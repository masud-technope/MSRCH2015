thread_ID, Id, ParentId, PostType, Score, CreationDate, OwnerID, Body
55454096,55454096,null,1,0,Mon Apr 01 11:30:00 EDT 2019,8686366,"<p>I got a stranger error although I follow guideline in ditto example.</p>		<p>Octopus can published messages to MQTT. I can see them use MQTT client.	WebApp shows connection established and send send event works. I can change values through <code>"my.test.octopus"</code>panel. But when I query it using API, I can only my values from webapp, never got vales from octopus.</p>		<p>I checked connectivity logs, seems mapping problem...I used the following to create mapping when creating connection:</p>		<pre><code>"incomingScript": "function mapToDittoProtocolMsg(	                              headers, 	                              textPayload, 	                              bytePayload, 	                              contentType) {		    const jsonString = String.fromCharCode.apply(null, new Uint8Array(bytePayload));	    const jsonData = JSON.parse(jsonString);	    const thingId = jsonData.thingId;	    const value = { 	      temp_sensor: { 	        properties: { 	          value: jsonData.temp 	        }	      },	      altitude: { 	        properties: { 	          value: jsonData.alt 	        }	      }	    };		    return Ditto.buildDittoProtocolMsg('my.test', thingId, 'things', 'twin', 'commands', 'modify', '/features', headers, value);	}"	</code></pre>		<p>Thanks for help</p>		<p><strong>update</strong></p>		<p>The error manifests in the following log line: </p>		<p>See the following log statement:</p>		<pre><code>"The message mapper configuration failed due to: unterminated regular expression literal (incomingScript#1) - in line/column #1/472," -- ""incomingScript": "function mapToDittoProtocolMsg(headers, textPayload, bytePayload, contentType) {var jsonData = JSON.parse(textPayload);const thingId = jsonData.thingId;const value = {temp_sensor: { properties: { value: jsonData.temp } }, altitude: { properties: { value: jsonData.alt } } }; return Ditto.buildDittoProtocolMsg('my.test', thingId, 'things', 'twin', 'commands', 'modify', '/features', headers, value); }"	</code></pre>	"
55454096,97648605,55454096,3,0,Tue Apr 02 07:02:00 EDT 2019,2576531,"What I don't get is that the mapping script is 402 characters long and in the log we see an error in column 472. Did you copy paste the script from somewhere else and possibly added some hidden characters?"
55454096,97866028,55454096,3,0,Tue Apr 09 02:04:00 EDT 2019,8686366,"something wrong with the terminal, I guess. Now it appears works. Thanks"
55454096,55455104,55454096,2,1,Mon Apr 01 12:26:00 EDT 2019,2576531,"<p>Your mapping script seems to work correctly. I created a unit test for it using the <a href="https://github.com/eclipse/ditto-examples/tree/master/payload-mapping-testing" rel="nofollow noreferrer">payload mapping testing from ditto-examples</a>.</p>		<p>This test looks like the following:</p>		<pre><code> @Test	 public void incomingBytePayloadMapping() throws IOException {	     final Resource incomingMappingFunction = new Resource("incomingScript.js");	     final PayloadMappingFunction underTest = PayloadMappingFunction.fromJavaScript(incomingMappingFunction.getContent());		     final Map&lt;String, String&gt; headers = new HashMap&lt;&gt;();	     headers.put("content-type", ContentTypes.APPLICATION_OCTET_STREAM.toString());	     headers.put("device_id", "the-thing-id");		     final byte[] bytePayload = "{\"thingId\":\"my.test.thing\",\"temp\":25.6,\"alt\":11}".getBytes();	     final ExternalMessage message = ExternalMessageFactory.newExternalMessageBuilder(headers)	             .withBytes(bytePayload)	             .build();		     final Resource expectedAdaptableJsonResource = new Resource("expectedAdaptable.json");	     final JsonObject expectedAdaptableJson = JsonFactory.newObject(expectedAdaptableJsonResource.getContent());	     final Adaptable expectedAdaptable = ProtocolFactory	             .jsonifiableAdaptableFromJson(expectedAdaptableJson)	             .setDittoHeaders(DittoHeaders.of(headers));		     PayloadMappingTestCase.assertThat(message)	             .mappedByJavascriptPayloadMappingFunction(underTest)	             .isEqualTo(expectedAdaptable)	             .verify();	 }	</code></pre>		<p><strong>incomingScript.js</strong></p>		<pre><code>function mapToDittoProtocolMsg(	    headers,	    textPayload,	    bytePayload,	    contentType) {		    const jsonString = String.fromCharCode.apply(null, new Uint8Array(bytePayload));	    const jsonData = JSON.parse(jsonString);	    const thingId = jsonData.thingId;	    const value = {	        temp_sensor: {	            properties: {	                value: jsonData.temp	            }	        },	        altitude: {	            properties: {	                value: jsonData.alt	            }	        }	    };		    return Ditto.buildDittoProtocolMsg('my.test', thingId, 'things', 'twin', 'commands', 'modify', '/features', headers,	                                       value);	}	</code></pre>		<p><strong>expectedAdaptable.json</strong></p>		<pre><code>{	  "topic": "my.test/my.test.thing/things/twin/commands/modify",	  "headers": {},	  "path": "/features",	  "value": {	    "temp_sensor": {	      "properties": {	        "value": 25.6	      }	    },	    "altitude": {	      "properties": {	        "value": 11	      }	    }	  }	}	</code></pre>		<p>So far this seems to work, but in this test I assume the following incoming bytePayload:</p>		<pre><code>final byte[] bytePayload = "{\"thingId\":\"my.test.thing\",\"temp\":25.6,\"alt\":11}".getBytes();	</code></pre>		<p>Could you somehow verify, that the byte payload your octopus is sending is looking correctly? Is the octopus really sending byte payload or is it text payload (application/json)?</p>		<p><strong>update</strong></p>		<p>According to the comment of <a href="https://stackoverflow.com/questions/55454096/no-messagemappingprocessor-available-in-ditto#comment97625595_55455104">Bob Su</a> the octopus is sending text payload.	In order to map this payload, you actually have to use the text payload instead of byte payload. In the following you'll see the updated incomingScript.</p>		<p><strong>incomingScript.js</strong></p>		<pre><code>function mapToDittoProtocolMsg(	    headers,	    textPayload,	    bytePayload,	    contentType) {		    var jsonData = JSON.parse(textPayload);	    const thingId = jsonData.thingId;	    const value = {	        temp_sensor: {	            properties: {	                value: jsonData.temp	            }	        },	        altitude: {	            properties: {	                value: jsonData.alt	            }	        }	    };		    return Ditto.buildDittoProtocolMsg('my.test', thingId, 'things', 'twin', 'commands', 'modify', '/features', headers,	                                       value);	}	</code></pre>		<p>The test can be adapted to:</p>		<pre><code>@Test	public void incomingTextPayloadMapping() throws IOException {	    final Resource incomingMappingFunction = new Resource("incomingScript.js");	    final PayloadMappingFunction underTest = PayloadMappingFunction.fromJavaScript(incomingMappingFunction.getContent());		    final Map&lt;String, String&gt; headers = new HashMap&lt;&gt;();	    headers.put("content-type", ContentTypes.APPLICATION_JSON.toString());	    headers.put("device_id", "the-thing-id");		    final ExternalMessage message = ExternalMessageFactory.newExternalMessageBuilder(headers)	            .withText("{\"thingId\":\"my.test.thing\",\"temp\":25.6,\"alt\":11}")	            .build();		    final Resource expectedAdaptableJsonResource = new Resource("expectedAdaptable.json");	    final JsonObject expectedAdaptableJson = JsonFactory.newObject(expectedAdaptableJsonResource.getContent());	    final Adaptable expectedAdaptable = ProtocolFactory	            .jsonifiableAdaptableFromJson(expectedAdaptableJson)	            .setDittoHeaders(DittoHeaders.of(headers));		    PayloadMappingTestCase.assertThat(message)	            .mappedByJavascriptPayloadMappingFunction(underTest)	            .isEqualTo(expectedAdaptable)	            .verify();	}	</code></pre>	"
55454096,97627060,55455104,3,0,Mon Apr 01 14:04:00 EDT 2019,2576531,"Did this solve your problem?"
55454096,97643083,55455104,3,0,Tue Apr 02 01:27:00 EDT 2019,8686366,"not yet.  Still have the same problem: "The message mapper configuration failed due to: unterminated regular expression literal (incomingScript#1) - in line/column #1/472,"  -- ""incomingScript": "function mapToDittoProtocolMsg(headers, textPayload, bytePayload, contentType) {var jsonData = JSON.parse(textPayload);const thingId = jsonData.thingId;const value = {temp_sensor: { properties: { value: jsonData.temp } }, altitude: { properties: { value: jsonData.alt } } }; return Ditto.buildDittoProtocolMsg('my.test', thingId, 'things', 'twin', 'commands', 'modify', '/features', headers, value); }""
55454096,97643131,55455104,3,0,Tue Apr 02 01:32:00 EDT 2019,8686366,"Problem in the between 'twin' and 'commands'.   can you send me a good curl command of createConnection + mapping ? many thanks"
55454096,97643928,55455104,3,0,Tue Apr 02 02:41:00 EDT 2019,8686366,"If i used Postman to post message, partially works.  Publish from webapp is successfully.  But receiving data still have problem.  we need some time to try and will post you updates."
55454096,97625595,55455104,3,0,Mon Apr 01 13:24:00 EDT 2019,8686366,"Yes, our octopus sending is correct. It is sending text payload ."
55454096,97625741,55455104,3,0,Mon Apr 01 13:28:00 EDT 2019,2576531,"If it's sending text payload you should adapt your payload mapping script in order to use the textPayload instead of byte payload. I'll update my answer"
