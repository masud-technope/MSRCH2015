thread_ID, Id, ParentId, PostType, Score, CreationDate, OwnerID, Body
33137712,33137712,null,1,12,Thu Oct 15 00:06:00 EDT 2015,145567,"<p>We need to build a server that can communicate with some embedded devices running a variant of Android. We need to be able to send commands to the device, and receive a response. A simple command might be asking the device for it's status. We won't have HTTP, so we need to have the client/device establish a connection with the server.</p>		<p>We were considering using MQTT as it has a lot of nice properties (QoS, lightweight, built for IoT), but it doesn't natively support a request response workflow. </p>		<p>We have considered building RPC on top of MQTT, but before we do I just wanted peoples thoughts on the matter. Would Websockets, WAMP, ZeroMQ be a better approach?</p>		<hr>		<p><strong>Edit:</strong></p>		<p><strong><code>Q1:</code></strong> Do we even need RPC?</p>		<p><strong><code>Q2:</code></strong> Is there an approach to building systems where I always send async type messages and still provide a good user experience?</p>		<p><strong><code>Q3:</code></strong> Any examples?</p>		<p>Looking for implementation examples and hands on experience of building an IoT communication system beyond a toy example with a single device.</p>	"
33137712,54677541,33137712,3,1,Fri Oct 30 20:47:00 EDT 2015,3666197,"Well, not being an expert on this field, I would go and ask StackOverflow Moderators (on Meta)."
33137712,54641061,33137712,3,1,Thu Oct 29 22:49:00 EDT 2015,145567,"Hmm, can I not reward it now? I didn't realise they expired."
33137712,54619921,33137712,3,0,Thu Oct 29 13:11:00 EDT 2015,3666197,"Dominic, where has your offered +500 points bounty lost?"
33137712,96914295,33137712,3,0,Sun Mar 10 04:22:00 EDT 2019,3258851,"@user3666197 I once did. [Change auto-awarded bounty after grace period](https://meta.stackoverflow.com/q/294873/3258851). It's all lost now."
33137712,33139741,33137712,2,5,Thu Oct 15 04:09:00 EDT 2015,5447821,"<p>Based on your requirement of a light weight request/response protocol for IoT, CoAP (<a href="http://coap.technology/" rel="noreferrer">http://coap.technology/</a>), an IETF standard, might be useful.  It's light weight, and you can build RESTful services on top of it.</p>		<p>The other thing worth to consider is the "data model" and "service interfaces" for your server. Choosing a standard-based communication protocol, such as HTTP, MQTT, CoAP, is important, but it might be equally important to choose standard-based interoperable sensor data model and interfaces, so that your application can be interoperable and don't need to worry it becomes obsolete soon. Open Geospatial Consortium (OGC) SensorThings API (<a href="http://ogc-iot.github.io/ogc-iot-api/" rel="noreferrer">http://ogc-iot.github.io/ogc-iot-api/</a>) might be an option to consider.  It is an open standard, and it's data model is based on ISO 19156 Observation and Measurement. </p>	"
33137712,33143760,33137712,2,3,Thu Oct 15 08:40:00 EDT 2015,2210944,"<p>I could suggest to use <strong><code>AMQP</code></strong> if one of your requirements is request/response pattern.	The <code>AMQP</code> protocol supports this pattern natively with a "correlation" mechanism between the request end the response.	In your environment you could try to use the Apache Qpid Proton in C of eventually all the available language bindings like Java (for you Android based system).</p>	"
33137712,54138024,33143760,3,2,Fri Oct 16 07:25:00 EDT 2015,2210944,"The RPC you see on RabbitMQ web site is AMQP 0.9.1 based (in part it's true for AMQP 1.0 too). You don't have builtin concepts of replyto queue and correlation id. A simple solution could be that a sender publish on a topic of the receiver and set inside it's payload information about the topic to reply and info about correlation. You need to build it on top of MQTT using topic and payload. You can imagine a solution like this http://www.bitreactive.com/mqtt-request-response/ see the section "How does it work?". Of course it's not the only solution."
33137712,54128276,33143760,3,1,Thu Oct 15 22:37:00 EDT 2015,145567,"Do you think it's feasible to implement RPC over MQTT? I.e. the request response model detailed here: (https://www.rabbitmq.com/tutorials/tutorial-six-python.html)"
33137712,33183707,33137712,2,6,Sat Oct 17 06:45:00 EDT 2015,3666197,"<p><sup>"<strong>one-size-fits-all</strong>" may sound as a "<em>smart</em>" slogan for T-shirts<br> but causes nightmare for ex-post attempts<br> to fix poorly designed architectures<br>once real-world implementations scale</sup>	<br><sub>"<strong>right-sizing</strong>" and "<strong>M</strong>inimum-<strong>V</strong>iable-<strong>P</strong>roduct" strategies for just-enough designs have much better chance to survive IoT scales and to keep <strong>costs-of-adaptation</strong> acceptable ( take just the scales of the recent VW global device firmware update, expected to have about -2.5% to -3.0% GDP adverse impacts on Germany and automotive supply chains in Hungary and former Czechoslovakia regions - <strong>Yes, co$t$ matter in <code>IoT</code> domain more than just the trivial count$</strong>.)<sub><br></p>		<hr>		<h2>A smart-fit tool for IoT domain-specific architecture is a must</h2>		<p>A first thing that ought to be born in mind is the fact, that <strong>IoT domain</strong> is by several orders of magnitude different from scales of the classical legacy computing architectures. Minimised local-resources ( by design, also mentioned above ), massive scales/counts with uncontrolled concurrency, immense synchronisation complications for <a href="https://stackoverflow.com/a/27347539/3666197"><strong>true parallelism</strong> ( if such system design is needed ), ref.: a <strong><code>PARALLEL</code></strong> v/s <strong><code>CONCURRENT SEQUENTIAL</code></strong> Disambiguation Link</a>.</p>		<p>Thus a proper selection of tools is needed in context with this given state.</p>		<p>While <strong><code>AMQP</code></strong> and other power-MQ tools are great for broker-based ( if well designed, the central MQ-broker need not be a single-point of failure &amp; remains "just" a performance bottleneck ) the overheads for architectures with IoT-devices are to be carefully validated, whether feasible.</p>		<h2>Broker-less ZeroCopy, ZeroSharing, ZeroBlocking, ZeroLatency<sub>(...almost)</sub></h2>		<p><a href="https://i.stack.imgur.com/HAf5W.png" rel="nofollow noreferrer"><img src="https://i.stack.imgur.com/HAf5W.png" alt="A PIPELINE pattern"></a>	While <code>AMQP</code> has opened doors for the broker-less powers of well known <strong><code>ZeroMQ</code></strong>, the same happened another step further when Martin SUSTRIK redefined the rules and came with <strong><code>nanomsg</code></strong>.</p>		<p><code>nanomsg</code>, besides it's portability and light-weight-ness or a just enough right-weight-ness sets itself a good candidate ready for <strong><code>IoT</code></strong> models of co-operation, giving your Project much more than the asked <strong><code>REQ</code></strong>/<strong><code>REP</code></strong> <sub>where needed</sub> -- more advanced behaviours, alike <strong><code>SURVEY</code></strong> <sub>one asks, all vote</sub><a href="https://i.stack.imgur.com/Is8wQ.png" rel="nofollow noreferrer"><img src="https://i.stack.imgur.com/Is8wQ.png" alt="A SURVEY pattern"></a><br><strong><code>BUS</code></strong><sub>decentralised routing</sub><br><a href="https://i.stack.imgur.com/W5t3k.png" rel="nofollow noreferrer"><img src="https://i.stack.imgur.com/W5t3k.png" alt="BUS-"></a> or <strong><code>PIPE</code></strong> <sub>a directed, one-way pipe</sub> are particularly attractive in distributed process compositions in massive sensoric networks and a lovely example</p>		<hr>		<p>Answers for ad-hoc added Questions:</p>		<p><strong><code>A1:</code></strong> Yes, if design architecture requires, <code>RPC</code> might be using the same uniform signalling framework ( not reinventing wheel or adding just-another-distributed layer just for <code>Remote Proceducer Call</code></p>		<p><strong><code>A2:</code></strong> Yes, <code>ZeroMQ</code> and similar broker-less almost Zero-Latency <code>nanomsg</code> framework from Martin SUSTRIK are a good fit for inter-process messaging/signalling services. <strong>Your top-level design decides</strong>, whether these powers get harnessed anywhere near to their <sup>(awfully magnific)</sup> full potential or wasted into underperforming usage-patterns. To have an idea of their limits, FOREX event-streams execute spurious blasts of event with less than microsecond resolution time-stamping. There you really need a framework, that is <kbd><strong>robust</strong></kbd> <sub>( to handle such blasts )</sub>, <kbd><strong>fast</strong></kbd> ( not to add unnecessary delays )</sub>, elastically <kbd><strong>linear-scaleable</strong></kbd> ( with inner abilities to handle load-balancing on demand in many-folds )</sub>. After hands-on experience I can confirm that my own team's creativity ( while highly appreciated and field-tested with many decades of successfull project achievements on the list ) is <strong>the very limiting factor</strong> for user-experience, not the <code>ZeroMQ</code> / <code>nanomsg</code> smart-frameworks.</p>		<p><strong><code>A3:</code></strong> Yes, for a few years already using <code>ZeroMQ</code> ( DLL/LIB-adaptations are currently in progress for a <code>nanomsg</code> port ) for remote (load-balanced) central logging ( soft-realtime minimum latency-motivated, off-loading of distributed agents' capabilities ). Unless your system span grows into space ( where round-trip latencies are easily in minutes-hours ) <strong>this <code>modus operandi</code></strong> is both <strong>smart</strong> &amp; <strong>close to "just-enough"-design ideals.</strong></p>	"
33137712,96914338,33183707,3,0,Sun Mar 10 04:29:00 EDT 2019,3258851,"The first part of this answer is complete gibberish."
33137712,33217249,33137712,2,1,Mon Oct 19 14:37:00 EDT 2015,472270,"<p>I'd advice not to create your own protocol, but use LoraWAN protocol, which already contains those join/accept (the same as request/response) protocols.</p>		<p><a href="http://lora-alliance.org/portals/0/specs/LoRaWAN%20Specification%201R0.pdf" rel="nofollow">Here's spec</a> of LoraWAN protocol - page 47 describes join/accept.</p>	"
33137712,33236401,33137712,2,1,Tue Oct 20 12:14:00 EDT 2015,5444034,"<p>Basically, rpc and message passing are functionally equivalent as I believe was formally proved by Prof Needham in Cambridge back in the 70's. As you say, MQTT has some nice transport properties designed to help with small footprint, intermittently connected devices.</p>		<p>The point about RPC is that is enables a synchronous, single thread style of programming. However, if you are using Android, it's kind of unlikely that you will really be prepared for a UI to synchronously wait for an RPC to complete. Therefore, my personal opinion is that I find it easier to use a straight messaging system, such as MQTT, and track the state of the transaction however you want, (state machine, state variable, whatever).</p>		<p>As far as non-toy examples of MQTT based UI, you could checkout our platform <a href="http://www.thingstud.io" rel="nofollow">http://www.thingstud.io</a>. With MQTT multiple devices are a non-issue, as the UI is not even aware if it is talking to one device or many.</p>		<p>Mike</p>	"
33137712,33314492,33137712,2,1,Sat Oct 24 04:15:00 EDT 2015,4992784,"<p>Can't speak to the other protocols but MQTT does have some features that you may want to look into:</p>		<p>If you are just trying to figure out whether a device is connected or not, you can use a feature called <a href="http://www.hivemq.com/blog/mqtt-essentials-part-9-last-will-and-testament" rel="nofollow">'last will'</a> to send a pre-determined message on timeout or disconnect. Using that and <a href="http://www.hivemq.com/blog/mqtt-essentials-part-6-mqtt-quality-of-service-levels" rel="nofollow">Quality-of-service levels</a> you should be able to keep track of the device state enough to know whether your messages are being received or not, and then monitor the publishing channels from the devices to process the responses.</p>	"
33137712,37594886,33137712,2,2,Thu Jun 02 14:35:00 EDT 2016,2633577,"<p>For those already using MQTT communications and want to have request/response over their service you can try <strong>replyer</strong> (<a href="https://github.com/netbeast/replyer" rel="nofollow">https://github.com/netbeast/replyer</a>), which is a strategy over MQTT packet structure and protocol, rather than a new one.</p>	"
33137712,42724003,33137712,2,1,Fri Mar 10 17:09:00 EST 2017,4733260,"<p>If you need just request/response protocol you can go for CoAP (<a href="http://coap.technology/" rel="nofollow noreferrer">http://coap.technology/</a>), it is like HTTP and has HTTP verb support.</p>		<p>MQTT comes under pub - sub model. Ideal speaking you need a third machine which runs MQTT broker. </p>	"
