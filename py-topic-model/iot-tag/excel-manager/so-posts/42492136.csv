thread_ID, Id, ParentId, PostType, Score, CreationDate, OwnerID, Body
42492136,42492136,null,1,29,Mon Feb 27 17:31:00 EST 2017,1685748,"<p>I am building an android app that needs to communicate over a WiFi network that will not have any internet access. The problem is that even when the WiFi is connected android chooses to use cellular/mobile data when no connection internet is present on the wifi network.</p>		<p>I have read many posts on the issue many of which involve rooting the device but that is not possible with a production app (rooting devices is <strong>not</strong> an option). other solution (like my code bellow) suggest using <code>bindProcessToNetwork()</code> which works perfectly on my Sony Z2 but not on other devices I have tested on (all running 6.0.1)</p>		<pre><code>private void bindToNetwork() {	    final ConnectivityManager connectivityManager = (ConnectivityManager) mActivity.getSystemService(Context.CONNECTIVITY_SERVICE);	    NetworkRequest.Builder builder;	    if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) {	        builder = new NetworkRequest.Builder();	        //set the transport type do WIFI	        builder.addTransportType(NetworkCapabilities.TRANSPORT_WIFI);	        connectivityManager.requestNetwork(builder.build(), new ConnectivityManager.NetworkCallback() {	            @Override	            public void onAvailable(Network network) {	                if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) {			                    connectivityManager.bindProcessToNetwork(null);	                    if (barCodeData.getSsid().contains("screenspace")) {	                        connectivityManager.bindProcessToNetwork(network);	                    }		                } else {	                    //This method was deprecated in API level 23	                    ConnectivityManager.setProcessDefaultNetwork(null);	                    if (barCodeData.getSsid().contains("screenspace")) {		                        ConnectivityManager.setProcessDefaultNetwork(network);	                    }	                }		                connectivityManager.unregisterNetworkCallback(this);	            }	        });	    }	}	</code></pre>	"
42492136,79372432,42492136,3,0,Wed Sep 13 18:36:00 EDT 2017,8291593,"You can try the solution I gave in this post: https://stackoverflow.com/questions/42329775/using-a-wifi-without-internet-connection/46165010#46165010"
42492136,42570495,42492136,2,2,Fri Mar 03 04:07:00 EST 2017,5012320,"<p>Could you try and set the global setting captive_portal_detection_enabled to 0 (false).</p>		<p>What's actually happening is that by default, everytime you connect to a wifi, the FW will test against a server (typically google) to see if it's a captive wifi (needs login). So if your wifi is not connected to google, this check will fail. After that, the device knows that wifi has no internet connection and simply will not autoconnect to it.</p>		<p>Setting this setting to 0, will avoid this check.</p>		<p>Programatically:	<code>Settings.Global.putInt(getContentResolver(), Settings.Global.CAPTIVE_PORTAL_DETECTION_ENABLED, 0);</code></p>		<p>Edit: You may need to use the string "captive_portal_detection_enabled" directly, instead of the constant that's not visible depending on Android version.</p>	"
42492136,72372338,42570495,3,3,Mon Mar 06 09:33:00 EST 2017,1685748,"this requires android.permission.WRITE_SECURE_SETTINGS which is not available. i specified in the question that roting is also not an option. http://stackoverflow.com/a/13045819/1685748"
42492136,72284763,42570495,3,0,Fri Mar 03 10:05:00 EST 2017,1685748,"`cannot resolve Settings.Global.CAPTIVE_PORTAL_DETECTION_ENABLED`"
42492136,72311074,42570495,3,0,Fri Mar 03 22:18:00 EST 2017,5012320,"@Lonergan6275 try using the string "captive_portal_detection_enabled" directly, instead of the constant that's not visible depending on version of Android you are using."
42492136,42693887,42492136,2,1,Thu Mar 09 11:13:00 EST 2017,549372,"<p>you'd need to disable mobile data in the Settings (not certain, if this can be done programmatically, which might be a possible option) - or take out the USIM;</p>		<p>else the common behavior is, that it will always fall back to the best available connection (while a connection with internet gateway might be preferred, because it is used by most application).</p>		<p>also see this <a href="https://android.stackexchange.com/a/114041/129380">answer</a>.</p>	"
42492136,44646994,42492136,2,0,Tue Jun 20 07:50:00 EDT 2017,5431173,"<p>You can check if wifi is connected then proceed else show a dialog to user asking him to connect to a wifi network</p>		<p>Since the method NetworkInfo.isConnected() is now deprecated in API-23, here is a method which detects if the Wi-Fi adapter is on and also connected to an access point using WifiManager instead:</p>		<pre><code>private boolean checkWifiOnAndConnected() {	    WifiManager wifiMgr = (WifiManager) getSystemService(Context.WIFI_SERVICE);		    if (wifiMgr.isWifiEnabled()) { // Wi-Fi adapter is ON		        WifiInfo wifiInfo = wifiMgr.getConnectionInfo();		        if( wifiInfo.getNetworkId() == -1 ){	            return false; // Not connected to an access point	        }	        return true; // Connected to an access point	    }	    else {	        return false; // Wi-Fi adapter is OFF	    }	}	</code></pre>	"
42492136,51470029,42492136,2,1,Sun Jul 22 23:24:00 EDT 2018,904907,"<p>You're in the right path, the solution is indeed with <a href="https://developer.android.com/reference/android/net/ConnectivityManager#bindProcessToNetwork(android.net.Network)" rel="nofollow noreferrer">ConnectivityManager.bindProcessToNetwork(network)</a>. This information was posted on the Android Developers Blog in this article: <a href="https://android-developers.googleblog.com/2016/07/connecting-your-app-to-wi-fi-device.html" rel="nofollow noreferrer">Connecting your App to a Wi-Fi Device</a>.</p>		<p>Looking into your code this <code>barCodeData.getSsid()</code> doesn't look that is getting the SSID of the currently connected wifi network. If that's the case your code will never successfully bind to the network.</p>		<p>Try replace your <em>if statement</em></p>		<pre><code>if (barCodeData.getSsid().contains("screenspace"))	</code></pre>		<p>With</p>		<pre><code>if (getNetworkSsid(context).equals("screenspace"))	</code></pre>		<p>Helper method in <strong>kotlin</strong> to retrieve the SSID of the connected wifi network</p>		<pre><code>private fun getNetworkSsid(context: Context?): String {	    // WiFiManager must use application context (not activity context) otherwise a memory leak can occur	    val mWifiManager = context?.applicationContext?.getSystemService(Context.WIFI_SERVICE) as WifiManager	    val wifiInfo: WifiInfo? = mWifiManager.connectionInfo	    if (wifiInfo?.supplicantState == SupplicantState.COMPLETED) {	        return wifiInfo.ssid.removeSurrounding("\"")	    }	    return ""	}	</code></pre>		<p>If still doesn't work please follow <a href="https://stackoverflow.com/a/51469732/904907">my complete solution</a> where I used the same method but with some extra checks. I tested it in the Android versions 5.1.1, 6.0, 6.0.1, 7.1.1 and 8.1.0.</p>	"
42492136,53728757,42492136,2,0,Tue Dec 11 16:49:00 EST 2018,7138404,"<p>Solution on Kotlin</p>		<pre><code>class ConnectWithoutInternetTest constructor(	private val mContext: Context,	private val connectivityManager: ConnectivityManager,	private val wifiManager: WifiManager	) {		private val mWifiBroadcastReceiver = object : BroadcastReceiver() {	    override fun onReceive(context: Context, intent: Intent) {	        when (intent.action) {	            WifiManager.NETWORK_STATE_CHANGED_ACTION -&gt; {	                val info = intent.getParcelableExtra&lt;NetworkInfo&gt;(WifiManager.EXTRA_NETWORK_INFO)	                val isConnected = info.isConnected		                val ssid: String? = normalizeAndroidWifiSsid(wifiManager.connectionInfo?.ssid)		                if (isConnected) {	                    val builder = NetworkRequest.Builder()	                    builder.addTransportType(NetworkCapabilities.TRANSPORT_WIFI)	                    connectivityManager.registerNetworkCallback(	                        builder.build(),	                        object : ConnectivityManager.NetworkCallback() {	                            override fun onAvailable(network: Network) {	                                super.onAvailable(network)	                                val networkInfo = connectivityManager.getNetworkInfo(network)	                                val networkSsid = networkInfo.extraInfo	                                if (networkSsid == ssid) {	                                    connectivityManager.unregisterNetworkCallback(this)	                                }	                            }	                        })	                }	            }	        }	    }	}		private fun init() {	    val intentFilter = IntentFilter()	    intentFilter.addAction(WifiManager.WIFI_STATE_CHANGED_ACTION)	    mContext.registerReceiver(mWifiBroadcastReceiver, intentFilter)	}		private fun destroy() {	    mContext.unregisterReceiver(mWifiBroadcastReceiver)	}		private fun normalizeAndroidWifiSsid(ssid: String?): String? {	    return ssid?.replace("\"", "") ?: ssid	}		fun connectToWifi(ssidParam: String, password: String?) {	    init()	    val ssid = "\"$ssidParam\""	    val config = wifiManager.configuredNetworks.find { it.SSID == ssid }	    val netId = if (config != null) {	        config.networkId	    } else {	        val wifiConfig = WifiConfiguration()	        wifiConfig.SSID = ssid	        password?.let { wifiConfig.preSharedKey = "\"$password\"" }	        wifiConfig.allowedKeyManagement.set(WifiConfiguration.KeyMgmt.NONE)	        wifiManager.addNetwork(wifiConfig)	    }		    wifiManager.disconnect()	    val successful = wifiManager.enableNetwork(netId, true)	}	</code></pre>	"
