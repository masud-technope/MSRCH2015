thread_ID, Id, ParentId, PostType, Score, CreationDate, OwnerID, Body
54156530,54156530,null,1,0,Sat Jan 12 03:23:00 EST 2019,3214029,"<p>I have a JSON object stored on a <code>table &gt; column</code>. Example of that JSON object is:</p>		<pre><code>{	  a :{	    data: [1, 2, 3]	  },	  b :{	    data: [4, 5, 6]	  }	}	</code></pre>		<p>And I have the schedulers for appending values on <code>a.data (named scheduler A)</code>, and <code>b.data (named scheduler B)</code>. The schedulers are working on a fashion of getting that JSON value from <code>table &gt; column</code> and appending the content.</p>		<p>Problem:</p>		<p>Here, <code>scheduler A</code> and <code>scheduler B</code> doesn't have any synchronization mechanism. And hence when <code>scheduler A</code> and <code>scheduler B</code> event of appending values occur at same time, <code>scheduler A</code> output will get override by <code>scheduler B</code> output or vice-versa.</p>		<p>What will be the mechanism to handle that synchronization? Since the JSON value will be dynamic in its behavior, I can't able to split that JSON objects on columns too, so I must should work on that JSON format.</p>	"
54156530,54158164,54156530,2,1,Sat Jan 12 09:13:00 EST 2019,5467450,"<p>For simplest case you can synchronize database access (for example have a dedicated object for reading/writing database, use this object in schedulers for accessing/modifying json data and synchronize on this object in schedulers).</p>		<p>Something like this:</p>		<p><strong>MockDB class</strong></p>		<pre><code>public class MockDB {		    private JSONObject json;		    public MockDB() {	        this.json = fillJSON();	    }		    // fill JSON object with test data	    private JSONObject fillJSON() {	        JSONObject json = new JSONObject();		        JSONObject map = new JSONObject();	        map.put("data", Arrays.asList(1));	        json.put("a", map);		        map = new JSONObject();	        map.put("data", Arrays.asList(11));	        json.put("b", map);		        return json;	    }		    public JSONObject getJSON() {	        return cloneJson(json);	    }		    public void setJSON(JSONObject newJson) {	        this.json = cloneJson(newJson);	    }		    // make a deep copy of JSON object	    private JSONObject cloneJson(JSONObject jsonObj) {	        JSONObject newJson = new JSONObject();	        for(Object key : jsonObj.keySet()) {	            if (jsonObj.get(key) instanceof JSONObject) {	                newJson.put(key, cloneJson((JSONObject) jsonObj.get(key)));	            } else if (jsonObj.get(key) instanceof JSONArray) {	                newJson.put(key, ((JSONArray)jsonObj.get(key)).clone());	            } else {	                newJson.put(key, jsonObj.get(key));	            }	        }	        return newJson;	    }	}	</code></pre>		<p><strong>Field updater class</strong></p>		<pre><code>public class ScheduledUpdater implements Runnable {		    private final MockDB database;	    private final String field;		    public ScheduledUpdater(MockDB database, String field) {	        this.database = database;	        this.field = field;	    }		    @Override	    public void run() {	        // here we should synchronize on a whole DB access object 	        // as we need get &amp; set to be atomic together	        JSONObject json;	        synchronized (database) {	            json = database.getJSON();		            JSONObject xData;	            xData = (JSONObject) json.get(field);	            Object obj = xData.get("data");	            List&lt;Integer&gt; array = new ArrayList&lt;&gt;((List&lt;Integer&gt;) obj);	            array.add(Collections.max(array) + 1); // add new item to json array	            xData.put("data", array);		            database.setJSON(json);	        }	        printValues(json);	    }		    private void printValues(JSONObject json) {	        JSONObject    ao = (JSONObject) json.get("a");	        List&lt;Integer&gt; ad = (List&lt;Integer&gt;) ao.get("data");	        JSONObject    bo = (JSONObject) json.get("b");	        List&lt;Integer&gt; bd = (List&lt;Integer&gt;) bo.get("data");	        System.out.println(String.format("a: %02d; b: %02d", Collections.max(ad), Collections.max(bd)));	    }		}	</code></pre>		<p><strong>Actual executor</strong></p>		<pre><code>    public static void main(String [] args) throws InterruptedException {		        MockDB database = new MockDB();		        System.out.println("starting tasks\n");		        ScheduledExecutorService executor = Executors.newScheduledThreadPool(2);	        executor.scheduleAtFixedRate(new ScheduledUpdater(database, "a"), 0, 1, TimeUnit.SECONDS);	        executor.scheduleAtFixedRate(new ScheduledUpdater(database, "b"), 0, 1, TimeUnit.SECONDS);		        // run test for 5 seconds	        executor.awaitTermination(5, TimeUnit.SECONDS);	        executor.shutdown();		        // let all threads to stop	        Thread.sleep(250);	        System.out.println("\ntasks stopped; json: " + database.getJSON());	    }	</code></pre>		<p>PS: besides you can check synchronisation primitives from java.util.concurrent package.</p>	"
