thread_ID, Id, ParentId, PostType, Score, CreationDate, OwnerID, Body
35096109,35096109,null,1,8,Fri Jan 29 23:43:00 EST 2016,1776942,"<p>Suppose I have an IoT device which I'm about to control (lets say switch on/off) and monitor (e.g. collect temperature readings). It seems MQTT could be the right fit. I could publish messages to the device to control it and the device could publish messages to a broker to report temperature readings. So far so good.</p>		<p>The problems start to occur when I try to design the API to control the device.</p>		<p>Lets day the device subscribes to two topics:</p>		<ul>	<li>/device-id/control/on</li>	<li>/device-id/control/off</li>	</ul>		<p>Then I publish messages to these topics in some order. But given the fact that messaging is typically an asynchronous process there are no guarantees on the order of messages received by the device.</p>		<p>So in case two messages are published in the following order:</p>		<ol>	<li>/device-id/control/on</li>	<li>/device-id/control/off</li>	</ol>		<p>they <em>could</em> be received in the reversed order leaving the device turned on, which can have dramatic consequences, depending on the context.</p>		<p>Of course the API could be designed in some other way, for example there could be just one topic</p>		<ol>	<li>/device-id/control</li>	</ol>		<p>and the payload of individual messages would carry the meaning of an individual message (on/off). So in case messages are published to this topic in a given order they are expected to be received in the exact same order on the device.</p>		<p>But what if the order of publishes to individual topics cannot be guaranteed? Suppose the following architecture of a system for IoT devices:</p>		<pre><code>                       / control service \	application -&gt; broker -&gt; control service -&gt; broker -&gt; IoT device	                       \ control service /	</code></pre>		<p>The components of the system are:</p>		<ul>	<li>an application which effectively controls the device by publishing messages to a broker</li>	<li>a typical message broker</li>	<li>a control service with some business logic</li>	</ul>		<p>The important part is that as in most modern distributed systems the control service is a distributed, multi instance entity capable of processing multiple control messages from the application at a time. Therefore the order of messages published by the application can end up totally mixed when delivered to the IoT device.</p>		<p>Now given the fact that most MQTT brokers only implement QoS0 and QoS1 but no QoS2 it gets even more interesting as such control messages could potentially be delivered multiple times (assuming QoS1 - see <a href="https://stackoverflow.com/a/30959058/1776942">https://stackoverflow.com/a/30959058/1776942</a>).</p>		<p>My point is that separate topics for control messages is a bad idea. The same goes for a single topic. In both cases there are no message delivery order guarantees.</p>		<p>The only solution to this particular issue that comes to my mind is message versioning so that old (out-dated) messages could simply be skipped when delivered after another message with more recent version property.</p>		<ul>	<li>Am I missing something?</li>	<li>Is message versioning the only solution to this problem? </li>	</ul>	"
35096109,35100326,35096109,2,1,Sat Jan 30 09:56:00 EST 2016,4607349,"<p>When state changes, send the new state immediately and after that periodically every x seconds. With this solution your systems gets into desired state, after some time, even when it temporarily disconnects from the network (low battery).</p>		<p>BTW: You did not miss anything.</p>	"
35096109,35100365,35096109,2,1,Sat Jan 30 10:01:00 EST 2016,504554,"<p>Apart from the comment that most brokers don't support QOS2 (I suspect you mean that a number of broker as a service offerings don't support QOS2, such as Amazon's AWS IoT service) you have covered most of the major points.</p>		<p>If message order really is that important then you will have to include some form of ordering marker in the message payload, be this a counter or timestamp.</p>	"
35096109,35156394,35096109,2,5,Tue Feb 02 14:40:00 EST 2016,1472222,"<p><strong>Am I missing something?</strong></p>		<p>Most definitely.  The example you brought up is a generic control system, being attached to some message-oriented scheme.  There are a number of patterns that can be used when referring to a message-based architecture.  <a href="https://msdn.microsoft.com/en-us/library/jj591577.aspx#sec6" rel="nofollow noreferrer">This article</a> by Microsoft categorizes message patterns into two primary classes:</p>		<ul>	<li><strong>Commands</strong> and</li>	<li><strong>Events</strong></li>	</ul>		<p>The most generic pattern of command behavior is to issue a command, then measure the state of the system to verify the command was carried out.  If you forget to verify, your system has an open loop. Such open loops are (unfortunately) common in IT systems (because it's easy to forget), and often result in bugs and other bad behaviors such as the one described above.  So, the proper way to handle a command is:</p>		<ol>	<li>Issue the command</li>	<li>Inquire as to the state of the system</li>	<li>Evaluate next action</li>	</ol>		<p>Events, on the other hand, are simply fired off. As the publisher of an event, it is not my business to worry about who receives the event, in what order, etc.  Now, it should also be pointed out that the use of any decent message broker (e.g. <a href="https://www.rabbitmq.com/" rel="nofollow noreferrer">RabbitMQ</a>) generally carries strong guarantees that messages will be delivered in the order which they were originally published.  <a href="https://stackoverflow.com/questions/21363302/rabbitmq-message-order-of-delivery"><em>Note that this does not mean they will be processed in order.</em></a></p>		<p>So, if you treat a command as an event, your system is guaranteed to act up sooner or later.</p>		<p><strong>Is message versioning the only solution to this problem?</strong></p>		<p>Message versioning typically refers to a property of the message class itself, rather than a particular instance of the class.  It is often used when multiple versions of a message-based API exist and must be backwards-compatible with one another.</p>		<p>What you are instead referring to is unique message identifiers. <code>Guids</code> are particularly handy for making sure that each message gets its own unique id.  However, I would argue that de-duplication in message-based architectures is an anti-pattern. One of the consequences of using messaging is that duplicates are possible, so you should try to design your system behaviors to be stateless and <a href="http://queue.acm.org/detail.cfm?id=2187821" rel="nofollow noreferrer">idempotent</a>. If this is not possible, it should be considered that messaging may not be the correct communication solution for the need.</p>		<p>Using the command-event dichotomy as an example, you could perform the following transaction:</p>		<ol>	<li>The controller issues the command, assigning a unique identifier to the command.</li>	<li>The control system receives the command and turns on.</li>	<li>The control system publishes the "light on" event notification, containing the unique id of the command that was used to turn on the light.</li>	<li>The controller receives the notification and correlates it to the original command.</li>	</ol>		<p>In the event that the controller doesn't receive notification after some timeout, the controller can retry the command.  Note that "light on" is an idempotent command, in that multiple calls to it will have the same effect.</p>	"
35096109,58248019,35156394,3,0,Mon Feb 08 11:19:00 EST 2016,1776942,"Thank you very much for your answer. It's very interesting, I'll definitely have a closer look at it. Nevertheless, I'll leave the question open for a while to see if there are more valuable approaches to this problem."
