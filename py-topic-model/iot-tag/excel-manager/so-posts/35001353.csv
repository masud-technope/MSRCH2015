thread_ID, Id, ParentId, PostType, Score, CreationDate, OwnerID, Body
35001353,35001353,null,1,2,Mon Jan 25 20:07:00 EST 2016,2554803,"<p>I am attempting to implement a sensor fault detection algorithm from a white paper I found here: <a href="http://www.hindawi.com/journals/mpe/2013/712028/ref/" rel="nofollow">http://www.hindawi.com/journals/mpe/2013/712028/ref/</a>	My math skills are decent, but this article does not give great detail on how everything is set up.</p>		<p>My current implementation looks something like the following: </p>		<pre><code>/*******************************************************************************	How this algorithm works:	    1) There exists W historical windows which hold the distribution objects (mean, variance)	        for that window. Each window is of size m (the sliding window size)	    2) There exists a current window which changes every iteration by popping the 	        oldest value into the buffer window.	    3) There exists a buffer window which takes the oldest values from the current window	        each iteration. Once the buffer window reaches size m	        it then becomes the newest historical window.	*******************************************************************************/		int m = 10; //Statistics sliding window size	float outlierDetectionThreshold; // The outlier detection threshold for sensor s, also called epsilon	List&lt;float&gt; U; // Holds the last 10 windows mean	List&lt;float&gt; V; // Holds the last 10 windows variance	List&lt;float&gt; CurrentWindow; // Holds the last m values		procedure GFD()	    do	        get a value vi 	        Detection(vi)	    while not end	return		procedure Detection(vi)	    init outlierDetectionThreshold	    init U and V, loading last m distribution characteristics from DB	    init CurrentWindow loading the last m - 1 values		    Xi; // What is this?	    Tau; // What is this?		    Insert vi into CurrentWindow // CurrentWindow now has the m latest values 		    float CurrentWindowMean = Mean(CurrentWindow)	    float CurrentWindowVariance = Variance(CurrentWindow)		    if (IsStuck(CurrentWindowVariance) or IsSpikes(vi))	        return	    If (IsOutlier(vi) and not IsRatStatChagne(vi))	        return;	    IsRatStatChagne(vi);	    return		procedure IsStuck(variance)	    if (variance == 0)	        return true;	    return false;		procedure IsSpike(windowMean, windowVariance, historicalMeans, historicalVariances, xi, tau)	    if ( (mean / Mean(historicalMeans)) &lt; xi)	        if ( (variance / Mean(historicalVariances)) &gt; tau)	            return true;	    return false;		procedure IsOutlier(historicalMeans, historicalVariances, outlierDetectionThreshold)	    // use historicalMeans and historicalVariances to calculate theta	    if (theta &gt; outlierDetectionThreshold)	        return true;	</code></pre>		<p>I am running into difficulty implementing the IsOutlier and IsRatStatChange functions.</p>		<ol>	<li>In IsSpike, how are xi and tau calculated, or what do they represent?</li>	<li>For the IsOutlier function, how is theta calculated?</li>	<li>For the IsRatStatStange function, I have not looked into as much yet, but does anyone have a solid grasp to write this?</li>	</ol>		<p>Any other insights you gleam would be most appreciated.	Thanks in advance.</p>	"
