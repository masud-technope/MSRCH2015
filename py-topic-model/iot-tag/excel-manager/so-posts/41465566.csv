thread_ID, Id, ParentId, PostType, Score, CreationDate, OwnerID, Body
41465566,41465566,null,1,1,Wed Jan 04 13:57:00 EST 2017,405894,"<p>I have a raspberry pi 3 with Windows 10 IoT. I would like to get the data from a sensor that sends pulses. Namely the Swiss Flow SF800 <a href="http://www.swissflow.com/sf800.html" rel="nofollow noreferrer">link</a>. This sensor will send out an amount of pulses equal to the amount of flow through the sensor. The datasheet says that I will send up to 2kHz.</p>		<p>My question is will the GPIO on the raspberry pi handle an interrupt frequency this high? I have looked into the lightning provider <a href="https://developer.microsoft.com/en-us/windows/iot/docs/lightningproviders" rel="nofollow noreferrer">https://developer.microsoft.com/en-us/windows/iot/docs/lightningproviders</a> which is supposed to be a huge performance gain but cannot find any documentation about what kind of performance I should expect.</p>	"
41465566,41478680,41465566,2,1,Thu Jan 05 06:38:00 EST 2017,6601582,"<p>There is no official bench marks of GPIO interrupt for now.</p>		<p>Here is <a href="https://developer.microsoft.com/en-us/windows/iot/docs/LightningPerformance" rel="nofollow noreferrer">Windows IoT Lightning Performance Testing</a>. It tested GPIO performance by toggling GPIO 5 between 0 and 1 at the fastest possible speed. It seems at least 17.4 kHz can be achieved.</p>		<p>And <a href="https://msdn.microsoft.com/en-us/windows/hardware/drivers/wdf/creating-an-interrupt-object" rel="nofollow noreferrer">GPIO interrupt event should be pushed into the queue</a> and will not be lost.</p>		<p>So, based on above information, for 2kHz, app will be able to handle such speed interrupt event in time and without missing.</p>		<p>Feel free to use it and if there is any concern please let me know.</p>	"
41465566,70225415,41478680,3,0,Fri Jan 06 16:21:00 EST 2017,405894,"I am going to run a test with an arduino to push pulses at the Pi and check my results. I will share them once I do."
41465566,41980095,41465566,2,0,Wed Feb 01 12:40:00 EST 2017,405894,"<p>Initially I suspected that I would need to use the lightning driver in order to achieve the interrupt frequency that I needed. It turns out that the standard Inbox Driver is adequate for what I need.</p>		<p>Here are the steps to reproduce my situation:</p>		<p>I created a simple Arduino sketch that would send out pulses at the rate of 10,000 Hz. </p>		<pre><code>int dataPin = 12;		void setup() {	    pinMode(dataPin, OUTPUT);	}		void loop() {	    int count = 0;	    while (count &lt; 400)	    {	        //pulse	        digitalWrite(dataPin, HIGH);	        digitalWrite(dataPin, LOW);	        //This delay presumably makes the pulse be 10000 Hz	        delayMicroseconds(100);	        count++;	    }	    delay(5000);	}	</code></pre>		<p>Created a UWP app with a simple UI that had a TextBlock in the center of the page. </p>		<pre><code> public sealed partial class MainPage : Page	    {	        private GpioController gpio;		        private const int inputPinNumber = 17;		        private GpioPin inputPin;		        private int count;		        private I2cController i2cController;		        private SpiController spiController;		        public MainPage()	        {	            this.InitializeComponent();	            this.Setup();	        }		        private void Setup()	        {	            if (LightningProvider.IsLightningEnabled)	            {	                LowLevelDevicesController.DefaultProvider = LightningProvider.GetAggregateProvider();	            }		            this.gpio = GpioController.GetDefault();			            this.inputPin = this.gpio.OpenPin(inputPinNumber);	            if (this.inputPin.IsDriveModeSupported(GpioPinDriveMode.InputPullUp))	            {	                this.inputPin.SetDriveMode(GpioPinDriveMode.InputPullUp);	            }	            else	            {	                this.inputPin.SetDriveMode(GpioPinDriveMode.Input);	            }		            this.inputPin.ValueChanged += InputPinOnValueChanged;	        }		        private void InputPinOnValueChanged(GpioPin sender, GpioPinValueChangedEventArgs args)	        {		            var task = Dispatcher.RunAsync(CoreDispatcherPriority.Normal, () =&gt; {	                if (args.Edge == GpioPinEdge.FallingEdge)	                {	                    this.count++;	                    this.CountBlock.Text = this.count.ToString();	                }	                else	                {	                    }	            });	        }	    }	}	</code></pre>		<p>Set Windows IoT to use the Direct Memory Mapped Driver.</p>		<p>The next step was to connect the pin on the Arduino with the pin on the Pi through a transistor. I did this so that I could take advantage of the built in Pull-Up resistor on the GPIO pins on the Pi.</p>		<p>When both applications were run at the same time I was only collecting about 30 pulses per cycle.</p>		<p>Went back into the Windows IoT setup and reset the driver back to the Inbox Driver and reran both applications. This time I did not miss a pulse.</p>		<p>In conclusion the Inbox Driver should be sufficient to give me up to 10khz without any issue.</p>	"
