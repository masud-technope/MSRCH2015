thread_ID, Id, ParentId, PostType, Score, CreationDate, OwnerID, Body
57804623,57804623,null,1,0,Thu Sep 05 11:36:00 EDT 2019,12024955,"<p>I am coming to you with a tiny problem. I'm trying to configure a coder (AMS 5601). This coder is behind a stepper motor. I'm using a raspberry. I detect well the coder with <code>sudo i2cdetect -y 1</code>. When i'm runnning my C code, i don't have any issue to write something into the coder memory. But if I'm using my golang code, then the program doesn't succeed to WriteBytes().</p>		<p>Here is the code in C:</p>		<pre><code>#include &lt;unistd.h&gt;             	#include &lt;fcntl.h&gt;              	#include &lt;sys/ioctl.h&gt;          //Needed for I2C port	#include &lt;linux/i2c-dev.h&gt;      //Needed for I2C port	#include &lt;stdio.h&gt;		unsigned char *ft_read_byte(int file_i2c, unsigned char *reg, int lenght) {	    unsigned char *buffer;	    if (write(file_i2c, reg, 1) != 1)	        printf("Failed to write to the i2c bus.\n");	    if (read(file_i2c, buffer, lenght) != lenght)	        printf("Failed to read from the i2c bus.\n");	    else {	        int i = 0;	        while (i &lt; lenght) {	            printf("byte NÂ°%d, read from :0x%x register : %d\n",i, reg[0], buffer[i]);	            i++;	        }	    }	    return buffer;	}		int ft_write_byte(int file_i2c, unsigned char reg, unsigned char value) {	    unsigned char data[2];	    data[0] = reg;	    data[1] = value;	    if (write(file_i2c, data, 2) != 2) {	        printf("failed to write on the i2c bus;\n");	        return -1;	    }	    sleep(1);	    return 0;	}		int main() // TODO implement permanent changes	{	    int file_i2c;	    int length;	    unsigned char *buffer_write = {0};	    unsigned char *data_0xC = {0};	    int addr = 0x36;   //&lt;&lt;&lt;&lt;&lt;The I2C address of the slave you have gotten with sudo i2cdetect -y 1 it will be always 0x36 for AMS 5601	    buffer_write[0] = 0x09; // Register of codeur sampling config	    buffer_write[1] = 0x05; // 0x08 = 0b1000 = sampling on 2048 positions 0x07 = 1024, 0x06 = 512, 0x05 = 256 (our goal for fine resolution), 0x04 = 128, 0x03 = 64, 0x02 = 32, 0x01 = 16, 0x00 = 8 (default case)	    length = 2;         //&lt;&lt;&lt; Number of bytes to write	    //----- OPEN THE I2C BUS -----	    char *filename = (char*)"/dev/i2c-1";	    if ((file_i2c = open(filename, O_RDWR)) &lt; 0)	    {	        //ERROR HANDLING: you can check errno to see what went wrong	        printf("Failed to open the i2c bus\n");	        return -1;	    }	    if (ioctl(file_i2c, I2C_SLAVE, addr) &lt; 0) // I2C_SLAVE = 0x0703 cf linux/i2c-dev.h	    {	        printf("Failed to acquire bus access and/or talk to slave.\n");	        //ERROR HANDLING; you can check errno to see what went wrong	        return -1;	    }	    ft_write_byte(file_i2c, buffer_write[0], buffer_write[1]);	    data_0xC = ft_read_byte(file_i2c, (unsigned char *)0xC, 1);	    return 0;	</code></pre>		<p>Here is a part of my code in Go:	package main</p>		<pre><code>import (	    "fmt"	    "github.com/d2r2/go-i2c"	    "log"	    "time"	    "os/exec" //for runing shell command into the program	//  "os"	    "encoding/binary"	)	func main(){	    var compensation uint16	    device, err := i2c.NewI2C(DeviceAdress, 1)	    if err != nil {	        fmt.Println("does not succeed to open \"/dev/i2c-1\"")	        //log.Fatal(err)	        //return	    }	//  defer device.Close()	//  _, err2 := device.WriteBytes([]byte{RegABN, Sampling1024}) // STEP 2	    _, err2 := device.WriteBytes([]byte{0x09, 0x05}) // STEP 2	    if err2 != nil {	        fmt.Println("does not succeed to write bytes")	        log.Fatal(err2)	    }	}	</code></pre>		<p>Here is the message I get:</p>		<pre><code>"2019-09-05T10:46:11.504 [     i2c] DEBUG  Write 2 hex bytes: [0905]	does not succeed to write bytes	2019/09/05 10:46:11 write /dev/i2c-1: remote I/O error"	</code></pre>		<p>Does I2C_SLAVE = 0x0703 have to be set somewhere?</p>	"
