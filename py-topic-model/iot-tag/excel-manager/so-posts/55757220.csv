thread_ID, Id, ParentId, PostType, Score, CreationDate, OwnerID, Body
55757220,55757220,null,1,1,Fri Apr 19 05:52:00 EDT 2019,8711769,"<p>I am relatively new to writing apps for Windows IoT.  I have a Windows IoT Background app that I want to spawn three separate threads from the main thread.  (The reason I want them to all be running in separate background threads is because some of the work they will do could be time consuming so I obviously don't want to block anything).</p>		<p><b>The first thread</b> is running a small web server.</p>		<p><b>The second thread</b> is listening to GPIO pins on a Raspberry PI.</p>		<p><b>The third thread</b> is to listen to devices via I2C.</p>		<p>For some reason, I can't seem to get all three threads to remain open. Here is my code from the StartupTask:</p>		<pre><code>public sealed class StartupTask : IBackgroundTask	{	    private static BackgroundTaskDeferral _Deferral = null;	    public async void Run(IBackgroundTaskInstance taskInstance)	    {	        _Deferral = taskInstance.GetDeferral();		        // do some stuff on the main thread here...		        // thread 1	        var webserver = new TestWebserver();	        await ThreadPool.RunAsync(workItem =&gt;	        {	            webserver.Start();	        });		        // thread 2	        var masterEventListener = new MasterEventListener();	        await ThreadPool.RunAsync(workItem =&gt;	        {	            masterEventListener.Start();	        });		        // thread 3	        var i2cEventListener = new I2CEventListener();	        await ThreadPool.RunAsync(workItem =&gt;	        {	            i2cEventListener.Start();	        });        	    }	}	</code></pre>		<p>Here is the shell for the first thread:</p>		<pre><code>internal class TestWebserver	{	    private const uint BufferSize = 8192;	    public async void Start()	    {	        var listener = new StreamSocketListener();	        await listener.BindServiceNameAsync(8081);		        listener.ConnectionReceived += async (sender, args) =&gt;	        {	            var request = new StringBuilder();	            using (var input = args.Socket.InputStream)	            {	                var data = new byte[BufferSize];	                IBuffer buffer = data.AsBuffer();	                var dataRead = BufferSize;		                while (dataRead == BufferSize)	                {	                    await input.ReadAsync(buffer, BufferSize, InputStreamOptions.Partial);	                    request.Append(Encoding.UTF8.GetString(data, 0, data.Length));	                    dataRead = buffer.Length;	                }	            }		            using (var output = args.Socket.OutputStream)	            {	                using (var response = output.AsStreamForWrite())	                {	                    string html = "TESTING RESPONSE";	                    using (var bodyStream = new MemoryStream(html))	                    {	                        var header = $"HTTP/1.1 200 OK\r\nContent-Length: {bodyStream.Length}\r\n\r\nConnection: close\r\n\r\n";	                        var headerArray = Encoding.UTF8.GetBytes(header);	                        await response.WriteAsync(headerArray, 0, headerArray.Length);	                        await bodyStream.CopyToAsync(response);	                        await response.FlushAsync();	                    }	                }	            }	        };	    }	}	</code></pre>		<p>Here is the shell for the second thread:</p>		<pre><code>internal class MasterEventListener	{	    public void Start()	    {	        GpioController gpio = GpioController.GetDefault();	        GpioPin gpioPin = gpio.OpenPin(4); // pin4		        if (gpioPin.IsDriveModeSupported(GpioPinDriveMode.InputPullUp))	        {	            gpioPin.SetDriveMode(GpioPinDriveMode.InputPullUp);	        }	        else	        {	            gpioPin.SetDriveMode(GpioPinDriveMode.Input);	        }		        gpioPin.Write(GpioPinValue.High);	        gpioPin.DebounceTimeout = TimeSpan.FromMilliseconds(25);	        gpioPin.ValueChanged += Pin_ValueChanged;	    }		    private void Pin_ValueChanged(GpioPin sender, GpioPinValueChangedEventArgs args)	    {	        bool value = sender.Read() == GpioPinValue.High;		        if (value)	        {	            Debug.WriteLine("OPEN!");	        }	        else	        {	            Debug.WriteLine("CLOSED!");	        }	    }	}	</code></pre>		<p>And here is the shell for the third thread:</p>		<pre><code>internal class I2CEventsListener	{	    public async void Start()	    {	        string aqs = I2cDevice.GetDeviceSelector();	        DeviceInformationCollection dis = await DeviceInformation.FindAllAsync(aqs);		        I2CThreadListener(dis);	    }		    private async void I2CThreadListener(DeviceInformationCollection dis)	    {	        while(true)	        {	            var settings = new I2cConnectionSettings(3); // I2C address 3	            settings.BusSpeed = I2cBusSpeed.FastMode;	            settings.SharingMode = I2cSharingMode.Shared;		            using (I2cDevice device = await I2cDevice.FromIdAsync(dis[0].Id, settings))	            {	                if (device != null)	                {	                    try	                    {	                        byte[] writeBuffer = Encoding.ASCII.GetBytes("000000");	                        byte[] readBuffer = new byte[7];		                        device.Write(writeBuffer);	                        device.Read(readBuffer);		                        var str = Encoding.Default.GetString(readBuffer);	                        if (str != null &amp;&amp; str.Trim().Length == 7 &amp;&amp; Convert.ToInt32(readBuffer[0]) &gt; 0)	                        {	                            Debug.WriteLine("RESULTS! '" + str + "'");	                        }	                    }	                    catch (Exception ex)	                    {	                        Debug.WriteLine(ex.Message);	                        Debug.WriteLine(ex.StackTrace);	                    }	                }	            }	            Thread.Sleep(100);	        }               	    });	}	</code></pre>		<p>If I comment out any of the two threads, the remaining thread will run indefinitely and work perfectly.  </p>		<p>If I comment out one thread, the remaining two threads work perfectly (sometimes)for about 30 seconds, and then one of the threads will terminate with a message like this:</p>		<pre><code>The thread 0xad0 has exited with code 0 (0x0).	</code></pre>		<p>I never get any error messages in my logs so I don't believe any kind of error is being thrown.</p>		<p>And I see the results I expect - so long as I am only running one of the threads.  But as soon as I have multiple threads running together, it causes problems.</p>		<p>Any direction would be greatly appreciated.</p>		<p>Thanks guys...</p>	"
55757220,98190142,55757220,3,0,Fri Apr 19 06:05:00 EDT 2019,4125422,"Maybe because of an exception. Does it show an exception message on the debug console?"
55757220,98190261,55757220,3,0,Fri Apr 19 06:12:00 EDT 2019,4125422,"But obviously you must have checked that yourself before asking."
55757220,98203501,55757220,3,0,Fri Apr 19 15:55:00 EDT 2019,8711769,"@RitaHan-MSFT - it does not appear to be hanging anywhere.  The reason I know the second thread is the one closing is that I have some logging in place.  Thread #1 (the webserver) continues to run (localhost:8081) and display a result.  But the I2C loop stops responding and outputting anything."
55757220,98249259,55757220,3,0,Mon Apr 22 05:57:00 EDT 2019,6601582,"@Mike Ok, in other words, have you tried set a breakpoint in I2C loop anywhere and the program execution can pause at the breakpoint? Because "`The thread 0xe80 has exited with code 0 (0x0).`" seems indicate the thread exited safely without any error."
55757220,98303571,55757220,3,0,Tue Apr 23 20:03:00 EDT 2019,8711769,"Hey guys - sorry I was out of town for the weekend...  I just edited my question above to be a little more clear with what is happening.  @RitaHan-MSFT - you are correct - the threads are exiting without any errors.  However, I do not want them to exit.  I want them to stay open and I can't figure out why they are terminating."
55757220,98193914,55757220,3,0,Fri Apr 19 09:16:00 EDT 2019,6601582,"@Mike If there is no exception you can check if it hangs anywhere. And how do you determine "The thread 0xe80" is the second thread for I2C?"
55757220,98190604,55757220,3,0,Fri Apr 19 06:29:00 EDT 2019,8711769,"No exception being hit. I am thinking it has something to do with either how I have the thread setup?  I am a bit new to the whole async/await concept so that wouldn't shock me at all!"
55757220,98191666,55757220,3,0,Fri Apr 19 07:24:00 EDT 2019,3859911,"Your code looks way over-complicated than it needs to be. You can spawn two tasks from your Main method using `Task.Run(async () => {  // your forever loop that needs to run in background }) `"
55757220,55826478,55757220,2,0,Wed Apr 24 09:15:00 EDT 2019,6601582,"<p>Based on your update code, although because the while loop in I2C thread prevent the Run method exit, so that local class variables(webserver etc.) will be always valid. And all necessary variables of I2C thread in the while loop so that they will be always valid. But local variables like <code>listener</code>, <code>gpio</code> and <code>gpioPin</code> will be collected by GC then invalid anymore after the method execute complete. Then the thread will exit.</p>		<p>To solve this issue I made some edits to your code and it works. You can have a try:</p>		<pre><code>public sealed class StartupTask : IBackgroundTask	    {	        private static BackgroundTaskDeferral _Deferral = null;	        private static TestWebserver webserver = null;	        private static MasterEventListener masterEventListener = null;	        private static I2CEventsListener i2cEventListener = null;		        public async void Run(IBackgroundTaskInstance taskInstance)	        {	            _Deferral = taskInstance.GetDeferral();		            // do some stuff on the main thread here...		            // thread 1	            webserver = new TestWebserver();	            await Windows.System.Threading.ThreadPool.RunAsync(workItem =&gt;	            {	                webserver.Start();	            });		            // thread 2	            masterEventListener = new MasterEventListener();	            await Windows.System.Threading.ThreadPool.RunAsync(workItem =&gt;	            {	                masterEventListener.Start();	            });		            // thread 3	            i2cEventListener = new I2CEventsListener();	            await Windows.System.Threading.ThreadPool.RunAsync(workItem =&gt;	            {	                i2cEventListener.Start();	            });		            Debug.WriteLine("The Run method exit...");	        }		        internal class TestWebserver	        {	            private StreamSocketListener listener = null;	            private const uint BufferSize = 8192;	            public async void Start()	            {	                listener = new StreamSocketListener();	                await listener.BindServiceNameAsync("8081");		                listener.ConnectionReceived += async (sender, args) =&gt;	                {	                    var request = new StringBuilder();	                    using (var input = args.Socket.InputStream)	                    {	                        var data = new byte[BufferSize];	                        IBuffer buffer = data.AsBuffer();	                        var dataRead = BufferSize;		                        while (dataRead == BufferSize)	                        {	                            await input.ReadAsync(buffer, BufferSize, InputStreamOptions.Partial);	                            request.Append(Encoding.UTF8.GetString(data, 0, data.Length));	                            dataRead = buffer.Length;	                        }	                    }		                    using (var output = args.Socket.OutputStream)	                    {	                        using (var response = output.AsStreamForWrite())	                        {	                            string html = "TESTING RESPONSE";	                            using (var bodyStream = new MemoryStream(Encoding.ASCII.GetBytes(html)))	                            {	                                var header = $"HTTP/1.1 200 OK\r\nContent-Length: {bodyStream.Length}\r\n\r\nConnection: close\r\n\r\n";	                                var headerArray = Encoding.UTF8.GetBytes(header);	                                await response.WriteAsync(headerArray, 0, headerArray.Length);	                                await bodyStream.CopyToAsync(response);	                                await response.FlushAsync();	                            }	                        }	                    }	                };	            }	        }		        internal class MasterEventListener	        {	            private GpioController gpio = null;	            private GpioPin gpioPin = null;		            public void Start()	            {		                gpio = GpioController.GetDefault();	                gpioPin = gpio.OpenPin(4); // pin4		                if (gpioPin.IsDriveModeSupported(GpioPinDriveMode.InputPullUp))	                {	                    gpioPin.SetDriveMode(GpioPinDriveMode.InputPullUp);	                }	                else	                {	                    gpioPin.SetDriveMode(GpioPinDriveMode.Input);	                }		                gpioPin.Write(GpioPinValue.High);	                gpioPin.DebounceTimeout = TimeSpan.FromMilliseconds(25);	                gpioPin.ValueChanged += Pin_ValueChanged;	            }		            private void Pin_ValueChanged(GpioPin sender, GpioPinValueChangedEventArgs args)	            {	                bool value = sender.Read() == GpioPinValue.High;		                if (value)	                {	                    Debug.WriteLine("OPEN!");	                }	                else	                {	                    Debug.WriteLine("CLOSED!");	                }	            }	        }		        internal class I2CEventsListener	        {	            public async void Start()	            {	                string aqs = I2cDevice.GetDeviceSelector();	                DeviceInformationCollection dis = await DeviceInformation.FindAllAsync(aqs);		                I2CThreadListener(dis);	            }		            private async void I2CThreadListener(DeviceInformationCollection dis)	            {	                var settings = new I2cConnectionSettings(3); // I2C address 3	                settings.BusSpeed = I2cBusSpeed.FastMode;	                settings.SharingMode = I2cSharingMode.Shared;		                I2cDevice device = await I2cDevice.FromIdAsync(dis[0].Id, settings);	                if (null == device)	                {	                    Debug.WriteLine("Get I2C device is NULL. Exiting...");	                }		                byte[] writeBuffer = Encoding.ASCII.GetBytes("000000");	                byte[] readBuffer = new byte[7];		                while (true)	                {	                    try	                    {	                        device.Write(writeBuffer);	                        device.Read(readBuffer);		                        var str = Encoding.Default.GetString(readBuffer);	                        if (str != null &amp;&amp; str.Trim().Length == 7 &amp;&amp; Convert.ToInt32(readBuffer[0]) &gt; 0)	                        {	                            Debug.WriteLine("RESULTS! '" + str + "'");	                        }	                    }	                    catch (Exception ex)	                    {	                        Debug.WriteLine(ex.Message);	                        Debug.WriteLine(ex.StackTrace);	                    }		                    Thread.Sleep(100);	                }	            }	        }			    }	</code></pre>		<p>It is suggested to create work items that are <strong>short-lived</strong> for using the thread pool. Refer to "<a href="https://docs.microsoft.com/en-us/windows/uwp/threading-async/best-practices-for-using-the-thread-pool" rel="nofollow noreferrer">Best practices for using the thread pool</a>".</p>		<p>For <strong>long time running</strong> task, for your case, if your three threads have no inter-communication you can create one <a href="https://docs.microsoft.com/en-us/windows/iot-core/develop-your-app/backgroundapplications" rel="nofollow noreferrer">background application</a> for each task individually.</p>	"
55757220,98343902,55826478,3,0,Thu Apr 25 00:29:00 EDT 2019,6601582,"@Mike You're welcome."
55757220,98340081,55826478,3,0,Wed Apr 24 20:26:00 EDT 2019,8711769,"Thanks!  I never would have guessed it was garbage collection of local variables, but you are correct.  That fixed my problem!  Not sure I could have figured that one out on my own, so thank you very much for your time!!!"
