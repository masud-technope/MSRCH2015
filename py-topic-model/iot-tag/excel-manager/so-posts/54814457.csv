thread_ID, Id, ParentId, PostType, Score, CreationDate, OwnerID, Body
54814457,54814457,null,1,0,Thu Feb 21 19:06:00 EST 2019,6927067,"<p>I have a really annoying issue with javascript in my Django project. Currently building a webbapp which reads data from sensors placed in manholes for water-temperature measurements. We display these sensors as markers on a Leafletmap with the pipe-system between each manhole.	I'm currently storing the sensor-id as a hidden variable in each manhole and then grabbing these to build a D3 graph displaying the temperature data for the specific manhole that has been clicked.</p>		<pre><code>onEachFeature: (feature, layer) =&gt; {		                    for (let i = 0; i &lt; place.length; i++) {		                        if (place[i].fields.pnamn === feature.properties.pnamn) {	                            sensorid = place[i].fields.eui;	                        }	                    }		                    var popupText = "&lt;strong&gt;" + feature.properties.pnamn + "&lt;p id='popupText' style='display:none'&gt;" + sensorid + "&lt;/p&gt;" + "&lt;/strong&gt;";	                    layer.bindPopup(popupText);	                },		[......] }).on('click', onClick).on('popupclose', startZoomer).addTo(map);	</code></pre>		<p>The id in question is the sensorid in the p-element. It works as it should, except for the extremely annoying fact that you can just click on a new manhole to update the graph without clicking twice on the new one or by clicking anywhere on the map.</p>		<p>I capture the sensorid in the function below and this is where I believe the problem is hiding. Can't really wrap my head around why this is happening and would appreciate any help at this point in time! </p>		<pre><code>                function onClick() {	                let id = document.getElementById("popupText").innerText;		                urlen = urlen.replace(/([A-Z])\w+/, id);	                console.log(id);	                console.log(urlen);		                var x = document.getElementById("chart-area");	                if (x.style.display === "none") {	                    x.style.display = "block";	                } else {	                    x.style.display = "block";	                }		                map.scrollWheelZoom.disable();			                update();		            }	</code></pre>		<p>Where the building of the new id for updating the graph is happening is the first 4 rows under the function initialization. The rest is for locking the map for mousewheel scroll when a popup is open so that user can scroll between the graph and map as they are stacked on top of eachother.</p>		<p>It's as I said extremely annoying for me and unacceptable when the system's put to use to have to click twice, and if you don't know this happens it can skew your view as it does update if you just click between manholes but you get the manhole you clicked before the current.</p>		<p>Please help me.</p>	"
54814457,54819125,54814457,2,0,Fri Feb 22 02:17:00 EST 2019,5108796,"<p>When the click event happens, most probably your new popup is not opened yet. This would explain why you find no element with matching id, or get the previous one.</p>		<p>You might have more luck using the "popupopen" event instead.</p>		<p>But in the first place, relying on scraping your sensor id from the popup text is a strange design, when you have control over the page code.</p>		<p>A more appropriate design would directly associate the sensor id with the Marker or its associated Feature, so that you can retrieve it easily on a Marker click event, instead of having to go through DOM querying.</p>		<p>For example in your onEachFeature:</p>		<pre><code>feature.properties.sensorid = sensorid	</code></pre>		<p>Then in your onClick listener:</p>		<pre><code>function onClick(event) {	  // the clicked layer is event.layer if the listener is on a Feature Group,	  // but is event.target if the listener is directly on that layer.	  const sensorid = event.layer.feature.properties.sensorid;	}	</code></pre>	"
54814457,96422944,54819125,3,0,Fri Feb 22 09:39:00 EST 2019,6927067,"Ok I will try this and see if it works! Thank you for the detailed answer."
54814457,96423008,54819125,3,0,Fri Feb 22 09:41:00 EST 2019,6927067,"I absolutely agree that it's a strange design, even a bad one.. Haven't really figured it out yet how to handle the scraping as the sensorid only exists within the leafletmarker-script and I can't seem to snatch it from anywhere else if I want to match it against the correct manhole-id"
