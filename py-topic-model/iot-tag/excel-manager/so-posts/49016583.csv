thread_ID, Id, ParentId, PostType, Score, CreationDate, OwnerID, Body
49016583,49016583,null,1,0,Tue Feb 27 19:33:00 EST 2018,2726634,"<p>I am collecting telemetry data from my sensor node to my raspberry pi through mqtt.There are 2 MQTT clients conected to a broker on localhost and broker on my VPS. The pi collects the data from the sensor node and sends it to my VPS server.</p>		<p>If the pi goes offline it will collect all the values in a local database and then, after reconnection, its supposed to send the messages one by one to the VPS.</p>		<p>Normally the messages are getting published one by one. But when it disconnects &amp; then reconnects it creates a thread "redundancywork()" and by the code it is supposed to publish messages one by one. </p>		<p>But this is what ends up happening:</p>		<pre><code>2018-02-28 00:29:00.304932,4.0,3.0,2.0,1.0,0.0	2018-02-28 00:29:01.074249,4.0,3.0,2.0,1.0,0.0	2018-02-28 00:29:01.496664,4.0,3.0,2.0,1.0,0.0	2018-02-28 00:29:01.912588,4.0,3.0,2.0,1.0,0.0	2018-02-28 00:29:02.264558,4.0,3.0,2.0,1.0,0.0	Message Published	Message Published	Message Published	Message Published	Message Published	</code></pre>		<p>It prints out the rows but publishes only AFTER the loop ends even though the publish function is within the loop. And after that it publishes normally one by one. The message does not get queued during disconnection as I set it that way. This is my code:</p>		<pre><code>from sqlalchemy import create_engine	from sqlalchemy.orm import sessionmaker	from model import SN1, Base	from datetime import datetime	import paho.mqtt.client as mqtt	import threading	import time	import os			#Topics to Subscribe to as (Topic Name, QOS Level)	topics = [("SN1",2)]	broker = "localhost"	portno = 1883			#Disconnect CHecker	DISCONNECT = "NO"			##Redundancy Stuff	redundancydb_url = 'sqlite:///redundancy.db'	redunandcy_engine = create_engine(redundancydb_url)	Base.metadata.bind = redunandcy_engine	if os.path.isfile("redundancy.db") is False:	    Base.metadata.create_all(redunandcy_engine)	redunandcysession = sessionmaker(bind = redunandcy_engine)	redundancydb = redunandcysession()			'''	Helper Methods	'''		#ToSubscribe	def on_connect(client, userdata, flags, rc):	    global DISCONNECT	    print("Connected with result code "+str(rc))	    # Subscribing in on_connect() means that if we lose the connection and	    # reconnect then subscriptions will be renewed.	    client.subscribe(topics)		    #CHECK IF VPS CLIENT	    if client._client_id == "VPS Client" and DISCONNECT == "YES":	        DISCONNECT = "NO"	        time.sleep(5)	        print("Redundancy Work Begins")	        thread = threading.Thread(target = redundancywork())	        thread.start()		#Message Processing	def on_message(client, userdata, msg):	    decoded = msg.payload.decode("utf-8")	    nowtime = datetime.now()	    message = decoded.split(",")	    print(message[0])	    global DISCONNECT	    global vpsclient			    #MESSAGE SENDING	    if message[0] == "SN1":	        if DISCONNECT == "NO":	            message_payload = "{},{},{},{},{},{}".format(nowtime, message[1], message[2], message[3], message[4], message[5])	            print(message_payload)	            vpsclient.publish("SN1", payload = message_payload, qos = 1)	        if DISCONNECT == "YES":	            newvalues = SN1(nowtime, message[1], message[2], message[3], message[4], message[5])	            redundancydb.add(newvalues)	            redundancydb.commit()	            print("Inserted to Redundancy DB")		def on_publish(client, userdata,mid):	    print("Message Published")		#Disconnection Handler	def on_disconnect(client, userdata, rc):	    print("Client {} has disconnected From Broker".format(client._client_id))	    global DISCONNECT	    DISCONNECT = "YES"		def redundancywork():	    #Get First Value of DB	    global vpsclient		    rdbsession = sessionmaker(bind = redunandcy_engine)	    rdb = rdbsession()	    first = rdb.query(SN1).first()	    print(first)		    #Check if length of firstrow is not 0	    while first is not None:	        message_payload = "{},{},{},{},{},{}".format(first.date, first.airtemp, first.humidity, first.watertemp, first.light, first.ph)	        print(message_payload)	        vpsclient.publish("SN1", payload = message_payload, qos = 1)	        #DELETE ROW	        rdb.delete(first)	        rdb.commit()		        #FETCH ROW	        first = rdb.query(SN1).first()	        time.sleep(2)		'''	Main Function	'''			if __name__ == "__main__":		    #Local Broker Client	    client = mqtt.Client()	    client._client_id = "Local Client"	    client.on_connect = on_connect	    client.on_message = on_message	    client.on_publish = on_publish	    client.on_disconnect = on_disconnect	    client.connect(broker, portno, keepalive = 20)		    #Vps Broker Client	    vpsbroker = "*"	    vpsportno = 1883	    global vpsclient	    vpsclient = mqtt.Client()	    vpsclient._client_id = "VPS Client"	    vpsclient.on_connect = on_connect	    vpsclient.on_publish = on_publish	    vpsclient.on_disconnect = on_disconnect	    vpsclient.max_inflight_messages_set(20)	    vpsclient.connect(vpsbroker, vpsportno, keepalive = 20)			while True:	    try:	        client.loop_start()	        vpsclient.loop_start()	    except Exception:	        continue	</code></pre>	"
49016583,85038876,49016583,3,0,Tue Feb 27 19:58:00 EST 2018,2726634,"I queued up about 50 rows. It was the exact same result. The 50 rows was printed and then the message got published only after the loop ended. I checked it on my server side and the messages were getting printed only after the loop ended."
49016583,86319016,49016583,3,1,Wed Apr 04 15:36:00 EDT 2018,464744,"Try replacing `threading.Thread(target = redundancywork())` with `threading.Thread(target = redundancywork)`. You're calling `redundancywork` in the main thread, not in a separate thread."
49016583,85038260,49016583,3,0,Tue Feb 27 19:40:00 EST 2018,464744,"Are you sure it doesn't just take 2 seconds for the four packets to be sent back and forth for QoS level 2? What happens when you queue up 100 rows instead of just 5?"
49016583,85038478,49016583,3,0,Tue Feb 27 19:46:00 EST 2018,2726634,"Let me try queueing up many rows."
49016583,86304527,49016583,3,0,Wed Apr 04 10:08:00 EDT 2018,2726634,"@Blender I tried QOS 0 also. Its sending messages only after the loop ends."
49016583,86471489,49016583,3,0,Mon Apr 09 08:49:00 EDT 2018,2726634,"@Blender Thanks! That fixed it!"
