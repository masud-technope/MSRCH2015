thread_ID, Id, ParentId, PostType, Score, CreationDate, OwnerID, Body
37178807,37178807,null,1,0,Thu May 12 06:24:00 EDT 2016,5168103,"<p>i am working on MQTT protocol. i configured its server and performed the communication in java using its mosquitto library on port 1883.	now i want to make this communication secure.What i know is port 8883 is reserved for its tls based secure communication.	It requires X.509 certiicates.	I found the following tutorial for this purpose.</p>		<p><a href="http://www.embedded101.com/Blogs/PaoloPatierno/entryid/366/mqtt-over-ssl-tls-with-the-m2mqtt-library-and-the-mosquitto-broker" rel="nofollow">http://www.embedded101.com/Blogs/PaoloPatierno/entryid/366/mqtt-over-ssl-tls-with-the-m2mqtt-library-and-the-mosquitto-broker</a></p>		<p>But my question are</p>		<p>1.how can we generate these certificates in java code?</p>		<p>2.how can we use multiple certificates at a time.As according to above tutorial we can specify only one set of ceritificates at a time in mosquitto.conf file of server.And then we need to restart the server.(that i dont want to do.)</p>		<p>3.how can we let a running server know about these newly generated certificates. Is there anyother way to do this except to specify in conf file of server?</p>	"
37178807,61893542,37178807,3,0,Thu May 12 07:24:00 EDT 2016,5168103,"moreiver, i want to know that can we start any mqtt broker in java?"
37178807,61896655,37178807,3,0,Thu May 12 08:44:00 EDT 2016,504554,"Why do you want to use multiple certificates?"
37178807,61896791,37178807,3,0,Thu May 12 08:47:00 EDT 2016,5168103,"if i am using multiple sensors for different use cases and each sensor communicates with the different topic on same broker."
37178807,37182050,37178807,2,1,Thu May 12 09:00:00 EDT 2016,504554,"<p>OK, I think you've miss understood how Certificate authentication works.</p>		<p>There are 2 parts to it (Proving the broker is who it says it is and then proving who the client connecting is)</p>		<p>Firstly the broker will have 1 certificate that identifies it to the world. You configure Mosquitto to use this certificate at startup and never need to change it. This certificate will be signed by a CA.</p>		<p>The sensors (clients) will have a copy of the CA cert which they will use when they connect to the broker to ensure it is who it claims to be.</p>		<p>Secondly if you want to use client certificates to identify the separate sensors then they will each need a certificate as well. Normally this will be signed by the same CA as the Broker certificate so the broker can verify the clients are who they claim to be. Mosquitto can be set up to use the CN from the certificates (<code>use_identity_as_username true</code>) as the username for the connecting clients and then you can use the <a href="https://github.com/jpmens/mosquitto-auth-plug" rel="nofollow noreferrer">mosquitto_auth_plugin</a> to keep track of the CN's in the certificates and apply ACLs to control who can use what topics.</p>		<p>As for creating certificates in java I suggest you look at this <a href="https://stackoverflow.com/questions/11383898/how-to-create-a-x509-certificate-using-java">question</a> </p>		<p>There is no need to restart Mosquitto when you issue a new cert.</p>	"
37178807,61897828,37182050,3,0,Thu May 12 09:10:00 EDT 2016,5168103,"Alright!@hardillb. 	but can u explain a bit about mosquitto_auth_plugin. As i dont find a way to use this in java eclipse project. 	Thank You."
37178807,61897890,37182050,3,0,Thu May 12 09:11:00 EDT 2016,504554,"You configure it in mosquitto, then you can use JDBC from java to push the new users/ACL entries into which ever database you have setup"
37178807,61898232,37182050,3,0,Thu May 12 09:19:00 EDT 2016,5168103,"okay. but i am new to all these things. can u share some developer guide or tutorial related to this? 	I will be much obliged to you."
37178807,61992448,37182050,3,0,Sat May 14 20:12:00 EDT 2016,5168103,"@hardillb.here are few more question. in mosquitto_auth_plugin we define backend databases holding username and password for authentication. how can we save certificates. as i am creating X509 rootCA for server and X509 certificates for client. i am quit confused about it."
37178807,61992722,37182050,3,0,Sat May 14 20:27:00 EDT 2016,504554,"If you have new questions post a new question"
37178807,62007476,37182050,3,0,Sun May 15 14:09:00 EDT 2016,5168103,"@hardillb.yes!!	here is post it.	http://stackoverflow.com/questions/37239255/mosquitto-secure-mqtt-connection"
37178807,54781439,37178807,2,0,Wed Feb 20 08:00:00 EST 2019,11088458,"<pre><code>    //add bcpkix-jdk15on-161, bcprov-jdk15on-1.52 and eclips pago-mqtt3.1 	    //lib in build path	    import java.io.*;	    import java.nio.file.*;	    import java.security.*;	    import java.security.cert.*;	    import java.security.spec.InvalidKeySpecException;	    import java.security.spec.PKCS8EncodedKeySpec;	    import java.security.spec.X509EncodedKeySpec;	    import javax.net.ssl.*;	    import org.bouncycastle.asn1.pkcs.PrivateKeyInfo;	    import org.bouncycastle.jce.provider.*;	    import org.bouncycastle.openssl.*;	    import org.bouncycastle.openssl.PasswordFinder;	    import org.bouncycastle.openssl.jcajce.JcaPEMKeyConverter;	    import org.bouncycastle.util.io.pem.PemObject;	    import org.bouncycastle.util.io.pem.PemReader;	    import org.eclipse.paho.client.mqttv3.MqttClient;	    import org.eclipse.paho.client.mqttv3.MqttConnectOptions;		    public class SslUtil	    {		        @SuppressWarnings("deprecation")	        //It will return SSLSocketFactory	        public static SSLSocketFactory getSocketFactory (final String 	       caCrtFile, final String crtFile, final String keyFile,                                                     	                   final String password) throws Exception	        {	            try{	                Security.addProvider(new BouncyCastleProvider());		                X509Certificate caCert = 	                (X509Certificate)SslUtil.getCertificate(caCrtFile);	                X509Certificate cert = 	                (X509Certificate)SslUtil.getCertificate(crtFile);	                FileReader fileReader = new FileReader(keyFile);	                PEMParser parser = new PEMParser(fileReader);	                PEMKeyPair kp = (PEMKeyPair) parser.readObject();		                PrivateKeyInfo info = kp.getPrivateKeyInfo();		                PrivateKey rdKey = new JcaPEMKeyConverter().setProvider("BC")	                        .getPrivateKey(info);		                // CA certificate is used to authenticate server	                KeyStore caKs = KeyStore.getInstance(KeyStore.getDefaultType());	                caKs.load(null, null);	                caKs.setCertificateEntry("ca-certificate", caCert);	                TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());	                tmf.init(caKs);		                // client key and certificates are sent to server so it can authenticate us	                KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());	                ks.load(null, null);	                ks.setCertificateEntry("certificate", cert);	                ks.setKeyEntry("private-key", rdKey, password.toCharArray(), new java.security.cert.Certificate[]{cert});	                KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());	                kmf.init(ks, password.toCharArray());		                // finally, create SSL socket factory	                SSLContext context = SSLContext.getInstance("TLSv1");	                context.init(kmf.getKeyManagers(), tmf.getTrustManagers(), null);		                return context.getSocketFactory();	            }catch (Exception e) {	                e.printStackTrace();	            }	            return null;	        }	       //Get MqttClient for Subscripe Pulish	        public static void mqttClient(String caCrtFile,String clientCrtFilePath,String clientKeyFilePath,String password){	            try{		            String serverUrl = "ssl://serverip:8883";	            MqttClient client = new MqttClient(serverUrl, "consumerId" , null);	//this MyCallback class extends mqtt there we have to override some function //like message arriver etc	            client.setCallback(new MyCallback());	            MqttConnectOptions options = new MqttConnectOptions();	            options.setConnectionTimeout(60);	            options.setKeepAliveInterval(60);	            options.setSocketFactory(SslUtil.getSocketFactory(caCrtFile, clientCrtFilePath, clientKeyFilePath, password));	            client.connect(options);	            client.subscribe("topic", 0);	            }catch (Exception e) {	                System.out.println("#Exception  :"+e.getMessage());	            }	        }	       //start execution	        public static void main(String[] args) throws Exception {	            String caCrtFile = "path Certification Authority";	            String clientCrtFilePath ="path for client crt file";	            String clientKeyFilePath ="path of client key";			            String password = "password while generating files";			        mqttClient(caCrtFile,clientCrtFilePath,clientKeyFilePath,password);	        //  getCertificate(caCrtFile);	        }		        //return certificate	        public static java.security.cert.X509Certificate getCertificate(String pemfile) throws Exception	        {	            java.security.cert.X509Certificate cert = null;	            try {	                FileReader fRd = new FileReader(pemfile);	                final PemReader certReader = new PemReader(fRd);	                final PemObject certAsPemObject = certReader.readPemObject();	                if (!certAsPemObject.getType().equalsIgnoreCase("CERTIFICATE")) {	                    throw new Exception("Certificate file does not contain a certificate but a " + certAsPemObject.getType());	                }	                final byte[] x509Data = certAsPemObject.getContent();	                final CertificateFactory fact = CertificateFactory.getInstance("X509");	                cert = (X509Certificate) fact.generateCertificate(new ByteArrayInputStream(x509Data));	                if (!(cert instanceof X509Certificate)) {	                    throw new Exception("Certificate file does not contain an X509 certificate");	                }		            } catch (FileNotFoundException e) {	                throw new IOException("Can't find file " + pemfile);	            }catch (Exception e) {	                System.out.println("#Exceotion :"+e.getMessage());	            }	            return cert;	        }		    //retuen keyPair Object form client key	        public KeyPair decodeKeys(byte[] privKeyBits,byte[] pubKeyBits) 	              throws InvalidKeySpecException, NoSuchAlgorithmException {	              KeyFactory keyFactory=KeyFactory.getInstance("RSA");	              PrivateKey privKey=keyFactory.generatePrivate(new 	              PKCS8EncodedKeySpec(privKeyBits));	              PublicKey pubKey=keyFactory.generatePublic(new 	              X509EncodedKeySpec(pubKeyBits));	              return new KeyPair(pubKey,privKey);	            }	    }	</code></pre>	"
