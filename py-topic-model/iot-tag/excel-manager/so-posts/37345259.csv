thread_ID, Id, ParentId, PostType, Score, CreationDate, OwnerID, Body
37345259,37345259,null,1,0,Fri May 20 11:14:00 EDT 2016,1049104,"<p>How can I send a message from paho java client to paho javascript client.</p>		<pre><code>    String topic        = "chatWith/904";	    String content      = "Message from MqttPublishSample";	    int qos             = 0;	    String broker       = "tcp://127.0.0.1:1883";	    String clientId     = "JavaSample";	    MemoryPersistence persistence = new MemoryPersistence();		    try {	        MqttClient sampleClient = new MqttClient(broker, clientId, persistence);	        MqttConnectOptions connOpts = new MqttConnectOptions();	        connOpts.setCleanSession(true);	        System.out.println("Connecting to broker: "+broker);	        sampleClient.connect(connOpts);	        System.out.println("Connected");	        System.out.println("Publishing message: "+content);	        MqttMessage message = new MqttMessage(content.getBytes());	        message.setQos(qos);	        sampleClient.publish(topic, message);	        System.out.println("Message published");	        sampleClient.disconnect();	        System.out.println("Disconnected");	        System.exit(0);	    } catch(MqttException me) {	        me.printStackTrace();	    }	</code></pre>		<p>Message exchange between two JS client is happening. But between Javasript &amp; java client, message exchange is not happening.</p>		<p>Here is JS code</p>		<pre><code> client = new Messaging.Client(host, Number(port), clientId);		  client.onConnect = onConnect;		  client.onMessageArrived = onMessageArrived;	  client.onMessageDelivered = onMessageDelivered;	  client.onConnectionLost = onConnectionLost;            	 var willMessage = createByteMessage({	        id: '',	        'msgType':'USER_STATUS',	        'status': 'Offline',	        'senderId': myUserId,	        'senderName': myName	    }, statusTopic);    	    willMessage.retained = true;  		  client.connect({	    userName:user, 	    password:password, 	    onSuccess:onConnect, 	    onFailure:onFailure,	    'willMessage': willMessage	  }); 	</code></pre>		<p>Here port is 8083 and mqtt broker is <a href="http://emqtt.io" rel="nofollow">emqtt</a></p>		<p><code>client.config</code></p>		<pre><code>testclientid0	testclientid1 127.0.0.1	testclientid2 192.168.0.1/24	</code></pre>		<p><code>emqttd.config</code></p>		<pre><code>% -*- mode: erlang;erlang-indent-level: 4;indent-tabs-mode: nil -*-	%% ex: ft=erlang ts=4 sw=4 et	[{kernel, [	    {start_timer, true},	    {start_pg2, true}	 ]},	 {sasl, [	    {sasl_error_logger, {file, "log/emqttd_sasl.log"}}	 ]},	 {ssl, [	    %{versions, ['tlsv1.2', 'tlsv1.1']}	 ]},	 {lager, [	    {colored, true},	    {async_threshold, 5000},	    {error_logger_redirect, false},	    {crash_log, "log/emqttd_crash.log"},	    {handlers, [	        %%{lager_console_backend, info},	        %%NOTICE: Level &gt;= error	        %%{lager_emqtt_backend, error},	        {lager_file_backend, [	            {formatter_config, [time, " ", pid, " [",severity,"] ", message, "\n"]},	            {file, "log/emqttd_error.log"},	            {level, error},	            {size, 104857600},	            {date, "$D0"},	            {count, 30}	        ]}	    ]}	 ]},	 {esockd, [	    {logger, {lager, error}}	 ]},	 {emqttd, [	    %% Authentication and Authorization	    {access, [	        %% Authetication. Anonymous Default	        {auth, [	            %% Authentication with username, password	            %{username, []},		            %% Authentication with clientid	            %{clientid, [{password, no}, {file, "etc/clients.config"}]},		            %% Authentication with LDAP	            % {ldap, [	            %    {servers, ["localhost"]},	            %    {port, 389},	            %    {timeout, 30},	            %    {user_dn, "uid=$u,ou=People,dc=example,dc=com"},	            %    {ssl, fasle},	            %    {sslopts, [	            %        {"certfile", "ssl.crt"},	            %        {"keyfile", "ssl.key"}]}	            % ]},		            %% Allow all	            {anonymous, []}	        ]},	        %% ACL config	        {acl, [	            %% Internal ACL module	            {internal,  [{file, "etc/acl.config"}, {nomatch, allow}]}	        ]}	    ]},	    %% MQTT Protocol Options	    {mqtt, [	        %% Packet	        {packet, [	            %% Max ClientId Length Allowed	            {max_clientid_len, 512},	            %% Max Packet Size Allowed, 64K default	            {max_packet_size, 65536}	        ]},	        %% Client	        {client, [	            %% Socket is connected, but no 'CONNECT' packet received	            {idle_timeout, 30} %% seconds	        ]},	        %% Session	        {session, [	            %% Max number of QoS 1 and 2 messages that can be â€œin flightâ€? at one time.	            %% 0 means no limit	            {max_inflight, 100},		            %% Retry interval for redelivering QoS1/2 messages.	            {unack_retry_interval, 60},		            %% Awaiting PUBREL Timeout	            {await_rel_timeout, 20},		            %% Max Packets that Awaiting PUBREL, 0 means no limit	            {max_awaiting_rel, 0},		            %% Statistics Collection Interval(seconds)	            {collect_interval, 0},		            %% Expired after 2 day (unit: minute)	            {expired_after, 2880}		        ]},	        %% Queue	        {queue, [	            %% simple | priority	            {type, simple},		            %% Topic Priority: 0~255, Default is 0	            %% {priority, [{"topic/1", 10}, {"topic/2", 8}]},		            %% Max queue length. Enqueued messages when persistent client disconnected,	            %% or inflight window is full.	            {max_length, infinity},		            %% Low-water mark of queued messages	            {low_watermark, 0.2},		            %% High-water mark of queued messages	            {high_watermark, 0.6},		            %% Queue Qos0 messages?	            {queue_qos0, true}	        ]}	    ]},	    %% Broker Options	    {broker, [	        %% System interval of publishing broker $SYS messages	        {sys_interval, 60},		        %% Retained messages	        {retained, [	            %% Expired after seconds, never expired if 0	            {expired_after, 0},		            %% Max number of retained messages	            {max_message_num, 100000},		            %% Max Payload Size of retained message	            {max_playload_size, 65536}	        ]},		        %% PubSub and Router	        {pubsub, [	            %% Default should be scheduler numbers	            {pool_size, 8},		            %% Store Subscription: true | false	            {subscription, true},		            %% Route aging time(seconds)	            {route_aging, 5}	        ]},		        %% Bridge	        {bridge, [	            %%TODO: bridge queue size	            {max_queue_len, 10000},		            %% Ping Interval of bridge node	            {ping_down_interval, 1} %seconds	        ]}	    ]},	    %% Modules	    {modules, [	        %% Client presence management module.	        %% Publish messages when client connected or disconnected	        {presence, [{qos, 0}]},		        %% Subscribe topics automatically when client connected	        {subscription, [		            %% $c will be replaced by clientid	            %% {"$queue/clients/$c", 1},		            %% Static subscriptions from backend	            backend	        ]}		        %% Rewrite rules	        %% {rewrite, [{file, "etc/rewrite.config"}]}	    ]},	    %% Plugins	    {plugins, [	        %% Plugin App Library Dir	        {plugins_dir, "./plugins"},		        %% File to store loaded plugin names.	        {loaded_file, "./data/loaded_plugins"}	    ]},		    %% Listeners	    {listeners, [	        {mqtt, 1883, [	            %% Size of acceptor pool	            {acceptors, 16},		            %% Maximum number of concurrent clients	            {max_clients, 512},		            %% Socket Access Control	            {access, [{allow, all}]},		            %% Connection Options	            {connopts, [	                %% Rate Limit. Format is 'burst, rate', Unit is KB/Sec	                %% {rate_limit, "100,10"} %% 100K burst, 10K rate	            ]},		            %% Socket Options	            {sockopts, [	                %Set buffer if hight thoughtput	                %{recbuf, 4096},	                %{sndbuf, 4096},	                %{buffer, 4096},	                %{nodelay, true},	                {backlog, 1024}	            ]}	        ]},		        {mqtts, 8883, [	            %% Size of acceptor pool	            {acceptors, 4},		            %% Maximum number of concurrent clients	            {max_clients, 512},		            %% Socket Access Control	            {access, [{allow, all}]},		            %% SSL certificate and key files	            {ssl, [{certfile, "etc/ssl/ssl.crt"},	                   {keyfile,  "etc/ssl/ssl.key"}]},		            %% Socket Options	            {sockopts, [	                {backlog, 1024}	                %{buffer, 4096},	            ]}	        ]},	        %% WebSocket over HTTPS Listener	        %% {https, 8083, [	        %%  %% Size of acceptor pool	        %%  {acceptors, 4},	        %%  %% Maximum number of concurrent clients	        %%  {max_clients, 512},	        %%  %% Socket Access Control	        %%  {access, [{allow, all}]},	        %%  %% SSL certificate and key files	        %%  {ssl, [{certfile, "etc/ssl/ssl.crt"},	        %%         {keyfile,  "etc/ssl/ssl.key"}]},	        %%  %% Socket Options	        %%  {sockopts, [	        %%      %{buffer, 4096},	        %%      {backlog, 1024}	        %%  ]}	        %%]},		        %% HTTP and WebSocket Listener	        {http, 8083, [	            %% Size of acceptor pool	            {acceptors, 4},	            %% Maximum number of concurrent clients	            {max_clients, 64},	            %% Socket Access Control	            {access, [{allow, all}]},	            %% Socket Options	            {sockopts, [	                {backlog, 1024}	                %{buffer, 4096},	            ]}	        ]}	    ]},		    %% Erlang System Monitor	    {sysmon, [	        %% Long GC, don't monitor in production mode for:	        %% https://github.com/erlang/otp/blob/feb45017da36be78d4c5784d758ede619fa7bfd3/erts/emulator/beam/erl_gc.c#L421	        {long_gc, false},		        %% Long Schedule(ms)	        {long_schedule, 240},		        %% 8M words. 32MB on 32-bit VM, 64MB on 64-bit VM.	        %% 8 * 1024 * 1024	        {large_heap, 8388608},		        %% Busy Port	        {busy_port, false},		        %% Busy Dist Port	        {busy_dist_port, true}		    ]}	 ]}	].	</code></pre>	"
37345259,62376161,37345259,3,0,Wed May 25 12:11:00 EDT 2016,2318649,"Does the JS client connect sauccessfully?, i.e do your javascript onSuccess/onConnect or onFailure/onFailure callback functions get called when the client tries to connect?"
37345259,62376217,37345259,3,0,Wed May 25 12:12:00 EDT 2016,1049104,"yes between two JS client its working find but between JS & JAVA  client its not exchanging messages"
37345259,62376301,37345259,3,0,Wed May 25 12:14:00 EDT 2016,2318649,"Do you mean "Yes the JS client is succeeding when it tries to connect because onSuccess is called"?"
37345259,62376363,37345259,3,0,Wed May 25 12:16:00 EDT 2016,2318649,"Shouldn't you include onMessageArrived in the client.connect() parameter?"
37345259,62376451,37345259,3,0,Wed May 25 12:18:00 EDT 2016,1049104,"r u talking about JS ? In js it is still there"
