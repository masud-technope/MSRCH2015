thread_ID, Id, ParentId, PostType, Score, CreationDate, OwnerID, Body
49363190,49363190,null,1,10,Mon Mar 19 12:38:00 EDT 2018,1016118,"<p>I am working on an IoT app in which there is an on boarding process where the user connects to an access point, which has not internet connectivity, configure the device and then connects to his home Wifi network.</p>		<p>Android 8 devices have been causing some problems, disconnecting from the access point and reconnecting to a previously configured network. I am assuming this is related to the connectivity update which was introduced in Android 8, from section Seamless Connectivity in <a href="https://developer.android.com/about/versions/oreo/android-8.0-changes.html" rel="noreferrer">this link</a>: </p>		<blockquote>	  <p>On compatible devices, automatic activation of Wi-Fi when a high	  quality saved network is nearby.</p>	</blockquote>		<p>My question is how to disable this behaviour as I need to stay connected to the access point, without internet connectivity, and finish the on Boarding process.</p>	"
49363190,85735167,49363190,3,0,Mon Mar 19 15:56:00 EDT 2018,2108972,"`automatic activation of Wi-Fi` ??? You are connected with wifi to that accespoint arent you? So wifi is activated already."
49363190,85726658,49363190,3,1,Mon Mar 19 12:44:00 EDT 2018,1016118,"@Yvette Colomb  I mean that the device automatically switches between the access point network, the one without internet access, and previously configured home network."
49363190,49531210,49363190,2,1,Wed Mar 28 09:44:00 EDT 2018,6445865,"<p>I had the same issue. What I did is adding a step to the boarding process where I invite the user to go to there settings, add manually this network with no data and accept the popup shown by the system.</p>		<p>I have not found a real solution yet.	However, I've seen an app called eWeLink where they manage to do it, but it is not an open source project.</p>	"
49363190,86261533,49531210,3,2,Tue Apr 03 10:04:00 EDT 2018,1016118,"The issue is that Android O introduced a "smart" mechanism to switch between networks, letting the OS decide what's good for you. I've tried hacking the wifi configuration with reflection as well as registering network callback to prefer networks without internet connectivity and use their socket factory. My attempts have not been successful and I chose the same solution you did. From reading the WifiConfiguration Android sources it seems this is the best way to go.	There is also another option which I have yet to try and that is to bind a socket to the specific network."
49363190,87527605,49531210,3,0,Wed May 09 13:49:00 EDT 2018,6445865,"I would be interested if you succeed doing it to see your solution if you're willing to share it. I had no more time to spend on it..."
49363190,49991619,49363190,2,1,Tue Apr 24 00:10:00 EDT 2018,9679688,"<p>I am currently facing the same issue right now for the newer phone with Android 8.+.  I am using WifiManager call  <code>bindProcessToNetwork</code> <a href="https://developer.android.com/reference/android/net/ConnectivityManager.html#bindProcessToNetwork(android.net.Network)" rel="nofollow noreferrer">here</a> this will allows data traffic go through the wifi with no internet access, </p>		<p>here how I connect my phone to the access point</p>		<pre><code>//Method to connect to WIFI Network	public boolean connectTo(String networkSSID, String key) {	    WifiConfiguration config = new WifiConfiguration();	    WifiInfo info = wifi.getConnectionInfo(); //get WifiInfo	    int id = info.getNetworkId(); //get id of currently connected network		    config.SSID = "\"" + networkSSID + "\"";	    if (key.isEmpty()) {	        config.allowedKeyManagement.set(WifiConfiguration.KeyMgmt.NONE);	    }	    int netID = wifi.addNetwork(config);		    int tempConfigId = getExistingNetworkId(config.SSID);		    if (tempConfigId != -1) {	        netID = tempConfigId;	    }		    boolean disconnect = wifi.disconnect();	    wifi.disableNetwork(id); //disable current network	    boolean enabled = wifi.enableNetwork(netID, true);	    boolean connected = wifi.reconnect();		if (((Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M))	                    || ((Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP)	                            &amp;&amp; !(Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M))) {		                final ConnectivityManager manager = (ConnectivityManager) context	                        .getSystemService(Context.CONNECTIVITY_SERVICE);	                NetworkRequest.Builder builder;	                builder = new NetworkRequest.Builder();	                //set the transport type do WIFI	                builder.addTransportType(NetworkCapabilities.TRANSPORT_WIFI);		                manager.requestNetwork(builder.build(), new ConnectivityManager.NetworkCallback() {	                    @Override	                    public void onAvailable(Network network) {	                        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) {	                            manager.bindProcessToNetwork(network);	                        } else {	                            ConnectivityManager.setProcessDefaultNetwork(network);	                        }	                        try {	                        } catch (Exception e) {	                            e.printStackTrace();	                        }	                        manager.unregisterNetworkCallback(this);	                    }	                });	            }	</code></pre>		<p>after connecting to the access point created by the device, it will constantly drop off from it. </p>	"
49363190,51955415,49363190,2,1,Tue Aug 21 19:24:00 EDT 2018,4076622,"<p>I had same issue. This is how I fix this issue in Android 8+ devices. 	1. Since Android 8+ devices auto switch between WiFI and Cellular devices. I removed below code. i.e. Code to force move to wifi.</p>		<pre><code>if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) {	    NetworkRequest.Builder request = new NetworkRequest.Builder();	    Log.i("forceCellularConnection","request WIFI enable");	    request.addCapability(NetworkCapabilities.TRANSPORT_WIFI);	    connectivityManager.requestNetwork(request.build(), new ConnectivityManager.NetworkCallback() {	          @Override	          public void onAvailable(Network network) {	               if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) {	                      connectivityManager.setProcessDefaultNetwork(network);		                      connectivityManager.bindProcessToNetwork(network);	                }	           }	     });		}	</code></pre>		<ol start="2">	<li><p>Also added below code to forget wifi connection before we make new connection. It takes some time for device to disconnect WiFI. So I added delay before connecting to new WIFI SSID.</p>		<pre><code>this.wifiManager.disableNetwork(configuration.networkId);	this.wifiManager.removeNetwork(configuration.networkId);	this.wifiManager.saveConfiguration(); // Not needed in API level 26 and above	</code></pre></li>	</ol>		<p>Workaround which I tried and helped me making connection work are below: In my case also I have to connect WiFi which doesn't have internet on it. Its a peer to peer connection.  </p>		<ol>	<li><p>I Made 2-3 attempts for connection </p>		<pre><code>new CountDownTimer(16000, 2000) {	</code></pre></li>	<li><p>Also I have written below broadcast receiver to check the state of WiFI. And then made the connection.</p>		<pre><code>private final BroadcastReceiver broadcastReceiver = new BroadcastReceiver() 	{	    @Override	    public void onReceive(Context context, Intent intent) {		        final String action = intent.getAction();		        Log.d("WifiReceiver", "&gt;&gt;&gt;&gt;SUPPLICANT_STATE_CHANGED_ACTION&lt;&lt;&lt;&lt;&lt;&lt;");	        SupplicantState supl_state = ((SupplicantState) intent	                .getParcelableExtra(WifiManager.EXTRA_NEW_STATE));	        switch (supl_state) {	        case ASSOCIATED:	            Log.i("SupplicantState", "ASSOCIATED");	            // authMsg = "ASSOCIATED";	            break;	        case ASSOCIATING:	            // authMsg = "ASSOCIATING";	            Log.i("SupplicantState", "ASSOCIATING");	            break;	        case AUTHENTICATING:	            // authMsg = "AUTHENTICATING";	            Log.i("SupplicantState", "Authenticating...");	            break;	        case COMPLETED:	            authMsg = "CONNECTED";	            Log.i("SupplicantState", "Connected");	             final ConnectivityManager connection_manager =	             (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);		            NetworkRequest.Builder request = new NetworkRequest.Builder();	            request.addTransportType(NetworkCapabilities.TRANSPORT_WIFI);		            connection_manager.registerNetworkCallback(request.build(), new ConnectivityManager.NetworkCallback() {		                @Override	                public void onAvailable(Network network) {	                    ConnectivityManager.setProcessDefaultNetwork(network);	                }	            });	            break;	        case DISCONNECTED:	</code></pre></li>	</ol>	"
49363190,53333375,49363190,2,1,Fri Nov 16 07:38:00 EST 2018,2593499,"<p>Just wanted to add a bit to the discussion. I've been using bindProcessToNetwork for a while and it does fix the loss of WiFi when connected to one without a network as described by Shawn Chen.  This is a heavy handed solution that makes it difficult to use Mobile network at the same time.  However, the routing layer is rather broken on Android somewhere around 6 where they started forcing request to mobile even though the routing table indicates the wifi device.</p>		<p>Anyway, you can actually bind at a socket level which I describe below.  This may help when the process has been bound to the WiFi network and you still want to use mobile.  Instead of looking up WiFi (which is what I was experimenting with instead of binding the process), you look up the mobile 'Network' object and build a socket to it.</p>		<p>What we need is something that indicates to android not to drop the WiFi connection.</p>		<p>HttpUrlConnection doesn't allow you to get the socket so you can use okhttp to do it at the per-connection level.  I'm using 2.7.5 of OkHttp but it is very similar for the 3+ version of OkHttp.</p>		<p>You get the current networks then process each to find WiFi network.</p>		<pre><code>Network[] networks = connectivityManager.getAllNetworks();	</code></pre>		<p>Then you build the url like:</p>		<pre><code>String url = "http://someurl";	HttpUrlConnection uconn = new OkUrlFactory( new OkHttpClient().setSocketFactory(network.getSocketFactory())).open(url)	</code></pre>		<p>This all works fine for a few connections and sometimes it works for the series of connections I used.  Android is using the knowledge that activity is happening over the network but any pauses and it jumps back to using mobile.  Android 9 wifi is just flawed and haven't figured out how to make it sticky using the socket solution.  There may be one.</p>	"
49363190,95073750,53333375,3,0,Thu Jan 10 01:29:00 EST 2019,2456270,"on Android 9 i found out that the System Dialog WifiNoInternetDialog https://android.googlesource.com/platform/packages/apps/Settings/+/master/src/com/android/settings/wifi/WifiNoInternetDialog.java can solve this Problem... but you can't open it without root, if you do you just get a SeuritiyException (as expected)"
