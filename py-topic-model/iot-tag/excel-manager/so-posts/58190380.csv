thread_ID, Id, ParentId, PostType, Score, CreationDate, OwnerID, Body
58190380,58190380,null,1,2,Tue Oct 01 18:26:00 EDT 2019,7903770,"<p>I'm using an react native app to communicate with my miband 3, and part of its authentication process is encrypt a array of bytes using AES/ECB/NoPadding algorithm. I'm currently using <a href="https://github.com/yogeshojha/MiBand3/blob/master/auth.py" rel="nofollow noreferrer">this code as reference</a></p>		<p>Since I'm new to iot and encryption, I suppose that <a href="https://medium.com/@yogeshojha/i-hacked-xiaomi-miband-3-and-here-is-how-i-did-it-43d68c272391" rel="nofollow noreferrer">the lest step of its authentication</a> is incorrect because and after writing to the miband 3 the encrypted byte array, I'm not getting authenticated properly. </p>		<p>Currently the last step looks like this: </p>		<pre><code>const base_key = [0x01,0x23,0x45,0x67,0x89,0x01,0x22,0x23,0x34,0x45,0x56,0x67,0x78,0x89,0x90,0x02]	console.warn('Getting random number...')	const random_number = bytesToString(notification.filter((byte, index) =&gt; index &gt; 3))		// Encrypting the key	const key = bytesToString(base_key)	const cipher = CryptoJS.AES.encrypt(random_number,key).toString()		// Step 5) Sending encrypted random number	console.warn('sending encrypted random number...')	const request_send_encrypted_key = [0x03,0x00, ...stringToBytes(cipher)]	await BleManager.writeWithoutResponse(miband3, service_uuid, characteristic_uuid, request_send_encrypted_key)	</code></pre>		<p>Notification is filtered because the first 3 bytes are used to tell which notification is happening, so I do not need them. </p>		<p>I must send the following to the miband 3 in order to authenticate properly:</p>		<pre><code>const byteArrayToSend = [0x03,0x00, ...encryptedByteArray]	</code></pre>		<p><strong>encryptedByteArray</strong> being my random number returned from miband notification (without the first 3 bytes) and properly encrypted .</p>		<p>I'm using 'crypto-js' and <a href="https://github.com/innoveit/react-native-ble-manager" rel="nofollow noreferrer">'react-native-ble-manager'</a> in the code.</p>		<p>How do I properly encrypt this bytearray using AES algorithm in order to send it?</p>	"
58190380,58202929,58190380,2,1,Wed Oct 02 13:49:00 EDT 2019,9014097,"<p>The following must be taken into account for AES-encryption using <code>CryptoJS</code>:</p>		<ul>	<li><p>In the posted code, keys and data to be encrypted (<code>random_number</code>) are obviously specified as arrays. <a href="https://cryptojs.gitbook.io/docs/" rel="nofollow noreferrer"><code>CryptoJS</code></a> uses <code>WordArray</code>-objects, so a conversion is necessary. <code>WordArray</code>-objects can easily be converted over hexadecimal strings into arrays and vice versa using <a href="https://stackoverflow.com/a/34356351/9014097">these</a> functions and the <code>CryptoJS</code>-<a href="https://cryptojs.gitbook.io/docs/#encoders" rel="nofollow noreferrer">Encoders</a>. Another possibility is the direct conversion using <a href="https://gist.github.com/artjomb/7ef1ee574a411ba0dd1933c1ef4690d1" rel="nofollow noreferrer">these</a> functions (not tested). </p></li>	<li><p>Since the arrays contain arbitrary byte-sequences (in the sense that they generally do not correspond to any readable characters), only suitable encodings (Base64 or hexadecimal) may be used here. The methods <code>bytesToString</code> and <code>stringToBytes</code> were not posted, so it is unclear if there is a problem. <code>CryptoJS</code> allows to pass the data as string or <code>WordArray</code>, where the latter is used in the following.</p></li>	<li><p>If the second parameter in <code>CryptoJS.AES.encrypt</code> is passed as a string, it is interpreted as a passphrase from which the actual key is generated according to a defined algorithm, <a href="https://cryptojs.gitbook.io/docs/#the-cipher-input" rel="nofollow noreferrer">here</a>. If the second parameter is to be interpreted as a key (and this seems to be the case in the <a href="https://github.com/yogeshojha/MiBand3/blob/master/auth.py" rel="nofollow noreferrer">reference code</a>), then it must be passed as a <code>WordArray</code>.</p></li>	<li><p><code>AES/ECB/NoPadding</code> is used for encryption according to the linked <a href="https://medium.com/@yogeshojha/i-hacked-xiaomi-miband-3-and-here-is-how-i-did-it-43d68c272391" rel="nofollow noreferrer">Medium-article</a>. The disabling of padding is only possible because the data to be encrypted (<code>random_number</code> with a length of 16 bytes according to the article) corresponds to an integer multiple of the AES block size (16 bytes) (if this were not the case, padding would have to be mandatory). </p></li>	<li><p>The result of the encryption is a <code>CipherParams</code>-object whose <code>ciphertext</code>-property contains the encrypted data as a <code>WordArray</code>, <a href="https://cryptojs.gitbook.io/docs/#the-cipher-output" rel="nofollow noreferrer">here</a>.</p></li>	</ul>		<p>Taking these points into account, encryption can be performed as follows:</p>		<pre><code>var CryptoJS = require("crypto-js");		// Key and random number as arrays, e.g.:	var random_numberBA = [0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f];	var keyBA = [0x01, 0x23, 0x45, 0x67, 0x89, 0x01, 0x22, 0x23, 0x34, 0x45, 0x56, 0x67, 0x78, 0x89, 0x90, 0x02];		// Conversion to WordArrays	var random_numberWA = CryptoJS.enc.Hex.parse(bytesToHex(random_numberBA));	var keyWA = CryptoJS.enc.Hex.parse(bytesToHex(keyBA));		// Encryption	// - random_number as WordArray	// - Key as WordArray	// - ECB-Mode (default: CBC), No-Padding (default: Pkcs7-Padding)	var encryptedCP = CryptoJS.AES.encrypt(random_numberWA, keyWA, { mode: CryptoJS.mode.ECB, padding: CryptoJS.pad.NoPadding });		// Encrypted data as WordArray	var encryptedWA = encryptedCP.ciphertext;		// Conversion to array	var encryptedBA = hexToBytes(CryptoJS.enc.Hex.stringify(encryptedWA));		// Consume encryptedBA 	// ...		// Helper: from https://stackoverflow.com/a/34356351/9014097	function hexToBytes(hex) {	    for (var bytes = [], c = 0; c &lt; hex.length; c += 2)	        bytes.push(parseInt(hex.substr(c, 2), 16));	    return bytes;	}		function bytesToHex(bytes) {	    for (var hex = [], i = 0; i &lt; bytes.length; i++) {	        var current = bytes[i] &lt; 0 ? bytes[i] + 256 : bytes[i];	        hex.push((current &gt;&gt;&gt; 4).toString(16));	        hex.push((current &amp; 0xF).toString(16));	    }	    return hex.join("");	}	</code></pre>		<p>The result can be verified e.g. <a href="http://aes.online-domain-tools.com/" rel="nofollow noreferrer">here</a>.</p>	"
