thread_ID, Id, ParentId, PostType, Score, CreationDate, OwnerID, Body
52761691,52761691,null,1,1,Thu Oct 11 13:45:00 EDT 2018,1862909,"<p>i'm trying to solve a simple task using <code>aws-iot-device-sdk-js</code> and node.js. I want to subscribe to all updates made to the shadow and so something with them. I could do it using the <code>device</code> class using the certificates, but this is not available for the purpose of this demo. </p>		<p>Here is my code:</p>		<pre><code>var AWS = require('aws-sdk');	var AWSIoTData = require('aws-iot-device-sdk');	var thingName = 'MyThing';	var shadowsRegistered = false;		var AWSConfiguration = {	   poolId: 'us-east-2:XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX', // 'YourCognitoIdentityPoolId'	   host: 'XXXXXXXXXXXXXX-ats.iot.us-east-2.amazonaws.com', // 'YourAWSIoTEndpoint', e.g. 'prefix.iot.us-east-1.amazonaws.com'	   region: 'us-east-2' // 'YourAwsRegion', e.g. 'us-east-1'	};		//	// Initialize our configuration.	//	AWS.config.region = AWSConfiguration.region;		AWS.config.credentials = new AWS.CognitoIdentityCredentials({	   IdentityPoolId: AWSConfiguration.poolId	});		var shadowsRegistered = false;		iniShadows = function(credentials){	    const shadows = AWSIoTData.thingShadow({	       region: AWS.config.region,  // Set the AWS region we will operate in.	       host:AWSConfiguration.host, //Set the AWS IoT Host Endpoint	       clientId: 'some random string', // Use a random client ID.	       protocol: 'wss', // Connect via secure WebSocket	       //	       // Set the maximum reconnect time to 8 seconds; this is a browser application	       // so we don't want to leave the user waiting too long for reconnection after	       // re-connecting to the network/re-opening their laptop/etc...	       //	       maximumReconnectTimeMs: 8000,	       debug: true, // Enable console debugging information (optional)	       //	       // IMPORTANT: the AWS access key ID, secret key, and sesion token must be	       // initialized with empty strings.	       //	       accessKeyId: credentials.AccessKeyId,	       secretKey: credentials.SecretKey,	       sessionToken: credentials.SessionToken	    });	    shadows.on('connect', function(){	      console.log('connect');	      //	      // We only register our shadows once.	      //	      if (!shadowsRegistered) {	        console.log('=== registering shadows ');	         shadows.register(thingName,{	           persistentSubscribe:true	         },function(){	           console.log('after registerging. ');	           shadowsRegistered = true;		         });		      }	    });	    shadows.on('reconnect', function(){	      console.log('reconnect');	    });		    shadows.on('status', function(thingName, statusType, clientToken, stateObject) {	      console.log(thingName);	      console.log('----&gt; got status ' + statusType);	      console.log(JSON.stringify(stateObject));	    });	    shadows.on('delta', function(thingName, stateObject) {	      console.log(thingName);	      console.log(JSON.stringify(stateObject));	    });	    shadows.on('timeout', function(thingName, clientToken) {	       console.log('received timeout on '+thingName);	    });    		}			var cognitoIdentity = new AWS.CognitoIdentity();	AWS.config.credentials.get(function(err, data) {	   if (!err) {	      console.log('retrieved identity: ' + AWS.config.credentials.identityId);	      var params = {	         IdentityId: AWS.config.credentials.identityId	      };	      cognitoIdentity.getCredentialsForIdentity(params, function(err, data) {	         if (!err) {	            //	            // Update our latest AWS credentials; the MQTT client will use these	            // during its next reconnect attempt.	            //	            //shadows.updateWebSocketCredentials(data.Credentials.AccessKeyId,	            //   data.Credentials.SecretKey,	            ///   data.Credentials.SessionToken);	            iniShadows(data.Credentials);	              console.log('updated credentials in shadows ');		         } else {	            console.log('error retrieving credentials: ' + err);	            alert('error retrieving credentials: ' + err);	         }	      });	   } else {	      console.log('error retrieving identity:' + err);	      alert('error retrieving identity: ' + err);	   }	});	</code></pre>		<p>The log on the console is just:	    ... (some cognito output)	    updated credentials in shadows	    connect	    === registering shadows	    after registerging.</p>		<p>so the cognito part is working, and I'm able to register the thing. </p>		<p>The <code>shadows.on('status',...</code> and <code>shadows.on('delta',</code> are never called. Even if there is data flowing, because I can register to the shadow/updates/accepted in the AWS IoT mqtt client. </p>		<p>I then tried to call <code>shadows.get(thingName)</code> from within the callback of the register function AND I got the callback for <code>status</code> working once. However, the callback does not work for every new message that gets accepted by the shadow. </p>		<pre><code>if (!shadowsRegistered) {	        console.log('=== registering shadows ');	         shadows.register(thingName,{	           persistentSubscribe:true	         },function(){	           console.log('after registerging. ');	           shadowsRegistered = true;		           opClientToken = shadows.get(thingName);	         });		      }	</code></pre>		<p>As you can see, I have no trouble authenticating or other stuff. It is probably just a misunderstanding of how the shadow class works. Any help highly appreciated. </p>	"
