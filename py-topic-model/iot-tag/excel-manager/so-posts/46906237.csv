thread_ID, Id, ParentId, PostType, Score, CreationDate, OwnerID, Body
46906237,46906237,null,1,2,Tue Oct 24 09:00:00 EDT 2017,8820453,"<p>I have a question on UWP app lifecycle and code structure. It relates to background-only services, and I couldn't really find the answer anywhere, although that may be because as a n00b in this area I don't know what question I'm trying to ask!</p>		<p>I was fiddling around with a project on my RPi (raspbian/C++), to read some sensors and do stuff based on the values, this is going to run 24/7. I'm slow at C++ though, so I thought I'd return to the relative safety of C#/.net using UWP/IoT. This app is going to be headless, as it will have a separate USB-based touch/display unit (from 4d).</p>		<p>So I want it to be background only, running as a daemon/service 24/7. Is this a model that is possible/recommended on UWP? I've seen a couple of blogs where they say otherwise.</p>		<p>Assuming it's OK, I need to read SPI, so that uses async methods, but then I guess I need to make my Run entry point async too? In which case surely to avoid mixing sync and async code the logical conclusion to this is that all code/EVERY method needs to be async? Is that right?</p>		<p>In this async/UWP case, what is the equivalent of a typical main loop:</p>		<pre><code>while(true)	{	    //do something	}	</code></pre>		<p>Confused how to transfer my limited knowledge into the async UWP world...</p>	"
46906237,46909025,46906237,2,4,Tue Oct 24 11:11:00 EDT 2017,4558911,"<p>What you're trying to do is possible only on  Windows IoT (raspberry).	You can create an headless application that will run forever.</p>		<p>You will find a good starter here : <a href="https://docs.microsoft.com/en-us/windows/iot-core/develop-your-app/BuildingAppsForIoTCore" rel="nofollow noreferrer">Building apps for IoT Core</a></p>		<p>There is also a simple sample available here : <a href="https://github.com/ms-iot/samples/tree/develop/HelloBlinkyBackground/CS" rel="nofollow noreferrer">Hello Blinky Background</a></p>		<p>You will need first to install the project template available from here:</p>		<ul>	<li><a href="https://marketplace.visualstudio.com/items?itemName=MicrosoftIoT.WindowsIoTCoreProjectTemplates" rel="nofollow noreferrer">Windows IoT Core Project Templates VS2015</a></li>	<li><a href="https://marketplace.visualstudio.com/items?itemName=MicrosoftIoT.WindowsIoTCoreProjectTemplatesforVS15" rel="nofollow noreferrer">Windows IoT Core Project Templates VS2017</a></li>	</ul>		<p>Once done, you will have to implement an UWP background task where you will retrieve <a href="https://docs.microsoft.com/en-us/uwp/api/Windows.ApplicationModel.Background.BackgroundTaskDeferral" rel="nofollow noreferrer">task deferral</a> and never complete it. By default, background task ends when their <code>Run()</code> method ends. If you retrieve the deferral, it will end only when you will complete the deferral.</p>		<pre><code>public sealed class MyLongRunningBackgroundTask : IBackgroundTask	{	    BackgroundTaskDeferral deferral;		    public async void Run(IBackgroundTaskInstance taskInstance)	    {	        // We retrieve the deferral to prevent the task to stop	        deferral = taskInstance.GetDeferral();		        // Run loop calling asynchronous methods 	        // It can also be a timer or an event callback registration	        while(true)	        {	             await doSomethingAsync()	        }	    }	}	</code></pre>		<p>If you want to end your task, you can then just call <code>deferral.Complete()</code> </p>		<p>It will also be good to register for the background task cancellation event in order to be notified by the OS when your task will be cancelled and gracefully close the resources you are using.</p>		<pre><code>public async void Run(IBackgroundTaskInstance taskInstance)	{	    taskInstance.Canceled += OnCanceled;	}		private void OnCanceled(IBackgroundTaskInstance sender, BackgroundTaskCancellationReason reason)	{	    // Cleanup	}	</code></pre>	"
