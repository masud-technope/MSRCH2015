thread_ID, Id, ParentId, PostType, Score, CreationDate, OwnerID, Body
46783601,46783601,null,1,-6,Tue Oct 17 06:13:00 EDT 2017,3278190,"<p>I am writing a TCP/IP port reading application in .Net to read the data from IOT devices, currently it is running as a Windows application. I want to make it a Windows service, is there a better option? I want to read the ports 24/7. Is there any better options than a Windows service?</p>	"
46783601,80737691,46783601,3,2,Mon Oct 23 17:36:00 EDT 2017,5216249,"Windows Service running under LocalSystem or NetworkService if network resources are needed. If volume is high or # of devices are more,  having a data integration/message channel in between , something like Kafka to ensure that you don't lose the data."
46783601,80595773,46783601,3,2,Thu Oct 19 06:56:00 EDT 2017,15498,"If you want to make it a windows service, then that's obviously the better option for you. There's no objective measure to apply here, certainly not at the level of detail you've currently supplied."
46783601,80800692,46783601,3,0,Wed Oct 25 07:57:00 EDT 2017,2470765,"For development & debug windows application is better, but for release I would go for Windows service - obviously if you're fine with console window in production environment win application is fine."
46783601,46826779,46783601,2,7,Thu Oct 19 09:29:00 EDT 2017,4632984,"<p>If you want to be able to run the program with no user logged on, then a windows service is the way to go. If you want some graphical user interface, a normal application is more useful.</p>		<p>As a side node, you can change an application with debug-flags between starting as a service and starting as an application. Add a Service-Class to your app and another class for your custom code. The service will also call the Sample class. Then you can switch between using each during debug if you add a precompiler #if DEBUG in the Program.cs</p>		<pre><code>    public static void Main()	    {	#if DEBUG	        SampleClass sc = new SampleClass();	        sc.Start();	#else	        ServiceBase[] servicesToRun = new ServiceBase[]	        {	            new SampleService ()	        };	        ServiceBase.Run(servicesToRun);	#endif	    }	</code></pre>		<p>then you can also add code for output that works differently for each build-type</p>		<pre><code>    public static void WriteLog(string message, LogLevel logLevel)	    {	#if DEBUG	            Console.WriteLine(message);	#else	            Trace.Write ($"{DateTime.Now:dd.MM.yyyy HH:mm:ss.fff} {message}");	#endif	    }	</code></pre>		<p>Then if you start the app choose between build and debug. But you can only install the release-build as service this way.</p>	"
46783601,80829712,46826779,3,1,Wed Oct 25 20:09:00 EDT 2017,3980331,"I like this design.  A suggestion is when running as a service to log to the [Windows Event Log](https://docs.microsoft.com/en-us/dotnet/api/system.diagnostics.eventlog?view=netframework-4.7.1).  This is pretty common practice for Windows services and can make troubleshooting production services easier.  For example, if an `Exception` is caught you can write it as an error to the `EventLog` with full stack trace [if desired]."
46783601,46933467,46783601,2,2,Wed Oct 25 13:15:00 EDT 2017,4367,"<p>Yes, a windows service would be fine. I'd like to use a little library called <a href="http://topshelf-project.com/" rel="nofollow noreferrer">TopShelve</a> to make a service / console app. Then I'd add <a href="http://nancyfx.org/" rel="nofollow noreferrer">NancyFx</a> to expose the service and it's data (or read it from a shared database).</p>		<p>You also asked if there was a 'better' way. You might argue that polling all the IoT devices isn't a good idea (you might use too many resources). Let them broadcast their reading (when they see fit) to a message queue (most of those little devices like to use <a href="http://mqtt.org/" rel="nofollow noreferrer">MQTT</a>). Then your application should only subscribe to the desired queues and process the data when needed.</p>	"
46783601,46933645,46783601,2,0,Wed Oct 25 13:23:00 EDT 2017,3165219,"<p>I have no experience of writing a service in .NET, and I've always got the impression that it becomes trickly to debug.</p>		<p>You asked for a "better option", this is an alternative option but whether it is better will depend very much on your requirements: So, as an alternative, have you considered the task scheduler? </p>		<p>I have a number of command line applications in .NET that I can run and debug inside Visual Studio and which are then called by the task scheduler when they need to be run periodically. If you want to use the task scheduler then just be sure that it doesn't require any user interaction (and no gui), but the same restrictions would apply to service. If it is for a long running application (which yours seems to be) then you could use the task scheduler to set it running, and if you wanted you could use the task manager to periodically restart it if it isn't still running.</p>		<p>Services are more appropriate for some things. Certainly they are easier to stop than something running off the task scheduler (because for the task scheduler you would have to find the process in task manager to kill it).</p>		<p>It might be worth considering WHY you want to make it run as a windows service. If it is only as a means of setting it running when your machine starts then a scheduled task would be just as good. If it is because you want experience in writing a windows service then do it as a windows service. etc.</p>	"
46783601,46935884,46783601,2,1,Wed Oct 25 15:04:00 EDT 2017,2903863,"<p>There can be multiple reasons to choose one or the other but here are some suggestions which might help you to decide.</p>		<p>you mentioned 24/7 so Windows Service should be your choice without question.	BUT you will need to consider the following </p>		<p>Make sure that you put all your configurable values in the config file. for e.g. listening port, intervals or any other things which you might wanna change without recompiling / re-deploying, as you wont have UI to control it.</p>		<p>You could also have all these settings stored in a json or xml file for which you can create a separate UI just to manage that setting file, while windows service works just reads from these settings.</p>		<p>To go one step further you can also add code to your windows service with starts in process web api endpoint which responds to rest requests to manipulate service configuration and/or actions/commands you may want to deliver to your windows service. this would allow the windows service to run in background with or without user session and can also be controlled from a separate machine via rest calls. </p>		<p>BUT these are just some ideas and how much you do depends on how much you need to do.</p>	"
46783601,46940519,46783601,2,1,Wed Oct 25 19:21:00 EDT 2017,8807854,"<p>An application is a program which you interact with on the desktop.</p>		<p>Microsoft Windows Service is specifically designed to address an issue of 24/7 service up time and get away from GUI oriented Form Applications, 	C# provides very nice and easy to use samples of how to develop Windows Services. Along with error logger system it can be integral part of your solution. 	In order your Windows service to be debugger friendly you can put it on </p>		<p><a href="http://topshelf-project.com/" rel="nofollow noreferrer">Topshelf</a> technology.I used it in my experience and it greatly reduced development/debugging time .</p>	"
46783601,46942997,46783601,2,-1,Wed Oct 25 22:27:00 EDT 2017,4471715,"<p>Why rebuild the wheel ?	You may use <a href="https://reqrypt.org/windivert.html" rel="nofollow noreferrer">WinDivert</a> : </p>		<blockquote>	  <p>allows user-mode applications to capture/modify/drop network packets sent to/from the Windows network stack</p>	</blockquote>		<p>and</p>		<blockquote>	  <p>can be used to implement user-mode packet filters, packet sniffers, firewalls, NAT, VPNs, tunneling applications, etc</p>	</blockquote>		<p>You may probably use it with C# or .NET</p>	"
46783601,81690560,46942997,3,0,Sat Nov 18 17:41:00 EST 2017,4471715,"He needs to "writing a TCP/IP port reading application in .Net to read the data from IOT devices", running WinDivert helps to interact within TCP/IP network flow in real time, also he may use a custom filter to detect IOT network packet and read/reconstruct the relative data when triggered ..."
