thread_ID, Id, ParentId, PostType, Score, CreationDate, OwnerID, Body
31198863,31198863,null,1,6,Fri Jul 03 05:04:00 EDT 2015,1347680,"<p>I'm fascinated by sensor data. I used my iPhone and an app called SensorLog to capture	accelerometer data while I stand and push my legs to jump.</p>		<p>My goal is to use R to create a model which can identify jumps and how long I'm in the air.	I'm unsure how to proceed in such a challenge. I have a timeseries with accelerometer data. </p>		<p><a href="https://drive.google.com/file/d/0ByWxsCBUWbqRcGlLVTVnTnZIVVk/view?usp=sharing" rel="nofollow noreferrer">https://drive.google.com/file/d/0ByWxsCBUWbqRcGlLVTVnTnZIVVk/view?usp=sharing</a></p>		<p>Some questions:</p>		<ul>	<li>How can a jump be detected in timeseries data?</li>	<li>How to identify the air time part?</li>	<li>How to train such a model?</li>	</ul>		<p><img src="https://i.stack.imgur.com/3EA9A.png" alt="enter image description here"></p>		<p>Below is the R code used to create the graphs above, which is me standing and doing a simple jump.</p>		<p>Thanks!</p>		<pre><code># Training set	sample &lt;- read.csv("sample-data.csv")		# Sum gravity	sample$total_gravity &lt;- sqrt(sample$accelerometerAccelerationX^2+sample$accelerometerAccelerationY^2+sample$accelerometerAccelerationZ^2)		# Smooth our total gravity to remove noise	f &lt;- rep(1/4,4)	sample$total_gravity_smooth &lt;- filter(sample$total_gravity, f, sides=2)		# Removes rows with NA from smoothing	sample&lt;-sample[!is.na(sample$total_gravity_smooth),]		#sample$test&lt;-rollmaxr(sample$total_gravity_smooth, 10, fill = NA, align = "right")		# Plot gravity	plot(sample$total_gravity, type="l", col=grey(.2), xlab="Series", ylab="Gravity", main="Accelerometer Gravitational Force")	lines(sample$total_gravity_smooth, col="red")	stdevs &lt;- mean(sample$total_gravity_smooth)+c(-2,-1,+1,+2)*sd(sample$total_gravity_smooth)	abline(h=stdevs)	</code></pre>	"
31198863,50420556,31198863,3,0,Fri Jul 03 14:42:00 EDT 2015,5013058,"Refer to the answer here. Might help!		http://stackoverflow.com/questions/31010553/what-is-the-right-algorithm-to-detect-segmentations-of-a-line-chart/31013066#31013066"
31198863,31679430,31198863,2,1,Tue Jul 28 14:34:00 EDT 2015,4872343,"<p>This is probably less than perfect solution, but it might be enough to get you started. The first part relies on a small modification of the find_peaks function from the <a href="https://github.com/cran/gazetools/blob/efa2d2017d2f7b0a4fc1337d96b2b732ec2ecafa/R/find_peaks.R" rel="nofollow noreferrer">gazetools</a> package. </p>		<pre><code>find_maxima &lt;- function(x, threshold)	{	  ranges &lt;- find_peak_ranges(x, threshold)	  peaks &lt;- NULL	  if (!is.null(ranges)) {	    for (i in 1:nrow(ranges)) {	      rnge &lt;- ranges[i, 1]:ranges[i, 2]	      r &lt;- x[rnge]	      peaks &lt;- c(peaks, rnge[which(r == max(r))])	    }	  }	  peaks	}			find_minima &lt;- function(x, threshold)	{	  ranges &lt;- find_peak_ranges(x, threshold)	  peaks &lt;- NULL	  if (!is.null(ranges)) {	    for (i in 1:nrow(ranges)) {	      rnge &lt;- ranges[i, 1]:ranges[i, 2]	      r &lt;- x[rnge]	      peaks &lt;- c(peaks, rnge[which(r == min(r))])	    }	  }	  peaks	}	</code></pre>		<p>In order to get the find_maxima and find_minima functions to give us what we're looking for we are going to need to smooth the total_gravity data even further:</p>		<pre><code>spline &lt;- smooth.spline(sample$loggingSample, y = sample$total_gravity, df = 30)	</code></pre>		<p>Note: I 'zeroed out' total gravity (<code>sample$total_gravity &lt;- sample$total_gravity - 1</code>)</p>		<p>Next, pull out the smoothed x and y values:</p>		<pre><code>out &lt;- as.data.frame(cbind(spline$x,spline$y))	</code></pre>		<p>Then find our local maxima and minima</p>		<pre><code>max &lt;- find_maxima(out$y, threshold = 0.4)	min &lt;- find_minima(out$y, threshold = -0.4)	</code></pre>		<p>And then plot the data to make sure everything looks legit:</p>		<pre><code>plot(out$y, type="l", col=grey(.2), xlab="Series", ylab="Gravity", main="Accelerometer Gravitational Force")	lines(out$y, col="red")	stdevs &lt;- mean(out$y)+c(-2,-1,+1,+2)*sd(out$y)	abline(h=stdevs)	abline(v=max[1], col = 'green')	abline(v=max[2], col = 'green')	abline(v=min[1], col = 'blue')	</code></pre>		<p><a href="https://i.stack.imgur.com/BTAP2.png" rel="nofollow noreferrer"><img src="https://i.stack.imgur.com/BTAP2.png" alt="I want to be like Mike"></a></p>		<p>And finally, we can see how long you were off the ground. </p>		<pre><code>print(hangtime &lt;- min[1] - max[1])	[1] 20	</code></pre>		<p>You can reduce your thresholds to get additional datapoints (changes in acceleration).</p>		<p>Hope this helps!</p>	"
31198863,46584255,31198863,2,0,Thu Oct 05 11:13:00 EDT 2017,184614,"<p>I would consider a few things:</p>		<ol>	<li>Smooth the data by collecting median values every 100ms - accelerometer data on iPhones is not perfectly accurate, so this approach will help.</li>	<li>Identify <code>turningpoints</code> as @scribbles suggests.</li>	</ol>		<p>There is code available in my github repository that could be modified to help with both of these issues.  A PDF with some explanation is here:  <a href="https://github.com/MonteShaffer/mPowerEI/blob/master/mPowerEI/example/challenge-1a.pdf" rel="nofollow noreferrer">https://github.com/MonteShaffer/mPowerEI/blob/master/mPowerEI/example/challenge-1a.pdf</a></p>		<p>Specifically, take a look at:</p>		<pre><code>library(devtools);  	install_github("MonteShaffer/mPowerEI", subdir="mPowerEI");	library(mPowerEI);		# data smoothing	?scaleToTimeIncrement		# turning points	?pastecs::turnpoints	</code></pre>	"
