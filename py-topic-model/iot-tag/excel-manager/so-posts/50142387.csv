thread_ID, Id, ParentId, PostType, Score, CreationDate, OwnerID, Body
50142387,50142387,null,1,0,Wed May 02 19:43:00 EDT 2018,8430413,"<p>I'm doing Android Things project.</p>		<p>I want to publish a String message to Google Cloud IoT Core, but there are errors shown.</p>		<p>I'm using Raspberry Pi 3 with Android Things OS and and programming it using Android Studio.</p>		<p>Errors screenshot:</p>		<p><a href="https://i.stack.imgur.com/Yw3pU.png" rel="nofollow noreferrer"><img src="https://i.stack.imgur.com/Yw3pU.png" alt="enter image description here"></a></p>		<p>This is the whole code:</p>		<p>AndroidManifest.xml:</p>		<pre><code>&lt;?xml version="1.0" encoding="utf-8"?&gt;	&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android"	          package="cacaosd.com.sample1"&gt;		    &lt;!-- PAHO Permissions --&gt;	    &lt;uses-permission android:name="android.permission.WAKE_LOCK" /&gt;	    &lt;uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" /&gt;	    &lt;uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE" /&gt;	    &lt;uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" /&gt;	    &lt;uses-permission android:name="android.permission.INTERNET" /&gt;	    &lt;!-- PAHO Permissions --&gt;		    &lt;application&gt;	        &lt;uses-library android:name="com.google.android.things"/&gt;		        &lt;!-- Mqtt Service --&gt;	        &lt;service android:name="org.eclipse.paho.android.service.MqttService" /&gt;		        &lt;activity android:name=".MainActivity"&gt;	            &lt;intent-filter&gt;	                &lt;action android:name="android.intent.action.MAIN"/&gt;		                &lt;category android:name="android.intent.category.LAUNCHER"/&gt;	            &lt;/intent-filter&gt;	            &lt;intent-filter&gt;	                &lt;action android:name="android.intent.action.MAIN"/&gt;		                &lt;category android:name="android.intent.category.IOT_LAUNCHER"/&gt;	                &lt;category android:name="android.intent.category.DEFAULT"/&gt;	            &lt;/intent-filter&gt;	        &lt;/activity&gt;	    &lt;/application&gt;		&lt;/manifest&gt;	</code></pre>		<p>IotCoreCommunicator Class</p>		<pre><code>  package cacaosd.com.sample1;		import android.content.Context;	import android.util.Log;		import java.util.concurrent.TimeUnit;		import org.eclipse.paho.android.service.MqttAndroidClient;	import org.eclipse.paho.client.mqttv3.IMqttActionListener;	import org.eclipse.paho.client.mqttv3.IMqttDeliveryToken;	import org.eclipse.paho.client.mqttv3.IMqttToken;	import org.eclipse.paho.client.mqttv3.MqttCallback;	import org.eclipse.paho.client.mqttv3.MqttConnectOptions;	import org.eclipse.paho.client.mqttv3.MqttException;	import org.eclipse.paho.client.mqttv3.MqttMessage;		public class IotCoreCommunicator {		    private static final String SERVER_URI = "ssl://mqtt.googleapis.com:8883";		    public static class Builder {		        private Context context;	        private String projectId;	        private String cloudRegion;	        private String registryId;	        private String deviceId;	        private int privateKeyRawFileId;		        public Builder withContext(Context context) {	            this.context = context;	            return this;	        }		        public Builder withProjectId(String projectId) {	            this.projectId = projectId;	            return this;	        }		        public Builder withCloudRegion(String cloudRegion) {	            this.cloudRegion = cloudRegion;	            return this;	        }		        public Builder withRegistryId(String registryId) {	            this.registryId = registryId;	            return this;	        }		        public Builder withDeviceId(String deviceId) {	            this.deviceId = deviceId;	            return this;	        }		        public Builder withPrivateKeyRawFileId(int privateKeyRawFileId) {	            this.privateKeyRawFileId = privateKeyRawFileId;	            return this;	        }		        public IotCoreCommunicator build() {	            if (context == null) {	                throw new IllegalStateException("context must not be null");	            }		            if (projectId == null) {	                throw new IllegalStateException("projectId must not be null");	            }	            if (cloudRegion == null) {	                throw new IllegalStateException("cloudRegion must not be null");	            }	            if (registryId == null) {	                throw new IllegalStateException("registryId must not be null");	            }	            if (deviceId == null) {	                throw new IllegalStateException("deviceId must not be null");	            }	            String clientId = "projects/" + projectId + "/locations/" + cloudRegion + "/registries/" + registryId + "/devices/" + deviceId;		            if (privateKeyRawFileId == 0) {	                throw new IllegalStateException("privateKeyRawFileId must not be 0");	            }	            MqttAndroidClient client = new MqttAndroidClient(context, SERVER_URI, clientId);	            IotCorePasswordGenerator passwordGenerator = new IotCorePasswordGenerator(projectId, context.getResources(), privateKeyRawFileId);	            return new IotCoreCommunicator(client, deviceId, passwordGenerator);	        }		    }		    private final MqttAndroidClient client;	    private final String deviceId;	    private final IotCorePasswordGenerator passwordGenerator;		    IotCoreCommunicator(MqttAndroidClient client, String deviceId, IotCorePasswordGenerator passwordGenerator) {	        this.client = client;	        this.deviceId = deviceId;	        this.passwordGenerator = passwordGenerator;	    }		    public void connect() {	        monitorConnection();	        clientConnect();	        subscribeToConfigChanges();	    }		    private void monitorConnection() {	        client.setCallback(new MqttCallback() {	            @Override	            public void connectionLost(Throwable cause) {	                Log.e("TUT", "connection lost", cause);	            }		            @Override	            public void messageArrived(String topic, MqttMessage message) throws Exception {	                Log.d("TUT", "message arrived " + topic + " MSG " + message);	                // You need to do something with messages when they arrive	            }		            @Override	            public void deliveryComplete(IMqttDeliveryToken token) {	                Log.d("TUT", "delivery complete " + token);	            }	        });	    }		    private void clientConnect() {	        try {	            MqttConnectOptions connectOptions = new MqttConnectOptions();	            // Note that the the Google Cloud IoT Core only supports MQTT 3.1.1, and Paho requires that we explicitly set this.	            // If you don't, the server will immediately close its connection to your device.	            connectOptions.setMqttVersion(MqttConnectOptions.MQTT_VERSION_3_1_1);		            // With Google Cloud IoT Core, the username field is ignored, however it must be set for the	            // Paho client library to send the password field. The password field is used to transmit a JWT to authorize the device.	            connectOptions.setUserName("unused-but-necessary");	            connectOptions.setPassword(passwordGenerator.createJwtRsaPassword());		            IMqttToken iMqttToken = client.connect(connectOptions);	            iMqttToken.setActionCallback(new IMqttActionListener() {	                @Override	                public void onSuccess(IMqttToken asyncActionToken) {	                    Log.d("TUT", "success, connected");	                }		                @Override	                public void onFailure(IMqttToken asyncActionToken, Throwable exception) {	                    Log.e("TUT", "failure, not connected", exception);	                }	            });	            iMqttToken.waitForCompletion(TimeUnit.SECONDS.toMillis(30));	            Log.d("TUT", "IoT Core connection established.");	        } catch (MqttException e) {	            throw new IllegalStateException(e);	        }	    }		    /**	     * Configuration is managed and sent from the IoT Core Platform	     */	    private void subscribeToConfigChanges() {	        try {	            client.subscribe("/devices/" + deviceId + "/config", 1);	        } catch (MqttException e) {	            throw new IllegalStateException(e);	        }	    }		    public void publishMessage(String subtopic, String message) {	        String topic = "/devices/" + deviceId + "/" + subtopic;	        String payload = "{msg:\"" + message + "\"}";	        MqttMessage mqttMessage = new MqttMessage(payload.getBytes());	        mqttMessage.setQos(1);	        try {	            client.publish(topic, mqttMessage);	            Log.d("TUT", "IoT Core message published. To topic: " + topic);	        } catch (MqttException e) {	            throw new IllegalStateException(e);	        }	    }		    public void disconnect() {	        try {	            Log.d("TUT", "IoT Core connection disconnected.");	            client.disconnect();	        } catch (MqttException e) {	            throw new IllegalStateException(e);	        }	    }		}	</code></pre>		<p>IotCorePasswordGenerator Class</p>		<pre><code>    package cacaosd.com.sample1;		import android.content.res.Resources;	import android.util.Base64;		import java.io.IOException;	import java.io.InputStream;	import java.security.KeyFactory;	import java.security.NoSuchAlgorithmException;	import java.security.spec.InvalidKeySpecException;	import java.security.spec.PKCS8EncodedKeySpec;	import java.time.Duration;	import java.time.Instant;	import java.util.Date;		import io.jsonwebtoken.JwtBuilder;	import io.jsonwebtoken.Jwts;	import io.jsonwebtoken.SignatureAlgorithm;		class IotCorePasswordGenerator {		    private final String projectId;	    private final Resources resources;	    private final int privateKeyRawFileId;		    IotCorePasswordGenerator(String projectId, Resources resources, int privateKeyRawFileId) {	        this.projectId = projectId;	        this.resources = resources;	        this.privateKeyRawFileId = privateKeyRawFileId;	    }		    char[] createJwtRsaPassword() {	        try {	            byte[] privateKeyBytes = decodePrivateKey(resources, privateKeyRawFileId);	            return createJwtRsaPassword(projectId, privateKeyBytes).toCharArray();	        } catch (NoSuchAlgorithmException e) {	            throw new IllegalStateException("Algorithm not supported. (developer error)", e);	        } catch (InvalidKeySpecException e) {	            throw new IllegalStateException("Invalid Key spec. (developer error)", e);	        } catch (IOException e) {	            throw new IllegalStateException("Cannot read private key file.", e);	        }	    }		    private static byte[] decodePrivateKey(Resources resources, int privateKeyRawFileId) throws IOException {	        try(InputStream inStream = resources.openRawResource(privateKeyRawFileId)) {	            return Base64.decode(inputToString(inStream), Base64.DEFAULT);	        }	    }		    private static String inputToString(InputStream is) {	        java.util.Scanner s = new java.util.Scanner(is).useDelimiter("\\A");	        return s.hasNext() ? s.next() : "";	    }		    private static String createJwtRsaPassword(String projectId, byte[] privateKeyBytes) throws NoSuchAlgorithmException, InvalidKeySpecException {	        return createPassword(projectId, privateKeyBytes, "RSA", SignatureAlgorithm.RS256);	    }		    private static String createPassword(String projectId, byte[] privateKeyBytes, String algorithmName, SignatureAlgorithm signatureAlgorithm) throws NoSuchAlgorithmException, InvalidKeySpecException {	        Instant now = Instant.now();	        // Create a JWT to authenticate this device. The device will be disconnected after the token	        // expires, and will have to reconnect with a new token. The audience field should always be set	        // to the GCP project id.	        JwtBuilder jwtBuilder =	                Jwts.builder()	                        .setIssuedAt(Date.from(now))	                        .setExpiration(Date.from(now.plus(Duration.ofMinutes(20))))	                        .setAudience(projectId);		        PKCS8EncodedKeySpec spec = new PKCS8EncodedKeySpec(privateKeyBytes);	        KeyFactory kf = KeyFactory.getInstance(algorithmName);		        return jwtBuilder.signWith(signatureAlgorithm, kf.generatePrivate(spec)).compact();	    }		}	</code></pre>		<p>MainActivity Class:</p>		<pre><code>    package cacaosd.com.sample1;		import android.app.Activity;	import android.hardware.SensorEvent;	import android.os.Bundle;	import android.os.HandlerThread;	import android.os.Handler;		import android.app.Activity;	import android.os.Bundle;	import android.os.Handler;	import android.os.HandlerThread;	import android.util.Log;				import cacaosd.com.sample1.R;	import cacaosd.com.sample1.IotCoreCommunicator;			import com.google.android.things.pio.Gpio;			import java.io.IOException;	import java.util.concurrent.TimeUnit;			public class MainActivity extends Activity {				    private IotCoreCommunicator communicator;	    private Handler handler;		    @Override	    protected void onCreate(Bundle savedInstanceState) {	        super.onCreate(savedInstanceState);		        // Setup the communication with your Google IoT Core details	        communicator = new IotCoreCommunicator.Builder()	                .withContext(this)	                .withCloudRegion("us-central1") // ex: europe-west1	                .withProjectId("my-first-project-198704")   // ex: supercoolproject23236	                .withRegistryId("vibration") // ex: my-devices	                .withDeviceId("my-device") // ex: my-test-raspberry-pi	                .withPrivateKeyRawFileId(R.raw.rsa_private)	                .build();		        HandlerThread thread = new HandlerThread("MyBackgroundThread");	        thread.start();	        handler = new Handler(thread.getLooper());	        handler.post(connectOffTheMainThread); // Use whatever threading mechanism you want	    }		    private final Runnable connectOffTheMainThread = new Runnable() {	        @Override	        public void run() {	            communicator.connect();		            handler.post(sendMqttMessage);	        }	    };				    private final Runnable sendMqttMessage = new Runnable() {	        private int i;		        /**	         * We post 100 messages as an example, 1 a second	         */	        @Override	        public void run() {	            if (i == 100) {	                return;	            }				            // events is the default topic for MQTT communication	            String subtopic = "events";	            // Your message you want to send	            String message = "Hello World " + i++;		            communicator.publishMessage(subtopic, message);				            handler.postDelayed(this, TimeUnit.SECONDS.toMillis(1));	        }	    };		    @Override	    protected void onDestroy() {	        communicator.disconnect();	        super.onDestroy();	    }	}	</code></pre>		<p><strong>Update:</strong></p>		<p>I converted the private key from "pem" format to "pkcs8" format by following this <a href="https://cloud.google.com/iot/docs/how-tos/credentials/keys?hl=en_US&amp;_ga=2.47098981.-332655218.1514485003&amp;_gac=1.87039466.1526092766.Cj0KCQjwy9LVBRDOARIsAGqoVns1YvqYIhDhv7toVcJvojRltB-XvaBO5RiqVMkXaVvzhTLoB2hJ1vcaAphDEALw_wcB#converting_keys_to_pkcs8_for_java" rel="nofollow noreferrer">documentation</a> and this <a href="https://www.youtube.com/watch?v=PSZU-3afKPk" rel="nofollow noreferrer">demo</a>, then the error "Invalid key spec" is gone, but still there is a "FATAL EXCEPTION" and "java.lang.IllegalArgumentException: bad base-64" as shown in the image below:</p>		<p>[![enter image description here][4]][4]</p>		<p>It says that these are the related codes that caused the error (which shown in blue color in the previous image:</p>		<p>IotCorePasswordGenerator.java:47</p>		<pre><code>return Base64.decode(inputToString(inStream), Base64.DEFAULT);	</code></pre>		<p>IotCorePasswordGenerator.java:34</p>		<pre><code> byte[] privateKeyBytes = decodePrivateKey(resources, privateKeyRawFileId);	</code></pre>		<p>IotCoreCommunicator.java:135</p>		<pre><code>connectOptions.setPassword(passwordGenerator.createJwtRsaPassword());	</code></pre>		<p>IotCoreCommunicator.java:101</p>		<pre><code>clientConnect();	</code></pre>		<p>MainActivity.java:58</p>		<pre><code>communicator.connect();	</code></pre>		<p>Update 2</p>		<p>I deleted the statement "-----BEGIN PRIVATE KEY-----" and the statement "------END PRIVATE KEY-----" and the error "bad base 64" is gone, Now there is another error which is "broken pipe" as shown in image below, when I reopen Android Studio and rebuild the project this error "broken pipe" removed, and when I run the project again it comes back again.</p>		<p>The error (first image)</p>		<p>Private key with start and end statements(second image)</p>		<p>Private key without start and end statements(third image)</p>		<p><img src="https://i.stack.imgur.com/QA716.png" alt="enter image description here"><img src="https://i.stack.imgur.com/ktwJK.png" alt="enter image description here"><img src="https://i.stack.imgur.com/jt932.png" alt="enter image description here"></p>	"
50142387,87304607,50142387,3,0,Wed May 02 20:40:00 EDT 2018,3534690,"Have you confirmed that the event messages are getting published?"
50142387,87403750,50142387,3,0,Sat May 05 19:37:00 EDT 2018,8430413,"Thank you for your reply Mr. GabeWeiss, I found many errors shown that I didn't see before I post the question, sorry for that, now I edit my question so you can see the errors."
50142387,51850361,50142387,2,0,Tue Aug 14 22:03:00 EDT 2018,1552344,"<p>I strongly recommend that you take a look at the <a href="https://github.com/androidthings/cloud-iot-core-androidthings" rel="nofollow noreferrer">Android Things connector for Cloud IoT core</a>. This project makes it much easier to access Cloud IoT core from Android Things and handles various best practices such as token refresh.</p>	"
50142387,50208837,50142387,2,1,Mon May 07 07:11:00 EDT 2018,3534690,"<p>From the error, it looks like you registered the device with the wrong type of SSL key. Verify that you created an SSL key that matches the format you specified in IoT Core. I.e. if you created an RSA key with the x509 certificate wrapper, be sure that your device is registered with that type and not just the RSA key.</p>		<p>Also be sure that the private key is actually on the device, and that it's not corrupted.</p>		<p>Edit: Problem may have been the roots.pem wasn't on device to handle the TLS handshake with IoT Core. We shall see... to get it, run: <code>wget https://pki.google.com/roots.pem</code> and put the roots.pem in the same directory as the private key on device.</p>	"
50142387,87456562,50208837,3,0,Mon May 07 17:47:00 EDT 2018,8430413,"There are two keys, one is public key and I entered it inside IoT Core to authenticate the device and its format is : RS256_X509 . The other key is private key which I provided in the code. The public key start with: -----BEGIN CERTIFICATE-----  , and the private key start with:    -----BEGIN PRIVATE KEY-----                                                       Finally, how can I know that the private key is actually on the device, and that it's not corrupted."
50142387,87617037,50208837,3,0,Fri May 11 20:53:00 EDT 2018,3534690,"Right, I just wanted to be sure that you had verified that when you registered the device in IoT Core, that you checked the radio button for RSA256_x509. I know I've made the mistake more than once that I'll register the device with the "default" which is RSA256 without the x509 cert wrapper.	Also make sure that you have the roots.pem from Google is on device as well."
50142387,87621976,50208837,3,0,Sat May 12 04:19:00 EDT 2018,8430413,"What do you mean by radio button?, where I can found it because I didn't see it. Also, by saying roots.pem do you mean the private key (rsa_private.pem) or what?  finally, I converted the private key format from "pem" to "pkcs8", see the update on my question please.  Thank you"
50142387,87641967,50208837,3,0,Sun May 13 05:09:00 EDT 2018,3534690,"When you go to add a new device in the console (if you're using the console), there's a radio button to specify the Public key format. However, I would guess that the problem is indeed the roots.pem since it sounds unfamiliar to you! :D run this: `wget https://pki.google.com/roots.pem` And be sure that the roots.pem is in the same directory as your private key on the device. See if that works."
