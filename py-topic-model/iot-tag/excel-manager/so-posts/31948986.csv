thread_ID, Id, ParentId, PostType, Score, CreationDate, OwnerID, Body
31948986,31948986,null,1,2,Tue Aug 11 18:09:00 EDT 2015,5216274,"<p>I am attempting to assemble a small proof of concept system on IBM's Bluemix/Internet of Things. Currently this comprises of a Raspberry Pi feeding events up to the cloudbased app, which currently stores those events away, and periodically attempts to send down a command, using the following code block:</p>		<pre><code>def sendCmd(command, payload, device="raspberrypi" ):	    deviceId = #Fixed value	    global cmdCount	    client.publishCommand("raspberrypi", deviceId, str(command), "json", payload)	    print "Sending '%s' cmd, payload '%s' to device %s" % (command, payload, deviceId)	    cmdCount = cmdCount + 1	</code></pre>		<p>As far as the documentation is concerned this appears to be the correct syntax, as described by the <a href="https://docs.internetofthings.ibmcloud.com/libraries/python_cli_for_apps.html#/publishing-commands-to-devices" rel="nofollow">documentation</a> :</p>		<pre><code>   client.connect()	   commandData={'rebootDelay' : 50}	   client.publishCommand(myDeviceType, myDeviceId, "reboot", "json", myData)	</code></pre>		<p>No exceptions are thrown in this block of code, however the device is not receiving any commands; and the cloud foundry log is not throwing any errors. Is there a subtle point about the syntax I am missing?</p>	"
31948986,51879767,31948986,3,0,Thu Aug 13 12:01:00 EDT 2015,5110123,"Hello Steve, are you able to understand if the command 'reboot' is managed by the device through PI client callback? Are you logging something in case of unhanded command?		For example by using such a code		`client.on("command", function (commandName,format,payload,topic) {	    if(commandName === "blink") {	        console.log(blink);	        //function to be performed for this command	        blink(payload);	    } else {	        console.log("Command not supported.. " + commandName);	    }	});`"
31948986,51884666,31948986,3,0,Thu Aug 13 13:50:00 EDT 2015,5216274,"Un-handled Commands were being logged by the device.		I have since managed to get messages through - I believe that I had set the device up as an application instance. Once this was changed and the relevant function calls had been mapped to the device equivalents, then it worked."
31948986,52254890,31948986,3,0,Mon Aug 24 14:24:00 EDT 2015,5110123,"could you answer to your question explaining how you solved? many thanks"
31948986,32187757,31948986,2,1,Mon Aug 24 17:00:00 EDT 2015,5216274,"<p>This issue boiled down to having instantiated the wrong class on the Raspberry Pi. I had an instance of <strong>ibmiotf.application</strong> which registered a function to the variable self.client.commandCallback. However nothing appeared to be triggering the callback.</p>		<p>Once I instantiated the device with the <strong>ibmiotf.device</strong> import rather than <strong>ibmiotf.application</strong>, the command callback started to be called. This required a couple of the minor changes, to support slightly different function calls, but they were fairly self explanatory when trying to run the code.</p>		<p>The Device Class controls Events being published from the unit, and determines how to handle commands from upstream. Whereas the Application Class handles the receipt of Events and emission of Commands.</p>	"
