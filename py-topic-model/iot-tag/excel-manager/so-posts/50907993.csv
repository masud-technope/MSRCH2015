thread_ID, Id, ParentId, PostType, Score, CreationDate, OwnerID, Body
50907993,50907993,null,1,0,Mon Jun 18 11:01:00 EDT 2018,6795124,"<p>I'm trying to create a UWP service app on the Raspberry Pi3 which provides the access to the on board UART. I'm facing an issue about the AppConnection Request/response.</p>		<p>this is the service method that handles the incoming requests from client apps</p>		<pre><code>internal class Inbound	{	    public static async void OnRequestReceived(AppServiceConnection sender, AppServiceRequestReceivedEventArgs args)	    {	        var messageDeferral = args.GetDeferral();	        var response = new ValueSet();		        bool success = false;	        var msg = args.Request.Message.Keys;	        if (args.Request.Message.TryGetValue(ServiceApiRequests.Keys.Command, out object command))	        {	            try	            {	                switch (command)	                {		                    case ServiceApiRequests.CommandValues.UartWrite:	                        if (args.Request.Message.TryGetValue(ServiceApiRequests.Keys.UartTxBuffer, out object txBuffer))	                        {	                            string rxBuff = "";	                            success = await Pi3.Peripherals.Uart.GerInstance(57600).Write((string)txBuffer);		                            if (success)	                            {	                                Debug.WriteLine("Tx: " + (string)txBuffer);	                                if (args.Request.Message.TryGetValue(ServiceApiRequests.Keys.ReadUartResponse, out object getResponse))	                                {	                                    if ((string)getResponse == ServiceApiRequests.ReadUartResponse.Yes)	                                    {	                                        rxBuff = await Pi3.Peripherals.Uart.GerInstance(57600).Read();	                                        Debug.WriteLine("Rx: " + rxBuff);	                                    }	                                }	                            }	                            response.Add(ServiceApiRequests.Keys.UartRxBuffer, rxBuff);		                        }	                        break;	                }	            }	            catch (Exception ex)	            {	                success = false;	            }	        }		        response.Add(new KeyValuePair&lt;string, object&gt;(ServiceApiRequests.Keys.Result, success ? ServiceApiRequests.ResultValues.Ok : ServiceApiRequests.ResultValues.Ko));	        var result = await args.Request.SendResponseAsync(response);	        if (result == AppServiceResponseStatus.Failure)	        {	            Debug.WriteLine("Failed to send the response");	        }	        messageDeferral.Complete();	    }	}	</code></pre>		<p>As you can figure out, the Uart class is get using the Singleton pattern using the method <code>Pi3.Peripherals.Uart.GerInstance(57600)</code>.</p>		<p>Following the code i using for send the request from the client app.</p>		<pre><code>    public static class Uart	{	    public static IAsyncOperation&lt;string&gt; SendCommand(this AppServiceConnection DriverControllerConnection, string txBuffer, string awaitResponse = ServiceApiRequests.ReadUartResponse.Yes)	    {	        return _SendCommand(DriverControllerConnection, txBuffer, awaitResponse).AsAsyncOperation();	    }	    private static async Task&lt;string&gt; _SendCommand(AppServiceConnection DriverControllerConnection, string txBuffer, string awaitResponse)	    {	        AppServiceResponse response = null;	        string response_str = "";	        try	        {	            if (DriverControllerConnection != null)	            {	                response = await DriverControllerConnection.SendMessageAsync(new ServiceApiRequests.UartWrite().GetCommand(txBuffer, awaitResponse));	                if (response.Status == AppServiceResponseStatus.Success)	                {	                    if (response.Message.TryGetValue(ServiceApiRequests.Keys.Result, out object result))	                    {	                        if ((string)result == ServiceApiRequests.ResultValues.Ok &amp;&amp; awaitResponse == ServiceApiRequests.ReadUartResponse.Yes)	                        {	                            response_str = response.Message[ServiceApiRequests.Keys.UartRxBuffer] as string;	                        }	                    }	                }	            }	        }	        catch (Exception ex)	        {	            // TODO: log	        }	        return response_str;	    }	}	</code></pre>		<p>The system works well just for a while, until i have <code>response.Status == AppServiceResponseStatus.Success</code> , then the result of the request changes and it becomes <code>AppServiceResponseStatus.Failure</code>. This way the program counter never steps into the condition <code>if (response.Status == AppServiceResponseStatus.Success)</code>.</p>		<p>Any idea about the cause?	Thank you so much for the help.</p>		<p><strong>EDIT</strong></p>		<p>Follow the suggestions, i added an handler for the <code>ServiceClosed</code> event. This is the main class.</p>		<pre><code>public sealed class DriverListener : IBackgroundTask	{	    private BackgroundTaskDeferral backgroundTaskDeferral;	    private AppServiceConnection appServiceConnection;	    public void Run(IBackgroundTaskInstance taskInstance)	    {	        backgroundTaskDeferral = taskInstance.GetDeferral();	        // taskInstance.Canceled += OnTaskCanceled;		        var triggerDetails = taskInstance.TriggerDetails as AppServiceTriggerDetails;	        appServiceConnection = triggerDetails.AppServiceConnection;	        appServiceConnection.RequestReceived += Inbound.OnRequestReceived;	        appServiceConnection.ServiceClosed += OnTaskCanceled;	    }		    private void OnTaskCanceled(AppServiceConnection sender, AppServiceClosedEventArgs reason)	    {	        if (this.backgroundTaskDeferral != null)	        {	            Debug.WriteLine("ServiceClosed");	            // Complete the service deferral.	            this.backgroundTaskDeferral.Complete();	        }	    }	}	</code></pre>		<p>Placing a breakpoint in this function, i see that it was never triggered.	The app connection is opened using the singleton pattern, and putted in a dll that i use in the client app</p>		<pre><code>    public static AppServiceConnection GetDriverConnectionInstance()	    {	        if (_DriverConnectionInstance == null)	        {	            try	            {	                _DriverConnectionInstance = OpenDriverConnection().AsTask().GetAwaiter().GetResult();	            }	            catch	            {		            }	        }	        return _DriverConnectionInstance;   	    }	</code></pre>		<p>I also add a Request to the service that toggles a led, and i noticed that the led status changes but the response from the app service is still "Failure" and the message is null.</p>	"
50907993,88845726,50907993,3,0,Tue Jun 19 07:53:00 EDT 2018,6795124,"Hi @StefanWickMSFT, thanks for the reply: 1) Yes it is a background service running on the same RPi3. 2) No, this is the first time i heard about it. How have i to use it?"
50907993,88832393,50907993,3,0,Mon Jun 18 19:24:00 EDT 2018,686985,"A couple of questions to clarify the scenario: 1) is your client app also a UWP app running on the same device? 2) Does the ServicedClosed event get fired on your AppServiceConnection?"
50907993,50936748,50907993,2,0,Tue Jun 19 20:49:00 EDT 2018,686985,"<p>The AppService has a default lifetime of 25sec, unless it is being requested by the foreground experience. When the service shuts down the connection, your client process will receive the ServiceClosed event, so you know you will need to reopen the connection the next time you want to send a request.</p>	"
50907993,88884489,50936748,3,0,Wed Jun 20 08:21:00 EDT 2018,6795124,"Thanks for the clarification, let me investigate and i'll update the post."
50907993,89082235,50936748,3,0,Tue Jun 26 14:39:00 EDT 2018,6795124,"Thank you so Much Stefan Wick MSFT, listening the ServiceClose event i can restore the connection with the service app when it is. The only problem is that when the connection closing occurs, i loss one of the uart packet i've sent. So this let me think that the service app it's not the best way to manage a serial communication. What do you think?"
50907993,88958023,50936748,3,0,Fri Jun 22 05:43:00 EDT 2018,6795124,"The ServiceClosed event was never triggered. I updated the post, see it for more infos."
50907993,88974598,50936748,3,0,Fri Jun 22 14:20:00 EDT 2018,686985,"You need to listen to ServiceClosed on the client side of the AppServiceConnection, not on the server side."
