thread_ID, Id, ParentId, PostType, Score, CreationDate, OwnerID, Body
36532990,36532990,null,1,0,Sun Apr 10 17:22:00 EDT 2016,2013755,"<p>While researching about the embedded systems I found <code>libmraa</code> library for Linux. But I can't make sure that it is the right tool for me.</p>		<p>What I would like to do is to implement an embedded system that contains stepper motors, heaters and fans etc. It would be good If I can do it with Linux, but I thought that it is not practical and possible.</p>		<p>Does <code>libmraa</code> provide scheduling guarantees to ensure deterministic behaviour and timely response events and interrupts? Because I always make sure that steppers always work without any interruption.</p>		<p>Is <code>libmraa</code> just a tool for hobbyists or a good to for a real embedded system?</p>	"
36532990,36540967,36532990,2,1,Mon Apr 11 06:07:00 EDT 2016,3436922,"<p>A <code>lib</code> could not grant a real time behavior. It is a kernel matter.</p>		<p>You should use a real time Linux kernel: e.g. <a href="https://www.rtai.org/" rel="nofollow">RTI</a> or <a href="https://rt.wiki.kernel.org/index.php/RT_PREEMPT_HOWTO" rel="nofollow">PREEMPT RT Patch</a>.</p>	"
36532990,36542525,36532990,2,2,Mon Apr 11 07:36:00 EDT 2016,5257515,"<p><em>Warning: I have no experience with <code>mraa</code>. What I did though, beyond looking at what it's about, is clone the repo and grep the sources for 'sched', 'nice' etc.</em></p>		<p>The only thing I found is this <code>mraa_set_priority()</code> API:</p>		<p><a href="https://github.com/intel-iot-devkit/mraa/blob/master/api/mraa/common.h#L153" rel="nofollow">https://github.com/intel-iot-devkit/mraa/blob/master/api/mraa/common.h#L153</a></p>		<p>Note that it's for <code>SCHED_RR</code>, but there's no API for the more aggressive and deterministic <code>SCHED_FIFO</code> nor the modern refinement <code>SCHED_DEADLINE</code>.</p>		<p>So:</p>		<blockquote>	  <p>Does libmraa provide scheduling guarantees to ensure deterministic	  behaviour and timely response events and interrupts?</p>	</blockquote>		<p><strong>No</strong> (with the relatively minor exception of this <code>SCHED_RR</code> API).</p>		<p><strong>And it does so rightfully,</strong> since "Libmraa is a C/C++ library [...] to interface with the IO on Galileo, Edison &amp; other platforms", and scheduling policy has nothing to do with that: <strong>scheduling policy is an application specific and/or system integration wide (considering other processes) design decision and setup.</strong> It is most of the time (some exceptions exist) not a wise choice to hard-code a specific sched scheme into an application without considereng other running processes, nor the sched policy mechanisms built into the kernel or not (kernel configuration choice).</p>		<p>It is the job of:</p>		<ul>	<li><p>benchmark the system (kernel + app + other processes),</p></li>	<li><p>make use of standard tools (or the API they use into the app via	build or runtime configuration option) and/or configure the kernel to	make new sched options available,</p></li>	<li><p>benchmark again, rinse, repeat.</p></li>	</ul>		<p>The standard tools for this are:</p>		<ul>	<li><a href="http://linux.die.net/man/1/nice" rel="nofollow">nice</a></li>	<li><a href="http://linux.die.net/man/1/chrt" rel="nofollow">chrt</a></li>	<li><a href="http://linux.die.net/man/1/taskset" rel="nofollow">taskset</a></li>	</ul>		<p>...and the standard API they use, such as sched_set/getaffinity, sched_set/getscheduler etc (look at the <code>shchedutils/</code> source dir in the <a href="https://www.kernel.org/pub/linux/utils/util-linux/" rel="nofollow"><code>util-linux</code> package</a>).</p>		<p>As for the kernel scheduling options, look at <a href="https://www.kernel.org/doc/Documentation/" rel="nofollow">the doc</a> in the <code>scheduler/</code> subdir. You may also look at the CPU cgroup controller, look at <code>cgroup-v2.txt</code> or the <code>cgroup-v1/</code> subdir depending on your kernel version.</p>		<p>I did myself some benchmarks/tests for an embedded product using these alternatives, and finally decided to go with CPU shares from the CPU cgroup controller, because they were the "smartest self-adapting" and flexible load balancing mechanism for my case (mix of realtime vs non-realtime yet important for the product functionality vs low prio tasks such as logging). I did <em>not</em> considered/tested the cgroups cpuset, making not much sense for a dual-core embedded system, nor the  period/quota setups.</p>		<p>Of course, one may use a mix of above mentioned techniques.</p>		<blockquote>	  <p>Is libmraa just a tool for hobbyists or a good to for a real embedded	  system?</p>	</blockquote>		<p><em>Again, no experience with it. Though,</em> some experience with Intel open source (from their e10000 Ethernet drivers), and as for me Intel is serious and does not throw away some sources in the wild and then forget about it. Even for a very <a href="https://github.com/AVnu/Open-AVB" rel="nofollow">"prototypesque" project</a>.	For <code>mraa</code>, looking at github, there's minimal wiki, and a issue tracking showing some issues are indeed fixed.</p>		<p>So I would be inclined to trust it "for a real embedded system". The community may be small though, which is not a negligible factor.</p>		<p>PS:</p>		<p>The most important thing in all that is: <strong>benchmark</strong>, <em>benchmark</em>, benchmark...</p>		<p>EDIT:</p>		<p>And as for the "real RTOS" vs Linux:</p>		<p>I have some experience with that too, and though yes, technically this would be the rational choice for the application you describe, it only is if you have time (= money) and/or missing a deadline may led to catastrophic event such as hurting/killing someone or destroy something (including your own hardware, ex drone falling) or plain failing at doing its mission-critical job. Think defense, aerospace, health/medical equipment.</p>		<p>The development cycle of Linux (code -> build -> flash/install -> debug, repeat) vs a real-time OS will be faster with Linux (you can prototype a lot of things on your PC without any hardware yet), the ecosystem of libs/apps will be richer, the community will be wider, lesser special technical training required, tons of doc for everything etc = faster time to market and rich functionalities.</p>		<p>If the case of "no catastrophic event" considered, going to a real embedded RT OS is more a question of BOM (Bill Of Material: less flash/RAM/CPU power) or sometime legal liability regarding the product reliability.</p>		<p>And hard real-time with Linux is possible (not necessarily in the userland), as @LPs answer point out.</p>	"
