thread_ID, Id, ParentId, PostType, Score, CreationDate, OwnerID, Body
56288277,56288277,null,1,0,Fri May 24 08:02:00 EDT 2019,6225913,"<h2>Some context</h2>		<p>First let explain the context, for a course I had to create some protocol to save power consumption in a IoT <strong>IEEE 802.15.4</strong> network (thus how to optimise the routing, fault detection, ... to save energy since the devices are running on battery). The network should be a tree and each node has only one parent (I know this is not the best solution but those were the requirements of the teacher). We had to build it with the broadcast and (r)unicast of Rime. A Rime address are two 8 bits values (can be extended to two 16 bits values but I would like to avoid using them to keep the packets as small as possible).</p>		<p>It all works fine on contiki since rime is attributing the nodes an address automatically (base on there node id that is given when they are added to the simulation). When going to hardware all nodes had the same hardcoded id  (thus same address) and of course nothing was working. So I started to think about <strong>how to assign addresses to new nodes in the network?</strong></p>		<h2>Some solutions I found</h2>		<p>Different solutions came up:</p>		<ol>	<li><p>Don't do it dynamically and hardcode the addresses in each new node you want to add to the network. From what I read it is a common practice but I'm not satisfied by this since it is not quite user friendly and we have to maintain some list of all given addresses per network. </p></li>	<li><p>All nodes that connect to the network have to ask the the root node which address they may take (like on a normal internet network) but this requires a lot of messages in both directions and those devices are really slow. This would take a lot of time and will consume a lot of energy not only on the root node and the new node but on all nodes between them. Furthermore the root node will have the keep track of all addresses already given and they don't have much memory so when having a lot of nodes ...</p></li>	<li><p>Quite the same idea as in <strong>2.</strong> but here the parent node will not give an unique address to his new child but a range of addresses, the child will chose one and will be able to give a new range to his children (again this is quite what normal networks do). This is a better solution than the previous but the big drawback is that we the network is limited in depth (quite a lot). Like explained above the addresses are two 8bits values, this makes 65536 different addresses and with this solution the max depth of the network would be 6, thus in the worst case only 6 nodes could be added to the network ...  </p></li>	<li><p>The last idea is to let the new node chose an address when it boots. It would be a random value. So I tried to find the probability to have twice the same address on the network and I realised this is the same problem as the <a href="https://en.wikipedia.org/wiki/Birthday_problem" rel="nofollow noreferrer">birthday problem</a>. After some maths I found the following statistics:	<a href="https://i.stack.imgur.com/Ou0c3.png" rel="nofollow noreferrer"><img src="https://i.stack.imgur.com/Ou0c3.png" alt="General overview"></a></p></li>	</ol>		<p>We can see that it quickly raise to high chance of having duplicates, with 300 nodes we have 50% chance of having a duplicated node. When we take a closer look we can see that under 40 nodes we have less than 1% chance of having duplicated nodes, this become acceptable probabilities. </p>		<p><a href="https://i.stack.imgur.com/qKYbC.png" rel="nofollow noreferrer"><img src="https://i.stack.imgur.com/qKYbC.png" alt="Closer look"></a></p>		<p>But we will still have some probability to have duplicated nodes and this works for small networks, big networks would require to encoded the addresses on two 16 bits values (what I tried to avoid). The advantage of the two 16bits values for the address is that the chance of having duplicated nodes will be very low, even for quite big networks (don't have graphs or numbers to show ... My computer didn't like to calculate 2^32!) </p>		<h2>My question</h2>		<p>First of all thank you for reading up to here. I'm aware that this is maybe more a discussion than a actual question but still, I hope there is a good solution to this problem. </p>		<blockquote>	  <p>For what option should I go? The easy solution and don't try to make	  this dynamically or is dynamically a possible solution? Are there some	  <em>protocols</em> (not sure if this is the right term) that already solve this problem?</p>	</blockquote>		<p>Any advise or critic on my reasoning is welcome and any new idea is more than welcome.</p>		<p>Thank you for taking time to read all of this.</p>	"
56288277,99192379,56288277,3,0,Fri May 24 09:43:00 EDT 2019,2435820,"Maybe look at IPv6 duplicate address discovery. I suggest switching to IPv6 in the first place. Rime is a nice academic exercise, but it's also old and non-standard."
56288277,99192696,56288277,3,0,Fri May 24 09:53:00 EDT 2019,6225913,"@kfx Since it is an academic exercice ... ;) But to talk about IPv6, it is quite a waste of space to use IPv6 in a PAN where the goal is to safe space. I will have a look to your suggestion"
56288277,99194754,56288277,3,0,Fri May 24 10:56:00 EDT 2019,2435820,"You may be able to extract the main ideas behind IPv6 duplicate address detection and apply them in rime settings. Some code also could be reused."
56288277,99197976,56288277,3,0,Fri May 24 12:36:00 EDT 2019,6225913,"@kfx In the [RFC 44C9](https://tools.ietf.org/html/rfc4429#section-1.1) they are also using randomness but with 64bits values (which of course has a very low probability even when having up to thousands nodes) . I think I will go for randomness and in the configuration file let the choice of the having the addresses encoded on 16bits or 32bits depending on the scale of the network."
