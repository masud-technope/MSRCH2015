thread_ID, Id, ParentId, PostType, Score, CreationDate, OwnerID, Body
26179093,26179093,null,1,2,Fri Oct 03 12:39:00 EDT 2014,2165027,"<p>Could someone explain me what is going on within the Contiki-OS when it transmits an UDP packet?</p>		<p>Here is the current consumption of my device in details running with the CC2538 chip:</p>		<p><img src="https://i.stack.imgur.com/t1eAh.png" alt="CC2538 Current consumption"></p>		<p>My question is: why it takes so long to transmit an UDP broadcast packet (about 250ms) knowing that theoretically at 250kbps the packet of 408 bits length should be transmitted in approximately 2ms? I'd understand if the transmission last lets say ten milliseconds but here the difference is huge. </p>		<p>I use the example in  <code>contiki/examples/ipv6/simple-udp-rpl/broadcast-example.c</code></p>		<p>Does anyone have an idea? </p>	"
26179093,26184677,26179093,2,2,Fri Oct 03 18:30:00 EDT 2014,2435820,"<p>By default, Contiki uses ContikiMAC radio duty cycling (RDC) protocol. The protocol has to deal with two conflicting requirements: allow receiver nodes to sleep almost all of the time when there are no packets to receive, but at the same time allow to deliver data as reliably as possible. The solution adopted in ContikiMAC is to place the burden on the transmitter. Given that receiver checks the radio channel 8 times per second (the default configuration on cc2538dk platform), the transmitter has to transmit for at least 125 ms duration to be sure that the receiver has waken up and seen the packet. In practice, this means that a packet is retransmitted for multiple times in row. See the <a href="http://dunkels.com/adam/dunkels11contikimac.pdf" rel="nofollow">ContikiMAC paper</a> and <a href="https://github.com/contiki-os/contiki/wiki/Radio-duty-cycling#The_ContikiMAC_Radio_Duty_Cycling_Mechanism" rel="nofollow">Contiki documentation</a> for more detailed description.</p>		<p>That being said, you won't always see transmissions with the maximum duration. If its an unicast, the receiver normally sends an ACK after successful reception. The transmitter checks for this ACK, and stops transmitting if received. This way, the expected average number of transmissions required is reduced two times. And then there's also <a href="https://github.com/contiki-os/contiki/wiki/RDC-Phase-optimization" rel="nofollow">Phase Optimization</a> - it allows the sender to synchronize the start of transmission with the expected wakeup time of the receiver. But for broadcasts, no ACKs are generated and the phase optimization wont work.</p>		<p>Another possible reason for unexpectedly long transmissions is a failing CCA check. Before transmitting a packet, the radio stack first checks if the medium is free; if it's not, it will back up for some time and retry.</p>	"
26179093,41141392,26184677,3,0,Tue Oct 07 07:12:00 EDT 2014,2165027,"Thank you for your complete description. I already suspected the CCA check of 8Hz 'cause the duration of 250ms is the double period. Its seems that the radio is not turned off properly and it has to wait the next radio check before it try again."
26179093,26382347,26179093,2,1,Wed Oct 15 12:14:00 EDT 2014,2165027,"<p>I found the problem : the radio is not turned off properly after the transmission of a packet. </p>		<p>At the end of the function <code>transmit()</code> in the file <code>cpu/cc2538/dev/cc2538-rf.c</code> the radio is turned off only if it was previously off. </p>		<pre><code>if(rf_flags &amp; WAS_OFF) {	    rf_flags &amp;= ~WAS_OFF;	    off();	}	</code></pre>		<p>But actually the program never goes in this condition and the radio is not turned off immediately after the transmission of a packet.</p>		<p>The problem arises because the function <code>channel_clear()</code> (called at the beginning of the <code>transmit()</code> function) clears this flag first. Thus the function <code>transmit()</code> doesn't know anymore that the radio was off before its execution and therefore the radio is kept on.</p>		<p>To fix the problem I put a local variable inside the <code>channel_clear()</code> which turn off the radio and clear the flag only if it is turned on inside the function itself. </p>		<pre class="lang-c prettyprint-override"><code>static int	channel_clear(void)	{	  int cca;	  /* Fix: local variable */	  uint8_t intern_onoff;		  intern_onoff = 0;		  PRINTF("RF: CCA\n");		  /* If we are off, turn on first */	  if((REG(RFCORE_XREG_FSMSTAT0) &amp; RFCORE_XREG_FSMSTAT0_FSM_FFCTRL_STATE) == 0) {	    rf_flags |= WAS_OFF;	    on();	    intern_onoff = 1;	  }		  /* Wait on RSSI_VALID */	  while((REG(RFCORE_XREG_RSSISTAT) &amp; RFCORE_XREG_RSSISTAT_RSSI_VALID) == 0);		  if(REG(RFCORE_XREG_FSMSTAT1) &amp; RFCORE_XREG_FSMSTAT1_CCA) {	    cca = CC2538_RF_CCA_CLEAR;	  } else {	    cca = CC2538_RF_CCA_BUSY;	  }		  /* If we were off, turn back off */	  if((rf_flags &amp; WAS_OFF) == WAS_OFF &amp;&amp; intern_onoff) {	    rf_flags &amp;= ~WAS_OFF;	    off();	    intern_onoff = 0;	  }		  return cca;	}	</code></pre>		<p>The current consumption during a packet transmission looks like now to:</p>		<p><img src="https://i.stack.imgur.com/tM5si.png" alt="Current consumption of contiki-os when UDB transmission"></p>		<p><strong>Note</strong>: the strobe time was reduced intentionally to 10ms with:</p>		<pre><code>#define STROBE_TIME                        RTIMER_ARCH_SECOND / 100	</code></pre>		<p>This explain why there is only three strobes of transmission for the broadcast message. </p>		<p>The duration of a strobe is 3ms. Which means that the data rate is ~140kbps (?). </p>	"
