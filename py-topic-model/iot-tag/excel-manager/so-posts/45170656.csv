thread_ID, Id, ParentId, PostType, Score, CreationDate, OwnerID, Body
45170656,45170656,null,1,0,Tue Jul 18 15:08:00 EDT 2017,8324091,"<p><strong>Background:</strong> I am looking for a generic approach to implement standard functions for an Raspberry Pi IoT hobby project which communicates to different hardware devices through serial communication . The devices identify themselves by returning the "protocol version" they use and which command groups of the protocol they have implemented.</p>		<blockquote>	  <p><strong><em>Example 1:</em></strong></p>	  	  <ul>	  <li>Device1: "Protocol V1a" Group "a,b"</li>	  <li>Device2: "Protocol V2" Group "a,c"</li>	  <li>Device3: and so on...</li>	  </ul>	</blockquote>		<p>The basic supported commands within the different protocols are the same but for different versions they expect different implementations.</p>		<blockquote>	  <p><strong><em>Example 2:</em></strong></p>	  	  <ul>	  <li><p>Protocol V1a:</p>	  	  <ul>	  <li>Command group a:	  	  <ul>	  <li>void sendAck(){SerialWrite(byte 0x0A);}</li>	  <li>void sendNak(){SerialWrite(byte 0x00);}</li>	  </ul></li>	  </ul></li>	  <li><p>Protocol V2:</p>	  	  <ul>	  <li>Command group a:	  	  <ul>	  <li>void sendAck(){SerialWrite(byte 0x1A);}</li>	  <li>void sendNak(){SerialWrite(byte 0x10);}</li>	  </ul></li>	  </ul></li>	  </ul>	</blockquote>		<p><strong>Goal:</strong> My goal is to be able to connect the raspberry pi running the application to one of the random devices and after receiving the protocol version and supported command groups from the device create the necessary objects in code.</p>		<p><strong>What i have achieved so far:</strong>	Serial communication with the devices works. I know the different commands but want to make it more generic and flexible. So for the basic definition of the commands i created an interface definition.</p>		<pre><code>interface IDeviceProtocol	{	    // Group a commands	    void sendAck();	    void sendNak();		    // Group b commands	    void someOtherCommand();	}	</code></pre>		<p>By doing so i can use the interface definition and implement the necessary commands per protocol.</p>		<pre><code>class ProtocolV1a: IDeviceProtocol	{	    // Explicit interface member implementation: 	    void IDeviceProtocol.sendAck()	    {	        SerialWrite(byte 0x0A);	    }		    // Explicit interface member implementation: 	    void IDeviceProtocol.sendNak()	    {	        SerialWrite(byte 0x00);	    }		    static void Main()	    {	       // Some protocol specific code here.	    }	}	</code></pre>		<p>Now i should be able to use the following code in my main program to call the protocol specific class. Is this correct?</p>		<pre><code>IDeviceProtocol Device1 = new ProtocolV1a();	Device1.sendAck();	</code></pre>		<p>or if it would be a V2 protocol device:</p>		<pre><code>IDeviceProtocol Device2 = new ProtocolV2();	Device2.sendAck();	</code></pre>		<p><strong>Question:</strong>	Is it possible to have some sort of enumerator list with all the possible Protocol versions listed. And based on the returned protocol version from the device create the device class with the correct Protocol class? </p>		<p>Something like this:</p>		<pre><code>// returns the protocol used by the device    	    EnumProtocols pversion = ReceiveProtocol(); 		    IDeviceProtocol genericDevice = new IDeviceProtocol(pversion);		    genericDevice.sendAck();	</code></pre>		<p>Does this approach have a name so i can look that up and learn how to do it?	Can you give me some pointers where to start looking, or maybe some example code?</p>	"
45170656,45171619,45170656,2,0,Tue Jul 18 15:47:00 EDT 2017,1304444,"<p>I think that what you are looking for is the Factory Design Pattern.</p>		<p>Something like this may accomplish your goal:</p>		<pre><code>public enum Protocol	{	    Version1,	    Version1A,	    Version2	}		public IDeviceProtocol CreateDeviceProtocol(Protocol protocol)	{	    switch protocol	    {	        case Protocol.Version1:	            return new Device1();	            break;	        case Protocol.Version1A:	            return new Device1A();	            break;	        case Protocol.Version2:	            return new Device2();	            break;	        default:	            //throw some error  	    }	}	</code></pre>	"
45170656,77321514,45171619,3,0,Tue Jul 18 20:28:00 EDT 2017,8324091,"Thank you for pointing me into the right direction. This is indeed something i was looking for. Also i have found this reference with in depth explanation of the factory design patern: https://msdn.microsoft.com/en-us/library/ee817667.aspx"
