thread_ID, Id, ParentId, PostType, Score, CreationDate, OwnerID, Body
56176907,56176907,null,1,0,Thu May 16 21:36:00 EDT 2019,11323731,"<p>I have to setup the remote control of a MCU application. </p>		<p>On field the MCU is based on an ATMEGA 1284P.	The MCU is completed with a GPRS modem based on the SIM808 module.</p>		<p>The MCU setups a TCPIP connection with a remote SERVER at its IP address and port.	At the MCU side everything is based on the official SIM900_TCPIP_Application Note_V1.02 and I compared the implementation with <a href="https://vsblogs.wordpress.com/2013/11/28/tcp-connection-over-gprs-using-sim900-and-at-commands/" rel="nofollow noreferrer">https://vsblogs.wordpress.com/2013/11/28/tcp-connection-over-gprs-using-sim900-and-at-commands/</a> and  <a href="https://www.electronicwings.com/pic/pic18f4550-interface-with-sim900a-gprs" rel="nofollow noreferrer">https://www.electronicwings.com/pic/pic18f4550-interface-with-sim900a-gprs</a> and <a href="https://www.cooking-hacks.com/documentation/tutorials/gprs-gsm-quadband-module-arduino-raspberry-pi-tutorial-sim-900#introduction" rel="nofollow noreferrer">https://www.cooking-hacks.com/documentation/tutorials/gprs-gsm-quadband-module-arduino-raspberry-pi-tutorial-sim-900#introduction</a></p>		<p>The connection with the SERVER takes place regularly, the JSON string from the client to the server is sent properly and the GUI APP at the server side receives the JSON and update the GUI interface properly, as expected.	So the remote monitoring works perfectly, continuoulsy, and forever (till the SERVER is not stopped).</p>		<p>The GUI APP is written is Qt C++.	The MCU code is written in AVRstudio C.</p>		<hr>		<p>When the Qt APP, really the server, tries to send back a JSON, at the MCU I receive a string into the UART buffer; if I check it, it is like expected but the GPRS modem enter in a kind of infinite loop.	The GPRS modem never release the control, never accepts any other AT command.	So I cannot send any other JSON and update the remote monitor.	The only way out is the reset of the modem and cancel the TCPIP session.</p>		<p>After the reset it is again possible to send all the JSON wanted, but at the first tentative to send a JSON from the Qt APP to the MCU the modem becomes blocked and does not accept any other AT command.</p>		<p>I have to reset it.</p>		<h2>Finally <strong>it is impossible for the SERVER to send a JSON to the client</strong>. It receives properly, but fails when wants to reply.</h2>		<p>This is how we are reading/writing data from application (SERVER side)</p>		<pre><code>#include "communicationhandler.h"	#include &lt;QTcpSocket&gt;	#include &lt;QJsonDocument&gt;	#include &lt;QJsonObject&gt;	#include &lt;QtDebug&gt;		CommunicationHandler::CommunicationHandler(QObject *parent)	    : QObject(parent)	{	    init();	}		void CommunicationHandler::init()	{	    tcpServer = new QTcpServer(this);	}		bool CommunicationHandler::startServer(int port)	{	    if (tcpServer-&gt;isListening())	        return true;		    if (port &lt;= 0)	    {	        return false;	    }		    if (tcpServer-&gt;listen(QHostAddress::AnyIPv4, port))	    {	        connect(tcpServer, &amp;QTcpServer::newConnection,	                this, &amp;CommunicationHandler::onNewConnection);		        return true;	    }		    return false;	}		bool  CommunicationHandler::stopServer()	{	    if (!tcpServer-&gt;isListening())	        return true;		    tcpServer-&gt;close();	    return true;	}		bool CommunicationHandler::isServerListening()	{	    return  tcpServer-&gt;isListening();	}		void CommunicationHandler::onNewConnection()	{	    connectionSocket = tcpServer-&gt;nextPendingConnection();	    connect(connectionSocket, &amp;QTcpSocket::readyRead, this, &amp;CommunicationHandler::onData);	}		void CommunicationHandler::onData()	{	    QTcpSocket* socket = (QTcpSocket*)sender();	    if (socket)	    {	        QByteArray data = socket-&gt;readAll();		        jsonData += data;		        qDebug() &lt;&lt; jsonData;	        QJsonDocument jsonDoc = QJsonDocument::fromJson(jsonData);	        if (!jsonDoc.isEmpty())	        {	            emit jsonReceived(jsonDoc);	            dataToBeSent = jsonData;	            jsonData.clear();	        }	    }	}		void CommunicationHandler::sendParameterData(const QByteArray&amp; data)	{	    QJsonDocument jsonDoc = QJsonDocument::fromJson(data);	    if (!jsonDoc.isEmpty())	    {	        QJsonDocument fullJsonDoc = QJsonDocument::fromJson(dataToBeSent);	        if (!fullJsonDoc.isEmpty())	        {	            //"{\"buzzer\":\"y\",\"deltaRpm\":50,\"door\":11,\"function\":\"a\",\"ins\":{\"l1\":120,\"l2\":100,\"l3\":80,\"l4\":20},\"powerMode\":\"b\",\"pressure\":35,\"reactTime\":12,\"rel\":{\"l1\":220,\"l2\":180,\"l3\":45,\"l4\":0},\"rpm\":2800,\"service\":127,\"test\":\"y\"}"		            QVariantMap map = jsonDoc.toVariant().toMap();		            QVariantMap fullMap = fullJsonDoc.toVariant().toMap();		            fullMap["buzzer"] = map.value("buzzer");	            fullMap["deltaRpm"] = map.value("deltaRpm");	            fullMap["door"] = map.value("door");	            fullMap["function"] = map.value("function");	            fullMap["ins"] = map.value("ins");	            fullMap["powerMode"] = map.value("powerMode");	            fullMap["pressure"] = map.value("pressure");	            fullMap["reactTime"] = map.value("reactTime");	            fullMap["rel"] = map.value("rel");	            fullMap["rpm"] = map.value("rpm");	            fullMap["service"] = map.value("service");	            fullMap["test"] = map.value("test");		            QJsonDocument doc  = QJsonDocument::fromVariant(fullMap);	            QByteArray jsonData = doc.toJson(QJsonDocument::Compact);		            sendData(jsonData);	        }	    }	}		void CommunicationHandler::sendData(const QByteArray&amp; data)	{	    if (connectionSocket!=nullptr)	    {	        qDebug() &lt;&lt; "Sending Data to Device: " &lt;&lt; data;	        QByteArray dataToBeSent = data;	        dataToBeSent.append('\r');	        connectionSocket-&gt;write(dataToBeSent);	        connectionSocket-&gt;flush();	    }	</code></pre>		<h2>    }</h2>		<p>Why the APP at the SERVER SIDE, when sends a JSON to the client blocks the GPRS modem?	Is there any handshake to do at the Server side before to send a JSON to the MCU? </p>		<p>How the TCPIP layer at the Server side informs that it is ready to accept a string to send to the client?	At the MCU side after the AT+CIPSEND, the TCPIP layer releases a prompt > and only after this prompt it is possible to send the JSON. When the transmission is succefully completed (received by the SERVER) the TCPIP layer releases a SEND OK, really the OK to send a new JSON.	<strong>Nothing similar at the SERVER side?</strong></p>		<p>I have not find any useful explanation on how and when the SERVER can send a JSON back to the MCU. Immediately after the JSON from the MCU is received and without any care about any prompts from the TCPIP layer?</p>		<p>If at the ATMEGA MCU side I am quite skilled, my ability with the Server code is limited.</p>		<p>Of course I can post the C code about the MCU but it is quite complex and not of immediate reading because the management of the GPRS modem and all the AT commands are made in parallel with all the other process that controls the devices connected. So the processes are divided into steps and each step takes place only when a countdown is over. 	Anyway if needed I will post. </p>		<p>I think the trouble is at the SERVER side and not at the MCU side.</p>		<p>Thank you for any help.</p>		<p>Best regards.	Mario</p>	"
