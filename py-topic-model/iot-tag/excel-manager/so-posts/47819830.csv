thread_ID, Id, ParentId, PostType, Score, CreationDate, OwnerID, Body
47819830,47819830,null,1,1,Thu Dec 14 18:22:00 EST 2017,1909309,"<p>I am working on IoT project with NXP i.MX7D . In this project I used Google Nearby API to publish data from companion app to the things app . I have followed this project <a href="https://github.com/rodrigosimoesrosa/nearby-api-pub-sub-kotlin" rel="nofollow noreferrer">nearby-kotlin</a> . I have followed almost exactly as this repo . but in my case both of my app is publishing is subscribing successfully . Here are my code for two activity first one is companion app's <code>MainActiviy.kt</code> and second one is for the activity running on the NXP i.MX7D </p>		<pre><code>class MainActivity : AppCompatActivity(), GoogleApiClient.ConnectionCallbacks, GoogleApiClient.OnConnectionFailedListener {			/**	 * The entry point to Google Play Services.	 */	private var mGoogleApiClient: GoogleApiClient? = null		/**	 * A [MessageListener] for processing messages from nearby devices.	 */	private var messageListener: MessageListener? = null				/**	 * One minutes.	 */	private val ttlInSeconds = 60 * 3	/**	 * Sets the time in seconds for a published message or a subscription to live. Set to three	 * minutes in this sample.	 */	private val publishSubscriptionStrategy = Strategy.Builder().setTtlSeconds(ttlInSeconds).build()			private val savedInstance = Calculate::class.java.simpleName		private val TAG = MainActivity::class.java.simpleName		private val keyUUID: String = "UUID_KEY"		private lateinit var calculation: Calculate		override fun onCreate(savedInstanceState: Bundle?) {	    super.onCreate(savedInstanceState)		    calculation = savedInstanceState?.get(savedInstance) as Calculate? ?:	            Calculate.builder(getUUID(getSharedPreferences(applicationContext.packageName, Context.MODE_PRIVATE)),	                    "0", "0", Operator.OPERATOR_PLUS)		    val binding = DataBindingUtil.setContentView&lt;ActivityMainBinding&gt;(this, R.layout.activity_main)	    binding.calculate = calculation		    setOperatorDrawable(calculation.operator)			    messageListener = object : MessageListener() {	        override fun onFound(message: Message) {	            Calculate.fromMessage(message).toString()	            resultTv.text = calculation.result	        }		        override fun onLost(message: Message) {		        }	    }		    if (mGoogleApiClient != null &amp;&amp; mGoogleApiClient!!.isConnected)	        subscriberForMessage()			    fab_plus.setOnClickListener {	        publishMessage()	        calculation.operator = "Plus"	        calculation.operandOne = operandOneET.text.toString()	        calculation.operandTwo = operandTwoET.text.toString()	        setOperatorDrawable(calculation.operator)	    }		    fab_minus.setOnClickListener {	        Log.i(TAG, "minus clicked")	        publishMessage()	        calculation.operator = "Minus"	        calculation.operandOne = operandOneET.text.toString()	        calculation.operandTwo = operandTwoET.text.toString()	        setOperatorDrawable(calculation.operator)	    }		    fab_multiply.setOnClickListener {	        publishMessage()	        calculation.operator = "Multiply"	        calculation.operandOne = operandOneET.text.toString()	        calculation.operandTwo = operandTwoET.text.toString()	        setOperatorDrawable(calculation.operator)	    }		    fab_divide.setOnClickListener {		        if (calculation.operandTwo.equals("0")) {	            Snackbar.make(resultTv, "Divide by zero exception", Snackbar.LENGTH_SHORT).show()		            return@setOnClickListener	        }	        publishMessage()	        calculation.operator = "Divide"	        calculation.operandOne = operandOneET.text.toString()	        calculation.operandTwo = operandTwoET.text.toString()	        setOperatorDrawable(calculation.operator)	    }		    buildGoogleApiClient()	}			private fun setOperatorDrawable(operator: String?) {		    when (operator) {	        "Plus" -&gt; operatorIV.setImageResource(android.R.drawable.ic_input_add)	        "Minus" -&gt; operatorIV.setImageResource(R.drawable.ic_minus_symbol)	        "Multiply" -&gt; operatorIV.setImageResource(R.drawable.ic_multiply)	        else -&gt; operatorIV.setImageResource(R.drawable.ic_divide)	    }	}			private fun getUUID(sharedPreferences: SharedPreferences): String {	    var uuid = sharedPreferences.getString(keyUUID, "")		    if (uuid.isEmpty()) {	        uuid.apply {	            uuid = UUID.randomUUID().toString()	            sharedPreferences.edit().putString(keyUUID, this).apply()	        }	    }		    return uuid	}		override fun onSaveInstanceState(outState: Bundle?) {	    super.onSaveInstanceState(outState)		    outState?.putSerializable(savedInstance, calculation)	}		private fun buildGoogleApiClient() {		    if (mGoogleApiClient != null)	        return			    mGoogleApiClient = GoogleApiClient.Builder(this@MainActivity)	            .addApi(Nearby.MESSAGES_API)	            .addConnectionCallbacks(this@MainActivity)	            .enableAutoManage(this@MainActivity, this@MainActivity)	            .build()	}			/**	 * Publishes a message to nearby devices and updates the UI if the publication either fails or	 * TTLs.	 */	private fun publishMessage() {	    Log.i(TAG, "publishing msg")			    val option: PublishOptions = PublishOptions.Builder().setStrategy(publishSubscriptionStrategy)	            .setCallback(object : PublishCallback() {	                override fun onExpired() {	                    super.onExpired()		                    Log.i(TAG, "Message Publish expired")	                    runOnUiThread { Snackbar.make(resultTv, "Publish expired", Snackbar.LENGTH_SHORT).show() }	                }	            }).build()		    Nearby.Messages.publish(mGoogleApiClient, calculation.toMessage(), option)	            .setResultCallback { status -&gt;	                if (status.isSuccess) {	                    Log.i(TAG, "publishing was successful")	                    Snackbar.make(resultTv, "publishing successful", Snackbar.LENGTH_SHORT).show()	                } else {	                    Snackbar.make(resultTv, "Couldn't publish " + status, Snackbar.LENGTH_SHORT).show()	                }		            }		}		/**	 * Subscribes to messages from nearby devices and updates the UI if the subscription either	 * fails or TTLs.	 */	private fun subscriberForMessage() {	    Log.i(TAG, "Subscribing")		    val option: SubscribeOptions = SubscribeOptions.Builder().setStrategy(publishSubscriptionStrategy)	            .setCallback(object : SubscribeCallback() {	                override fun onExpired() {	                    super.onExpired()		                    Log.i(TAG, "Subscription expired")	                    runOnUiThread { Snackbar.make(resultTv, "Subscription expired", Snackbar.LENGTH_SHORT).show() }	                }	            }).build()		    Nearby.Messages.subscribe(mGoogleApiClient, messageListener, option)	            .setResultCallback { status -&gt;	                if (status.isSuccess) {	                    Log.i(TAG, "subscription was successful")	                    Snackbar.make(resultTv, "Subscription successful", Snackbar.LENGTH_SHORT).show()	                } else {	                    Snackbar.make(resultTv, "Couldn't subscribe " + status, Snackbar.LENGTH_SHORT).show()	                }		            }		}		/**	 * Stops publishing message to nearby devices.	 */	private fun unpublish() {	    Log.i(TAG, "Unpublishing.")	    Nearby.Messages.unpublish(mGoogleApiClient, calculation.toMessage())	}			override fun onConnected(bundle: Bundle?) {	    Log.i(TAG, "GoogleApiClient connected")	    Snackbar.make(resultTv, "GoogleApiClient connected", Snackbar.LENGTH_SHORT).show()		    publishMessage()	    subscriberForMessage()	}		override fun onConnectionSuspended(i: Int) {	    Snackbar.make(resultTv, "Google Api connection Suspended", Snackbar.LENGTH_SHORT).show()	 }		override fun onConnectionFailed(connectionResult: ConnectionResult) {	    Snackbar.make(resultTv, "connection Failed" + connectionResult.errorMessage, Snackbar.LENGTH_SHORT).show()	 } }	</code></pre>		<p>activty for the app running on things </p>		<pre><code>class MainActivity : AppCompatActivity(), GoogleApiClient.ConnectionCallbacks, GoogleApiClient.OnConnectionFailedListener {			/**	 * The entry point to Google Play Services.	 */	private var mGoogleApiClient: GoogleApiClient? = null		/**	 * A [MessageListener] for processing messages from nearby devices.	 */	private var messageListener: MessageListener? = null			/**	 * One minutes.	 */	private val ttlInSeconds = 60 * 3	/**	 * Sets the time in seconds for a published message or a subscription to live. Set to three	 * minutes in this sample.	 */	private val publishSubscriptionStrategy = Strategy.Builder().setTtlSeconds(ttlInSeconds).build()			private val savedInstance = Calculation::class.java.simpleName		private val TAG = MainActivity::class.java.simpleName		private val keyUUID: String = "UUID_KEY"		private lateinit var calculation: Calculation			override fun onCreate(savedInstanceState: Bundle?) {	    super.onCreate(savedInstanceState)	    setContentView(R.layout.activity_main)		    calculation = savedInstanceState?.get(savedInstance) as Calculation? ?:	            Calculation.builder(getUUID(getSharedPreferences(applicationContext.packageName, Context.MODE_PRIVATE)),	                    "0", "0", Operator.OPERATOR_PLUS)		    setOperatorName(calculation.operator)				    messageListener = object : MessageListener() {	        override fun onFound(message: Message) {	            Calculation.fromMessage(message).toString()	            Log.i(TAG , "message found "+calculation.operandOne)	        }		        override fun onLost(message: Message) {	            Log.i(TAG, "message lost " + message)	        }	    }		    checkBox.setOnCheckedChangeListener({ _, isChecked -&gt;	        if (mGoogleApiClient != null &amp;&amp; mGoogleApiClient!!.isConnected)	            if (isChecked)	                subscriberForMessage()	            else	                unsubscribe()	    })		    buildGoogleApiClient()		}			private fun setOperatorName(operator: String?) {		    when (operator) {	        "Plus" -&gt; operatorTv.text = "plus"	        "Minus" -&gt; operatorTv.text = "minus"	        "Multiply" -&gt; operatorTv.text = "times"	        else -&gt; operatorTv.text = "divided"	    }	}			private fun getUUID(sharedPreferences: SharedPreferences): String {	    var uuid = sharedPreferences.getString(keyUUID, "")		    if (uuid.isEmpty()) {	        uuid.apply {	            uuid = UUID.randomUUID().toString()	            sharedPreferences.edit().putString(keyUUID, this).apply()	        }	    }		    return uuid	}		override fun onSaveInstanceState(outState: Bundle?) {	    super.onSaveInstanceState(outState)		    outState?.putSerializable(savedInstance, calculation)	}			private fun buildGoogleApiClient() {		    if (mGoogleApiClient != null)	        return			    mGoogleApiClient = GoogleApiClient.Builder(this@MainActivity)	            .addApi(Nearby.MESSAGES_API)	            .addConnectionCallbacks(this@MainActivity)	            .enableAutoManage(this@MainActivity, this@MainActivity)	            .build()			}		/**	 * Publishes a message to nearby devices and updates the UI if the publication either fails or	 * TTLs.	 */	private fun publishMessage() {	    Log.i(TAG, "publishing msg")			    val option: PublishOptions = PublishOptions.Builder().setStrategy(publishSubscriptionStrategy)	            .setCallback(object : PublishCallback() {	                override fun onExpired() {	                    super.onExpired()		                    Log.i(TAG, "Message Publish expired")	                    runOnUiThread { Snackbar.make(resultTv, "Publish expired", Snackbar.LENGTH_SHORT).show() }	                }	            }).build()		    Nearby.Messages.publish(mGoogleApiClient, calculation.toMessage(), option)	            .setResultCallback { status -&gt;	                if (status.isSuccess) {	                    Log.i(TAG, "publishing was successful")	                    Snackbar.make(resultTv, "publishing successful", Snackbar.LENGTH_SHORT).show()	                } else {	                    Snackbar.make(resultTv, "Couldn't publish " + status, Snackbar.LENGTH_SHORT).show()	                }		            }		}		/**	 * Subscribes to messages from nearby devices and updates the UI if the subscription either	 * fails or TTLs.	 */	private fun subscriberForMessage() {	    Log.i(TAG, "Subscribing")			    val option: SubscribeOptions = SubscribeOptions.Builder().setStrategy(publishSubscriptionStrategy)	            .setCallback(object : SubscribeCallback() {	                override fun onExpired() {	                    super.onExpired()		                    Log.i(TAG, "Subscription expired")	                    runOnUiThread {	                        Snackbar.make(resultTv, "Subscription expired", Snackbar.LENGTH_SHORT).show()	                        checkBox.isChecked = false	                    }	                }	            }).build()		    Nearby.Messages.subscribe(mGoogleApiClient, messageListener, option)	            .setResultCallback { status -&gt;	                if (status.isSuccess) {	                    Log.i(TAG, "subscription was successful" + status.statusMessage)	                    Snackbar.make(resultTv, "Subscription successful", Snackbar.LENGTH_SHORT).show()	                } else {	                    Snackbar.make(resultTv, "Couldn't subscribe " + status, Snackbar.LENGTH_SHORT).show()	                }		            }		}		/**	 * Stops publishing message to nearby devices.	 */	private fun unpublish() {	    Log.i(TAG, "Unpublishing.")	    Nearby.Messages.unpublish(mGoogleApiClient, calculation.toMessage())	}		/**	 * Stops subscribing to messages from nearby devices.	 */	private fun unsubscribe() {	    Log.i(TAG, "Unsubscribing.")	    Nearby.Messages.unsubscribe(mGoogleApiClient, messageListener)	}			override fun onConnected(bundle: Bundle?) {	    Log.i(TAG, "GoogleApiClient connected")		    if (checkBox.isChecked)	        subscriberForMessage()		    publishMessage()		    //Snackbar.make(operatorTv, "GoogleApiClient connected", Snackbar.LENGTH_SHORT).show()	}		override fun onConnectionSuspended(i: Int) {	    Log.i(TAG, "GoogleApiClient connection suspended")	    //Snackbar.make(operatorTv, "Google Api connection Suspended", Snackbar.LENGTH_SHORT).show()	}		override fun onConnectionFailed(connectionResult: ConnectionResult) {	    Log.i(TAG, "GoogleApiClient connection failed")	    checkBox.isChecked = false	    //Snackbar.make(operatorTv, "connection Failed" + connectionResult.errorMessage, Snackbar.LENGTH_SHORT).show()	} } 	</code></pre>		<p>if you guys need to check the class which has been serialized and deserialized with Gson to send as payload nearmy message this calsses are <a href="https://github.com/1abid/AndroidThings-calculator-/blob/master/app/src/main/java/com/vutkathings/increment/Calculate.kt" rel="nofollow noreferrer">Calculate</a> &amp; <a href="https://github.com/1abid/AndroidThings-calculator-/blob/master/thingscalulator/src/main/java/com/vutkathings/calculation/Calculation.kt" rel="nofollow noreferrer">Calculation</a> </p>		<p>this is my Hello world type project for IoT . Help and suggestion is appreciated .</p>		<p>Thanks is advance </p>	"
47819830,82605628,47819830,3,0,Thu Dec 14 20:30:00 EST 2017,1491707,"It seems like you never call `mGoogleApiClient.connect()`. Can you add that call and see if you get the onConnected callback?"
47819830,82606176,47819830,3,0,Thu Dec 14 20:50:00 EST 2017,1909309,"@NickFelker basically I followed this code from google code samles (https://github.com/googlesamples/android-nearby/blob/master/messages/NearbyDevices/app/src/main/java/com/google/android/gms/nearby/messages/samples/nearbydevices/MainActivity.java) 		there code is working . there was no  mGoogleApiClient.connect() in there code . where should I call this function"
47819830,52896331,47819830,2,0,Fri Oct 19 16:19:00 EDT 2018,4811948,"<p>The Google Nearby API is proving really tricky to work with. I am having the same problem with it, in my <em>JAVA</em> code, which was working perfectly until <strong>today</strong>. I created my <strong><em>NearbyManager</em></strong> Class to help automate and clear up the mainline code. Suddenly I'm not able to publish. <strong>My publish Success Callback is never fired</strong>. <em>Nor do I receive any messages</em>. </p>		<p>Look at your <strong>Log</strong>, I found out that somehow my <strong>API Key was not accepted by Google</strong> (I cleared my Log so no snap!), because my <em>SHA1(Android Debug Key)</em> fingerprint had changed (Again, makes no sense to me why, if anyone can explain, I'll be grateful), so I went to my <strong>Console</strong> and updated my fingerprint. This might have worked, though it's not been very long since I made that change, I'm yet to see results or test.</p>		<p>My code is not a solution to the problem, but is more of a prerequisite I put together to get people started with the <em>Nearby API</em>! We don't have a supporting class as such and I figured this would <em>help anyone starting out</em>! <em>This should help you to find missing pieces in your puzzle</em>! Good luck!</p>		<pre><code>import android.app.Activity;	import android.content.Context;	import android.content.SharedPreferences;	import android.util.Log;	import android.widget.Toast;	import com.google.android.gms.nearby.Nearby;	import com.google.android.gms.nearby.messages.Message;	import com.google.android.gms.nearby.messages.MessageListener;	import com.google.android.gms.nearby.messages.MessagesClient;	import com.google.android.gms.nearby.messages.PublishCallback;	import com.google.android.gms.nearby.messages.PublishOptions;	import com.google.android.gms.nearby.messages.Strategy;	import com.google.android.gms.nearby.messages.SubscribeCallback;	import com.google.android.gms.nearby.messages.SubscribeOptions;	import com.google.android.gms.tasks.OnSuccessListener;		public class NearbyManager {	    private boolean isSubscribing = false;	    private boolean isPublishing = false;	    private Activity current;	    private MessagesClient mMessageClient;	    private MessageListener mMessageListener;	    private static final Strategy PUB_STRATEGY = new Strategy.Builder()	            .setTtlSeconds(Strategy.TTL_SECONDS_DEFAULT).build();	    private static final Strategy SUB_STRATEGY = new Strategy.Builder()	            .setTtlSeconds(Strategy.TTL_SECONDS_MAX).build();	    private String mPubMessage;			    public boolean isSubscribing() {	        return isSubscribing;	    }		    public boolean isPublishing() {	        return isPublishing;	    }		    public NearbyManager(Activity activity){	        current = activity;	        PermissionManager.checkPerms(current);	        mMessageClient = Nearby.getMessagesClient(current);	        mMessageListener = new MessageListener(){	            @Override	            public void onFound(Message message) {	                if(message != null){	                    //DO SOMETHING	                    }	                }	            }	            @Override	            public void onLost(Message message) {	                Toast.makeText(current, "Device is lost", Toast.LENGTH_SHORT).show();	            }	        };		    }	    public void publish(final String message){	        mPubMessage = message;	        PublishOptions options = new PublishOptions	                .Builder()	                .setStrategy(PUB_STRATEGY)	                .setCallback(new PublishCallback(){	                    @Override	                    public void onExpired() {	                        super.onExpired();	                        current.runOnUiThread(new Runnable() {	                            @Override	                            public void run() {	                                isPublishing = false;	                            }	                        });	                    }	                })	                //.setStrategy(Strategy.BLE_ONLY) &lt;-- removed this	                .build();	        mMessageClient.publish(new Message(message.getBytes()), options).addOnSuccessListener(current, new OnSuccessListener&lt;Void&gt;() {	            @Override	            public void onSuccess(Void aVoid) {	                Toast.makeText(current, "Publishing! Message:" + message, Toast.LENGTH_SHORT).show();	            }	        });	        isPublishing = true;	    }	    public void subscribe(){	        SubscribeOptions options = new SubscribeOptions.Builder()	                .setStrategy(SUB_STRATEGY)	                .setCallback(new SubscribeCallback(){	                    @Override	                    public void onExpired() {	                        super.onExpired();	                        Toast.makeText(current, "No longer Subscribing!", Toast.LENGTH_SHORT).show();	                        current.runOnUiThread(new Runnable() {	                            @Override	                            public void run() {	                                isSubscribing = false;	                            }	                        });	                    }	                })	                //.setStrategy(Strategy.BLE_ONLY) &lt;-- removed this	                .build();	        mMessageClient.subscribe(mMessageListener, options).addOnSuccessListener(current, new OnSuccessListener&lt;Void&gt;() {	            @Override	            public void onSuccess(Void aVoid) {	                Toast.makeText(current, "Subscribing!", Toast.LENGTH_SHORT).show();	            }	        });	        isSubscribing = true;	    }	    public void unsubscribe(){	        if(isSubscribing &amp;&amp; mMessageClient != null)	            mMessageClient.unsubscribe(mMessageListener);	        isSubscribing = false;	    }	    public void unpublish(){	        if(isPublishing &amp;&amp; mMessageClient != null)	            mMessageClient.unpublish(new Message(mPubMessage.getBytes()));	        isPublishing = false;	    }		}	</code></pre>		<p>One recommendation I would give is to trace your function calls by placing Log or Toast statements in your function call body. Like inside mMessageListener, publish and subscribe. </p>		<p>plus I didn't read much of your code, but I hope you are programatically checking if publish and subscribe is a success using onSuccessListeners.</p>	"
47819830,92708808,52896331,3,0,Fri Oct 19 18:40:00 EDT 2018,4811948,"Finally started working again. I tried a lot of things until removing `.setStrategy(Strategy.BLE_ONLY)` made it work again."
