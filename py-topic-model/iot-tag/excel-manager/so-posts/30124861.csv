thread_ID, Id, ParentId, PostType, Score, CreationDate, OwnerID, Body
30124861,30124861,null,1,7,Fri May 08 13:17:00 EDT 2015,4879053,"<p>I'm trying to read the distance from an ultrasonic sensor (HC-SR04) but the only values I get is 0 and 265.xx. </p>		<p>I am using an Raspberry Pi 2 with Windows 10 IoT Core installed. </p>		<p>I've written the code in C#.</p>		<p>This is the ultrasonic sensor class:</p>		<pre><code>using System;	using System.Collections.Generic;	using System.Linq;	using System.Text;	using System.Threading;	using System.Threading.Tasks;	using System.Diagnostics;	using Windows.Devices.Gpio;		namespace RaspberryPi	{	    class UcSensor	    {	        GpioController gpio = GpioController.GetDefault();		        GpioPin TriggerPin;	        GpioPin EchoPin;		        //Contructor	        public UcSensor(int TriggerPin, int EchoPin)	        {	            //Setting up gpio pin's	            this.TriggerPin = gpio.OpenPin(TriggerPin);	            this.EchoPin = gpio.OpenPin(EchoPin);		            this.TriggerPin.SetDriveMode(GpioPinDriveMode.Output);	            this.EchoPin.SetDriveMode(GpioPinDriveMode.Input);		            this.TriggerPin.Write(GpioPinValue.Low);	        }		        public double GetDistance()	        {	            ManualResetEvent mre = new ManualResetEvent(false);	            mre.WaitOne(500);		            //Send pulse	            this.TriggerPin.Write(GpioPinValue.High);	            mre.WaitOne(TimeSpan.FromMilliseconds(0.01));	            this.TriggerPin.Write(GpioPinValue.Low);		            //Recieve pusle	            while (this.EchoPin.Read() == GpioPinValue.Low)	            {	            }	            DateTime start = DateTime.Now;		            while (this.EchoPin.Read() == GpioPinValue.High)	            {	            }	            DateTime stop = DateTime.Now;		            //Calculating distance	            double timeBetween = (stop - start).TotalSeconds;	            double distance = timeBetween * 17000;		            return distance;	        }		    }	}	</code></pre>		<p>I've also written a script in python to read the values from the ultrasonic sensor and then it works but in c# I can't get it working.</p>		<p>At the bottom you can find the debug log:</p>		<blockquote>	  <p>'BACKGROUNDTASKHOST.EXE' (CoreCLR: DefaultDomain): Loaded 'C:\Program Files\WindowsApps\Microsoft.NET.CoreRuntime.1.0_1.0.22816.1_arm__8wekyb3d8bbwe\mscorlib.ni.dll'. Skipped loading symbols. Module is optimized and the debugger option 'Just My Code' is enabled.	      'BACKGROUNDTASKHOST.EXE' (CoreCLR: CoreCLR_UAP_Domain): Loaded 'C:\Users\DefaultAccount\AppData\Local\DevelopmentFiles\RaspiCarVS.Debug_ARM.chris\RaspiCar.winmd'. Symbols loaded.	      'BACKGROUNDTASKHOST.EXE' (CoreCLR: CoreCLR_UAP_Domain): Loaded 'C:\Users\DefaultAccount\AppData\Local\DevelopmentFiles\RaspiCarVS.Debug_ARM.chris\System.Runtime.dll'. Skipped loading symbols. Module is optimized and the debugger option 'Just My Code' is enabled.	      'BACKGROUNDTASKHOST.EXE' (CoreCLR: CoreCLR_UAP_Domain): Loaded 'C:\Users\DefaultAccount\AppData\Local\DevelopmentFiles\RaspiCarVS.Debug_ARM.chris\WinMetadata\Windows.winmd'. Module was built without symbols.	      'BACKGROUNDTASKHOST.EXE' (CoreCLR: CoreCLR_UAP_Domain): Loaded 'C:\Users\DefaultAccount\AppData\Local\DevelopmentFiles\RaspiCarVS.Debug_ARM.chris\System.Runtime.InteropServices.WindowsRuntime.dll'. Module was built without symbols.	      'BACKGROUNDTASKHOST.EXE' (CoreCLR: CoreCLR_UAP_Domain): Loaded 'C:\Users\DefaultAccount\AppData\Local\DevelopmentFiles\RaspiCarVS.Debug_ARM.chris\System.Threading.dll'. Module was built without symbols.	      'BACKGROUNDTASKHOST.EXE' (CoreCLR: CoreCLR_UAP_Domain): Loaded 'C:\Users\DefaultAccount\AppData\Local\DevelopmentFiles\RaspiCarVS.Debug_ARM.chris\System.Diagnostics.Debug.dll'. Skipped loading symbols. Module is optimized and the debugger option 'Just My Code' is enabled.	      'BACKGROUNDTASKHOST.EXE' (CoreCLR: CoreCLR_UAP_Domain): Loaded 'C:\Users\DefaultAccount\AppData\Local\DevelopmentFiles\RaspiCarVS.Debug_ARM.chris\System.Runtime.WindowsRuntime.dll'. Skipped loading symbols. Module is optimized and the debugger option 'Just My Code' is enabled.	      Distance: 265.7457	      Distance: 0	      Distance: 0	      Distance: 0	      The program '[2508] BACKGROUNDTASKHOST.EXE' has exited with code 0 (0x0).</p>	</blockquote>	"
30124861,48359650,30124861,3,0,Fri May 08 13:27:00 EDT 2015,4798077,"The DateTime may not have the resolution you need, I haven't played around with the W10 IOT, so I don't know whats available (like Stopwatch). Do you have an o-scope you can see what the sensor is actually doing?"
30124861,48359671,30124861,3,0,Fri May 08 13:28:00 EDT 2015,791010,"`DateTime` isn't usually a good way of measuring time - it may be the resolution of this that's causing you problems.  Consider using the `StopWatch` class instead."
30124861,30125521,30124861,2,6,Fri May 08 13:49:00 EDT 2015,4879053,"<p>Thanks for the reactions. DateTime was the problem i've now used the stopwatch class and now it works. Thanks a lot!</p>		<p>The working class:</p>		<pre><code>using System;	using System.Collections.Generic;	using System.Linq;	using System.Text;	using System.Threading;	using System.Threading.Tasks;	using System.Diagnostics;	using Windows.Devices.Gpio;		namespace RaspberryPi	{	    class UcSensor	    {	        GpioController gpio = GpioController.GetDefault();		        GpioPin TriggerPin;	        GpioPin EchoPin;		        public UcSensor(int TriggerPin, int EchoPin)	        {	            this.TriggerPin = gpio.OpenPin(TriggerPin);	            this.EchoPin = gpio.OpenPin(EchoPin);		            this.TriggerPin.SetDriveMode(GpioPinDriveMode.Output);	            this.EchoPin.SetDriveMode(GpioPinDriveMode.Input);		            this.TriggerPin.Write(GpioPinValue.Low);	        }		        public double GetDistance()	        {	            ManualResetEvent mre = new ManualResetEvent(false);	            mre.WaitOne(500);	            Stopwatch pulseLength = new Stopwatch();		            //Send pulse	            this.TriggerPin.Write(GpioPinValue.High);	            mre.WaitOne(TimeSpan.FromMilliseconds(0.01));	            this.TriggerPin.Write(GpioPinValue.Low);		            //Recieve pusle	            while (this.EchoPin.Read() == GpioPinValue.Low)	            {	            }	            pulseLength.Start();			            while (this.EchoPin.Read() == GpioPinValue.High)	            {	            }	            pulseLength.Stop();		            //Calculating distance	            TimeSpan timeBetween = pulseLength.Elapsed;	            Debug.WriteLine(timeBetween.ToString());	            double distance = timeBetween.TotalSeconds * 17000;		            return distance;	        }		    }	}	</code></pre>	"
30124861,52778614,30125521,3,0,Tue Sep 08 12:51:00 EDT 2015,589577,"TimeSpan.FromTicks is independent of processor speed, so 1 Tick = 100 Nanoseconds. Therefore 10 microseconds is: TimeSpan.FromTicks(100); https://msdn.microsoft.com/en-us/library/system.timespan.fromticks(v=vs.110).aspx Still get back semi-random numbers from the distance sensor though."
30124861,52780429,30125521,3,0,Tue Sep 08 13:32:00 EDT 2015,589577,"I got it working a bit differently, I may post the code here as well, let me know if interested."
30124861,52682412,30125521,3,0,Fri Sep 04 21:58:00 EDT 2015,589577,"Does this work for you? Doesn't work for me and TimeSpan.FromMilliseconds(0.01) returns 0 MS. If you do TimeSpan.FromTicks(10000 / NanosecondsPerTick) it currently gives me 19.2microseconds"
30124861,53161177,30125521,3,0,Fri Sep 18 17:02:00 EDT 2015,589577,"For anyone in the future I bought 3 of these sensors, the first one would only give me relevant data a third of the time."
30124861,33883871,30124861,2,1,Tue Nov 24 01:22:00 EST 2015,3005995,"<p>There is a better solution as the currently proposed answer will occasionally lock while getting the distance.  The improved version of the code, which times out after 100 milliseconds (hardcoded).  You can return a null or 0.0.  Use double? if you want to return null.</p>		<pre><code>using System;	using System.Collections.Generic;	using System.Diagnostics;	using System.Linq;	using System.Text;	using System.Threading;	using System.Threading.Tasks;	using Windows.Devices.Gpio;		namespace MTP.IoT.Devices.Sensors	{	public class HCSR04	{	    private GpioPin triggerPin { get; set; }	    private GpioPin echoPin { get; set; }	    private Stopwatch timeWatcher;		    public HCSR04(int triggerPin, int echoPin)	    {	        GpioController controller = GpioController.GetDefault();	        timeWatcher = new Stopwatch();	        //initialize trigger pin.	        this.triggerPin = controller.OpenPin(triggerPin);	        this.triggerPin.SetDriveMode(GpioPinDriveMode.Output);	        this.triggerPin.Write(GpioPinValue.Low);	        //initialize echo pin.	        this.echoPin = controller.OpenPin(echoPin);	        this.echoPin.SetDriveMode(GpioPinDriveMode.Input);	    }		    public double GetDistance()	    {	        ManualResetEvent mre = new ManualResetEvent(false);	        mre.WaitOne(500);	        timeWatcher.Reset();	        //Send pulse	        this.triggerPin.Write(GpioPinValue.High);	        mre.WaitOne(TimeSpan.FromMilliseconds(0.01));	        this.triggerPin.Write(GpioPinValue.Low);	        return this.PulseIn(echoPin, GpioPinValue.High);           	    }		    private double PulseIn(GpioPin echoPin, GpioPinValue value)	    {	        var t = Task.Run(() =&gt;	        {	            //Recieve pusle	            while (this.echoPin.Read() != value)	            {	            }	            timeWatcher.Start();		            while (this.echoPin.Read() == value)	            {	            }	            timeWatcher.Stop();	            //Calculating distance	            double distance = timeWatcher.Elapsed.TotalSeconds * 17000;	            return distance;	        });	        bool didComplete = t.Wait(TimeSpan.FromMilliseconds(100));	        if(didComplete)	        {	            return t.Result;	        }	        else	        {	            return 0.0;                	        }	    }		}	}	</code></pre>	"
30124861,55564366,33883871,3,0,Tue Nov 24 18:18:00 EST 2015,589577,"Looks good, I got my version down to running every 30ms and timeout after 50ms."
30124861,64821219,33883871,3,0,Tue Aug 02 14:01:00 EDT 2016,5471259,"I used the same code, it's working fine but when I kept object near to this sensor constantly with out moving  it does not return same value for next time it will always give 0.0 value."
