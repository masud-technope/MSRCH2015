thread_ID, Id, ParentId, PostType, Score, CreationDate, OwnerID, Body
44277880,44277880,null,1,1,Wed May 31 07:04:00 EDT 2017,6463265,"<p>Is it possible and if so how to archive it that one application using libmosquitto get messages from one broker and publish it to another?</p>		<p><img src="https://i.stack.imgur.com/9Wl1N.png" alt="Schematics"></p>		<p>Its pretty simple to just change topic in mosquito_publish function, but set of broker takes place in </p>		<pre><code>mosquitto_connect(mosq, "localhost",1883 , 60); 	</code></pre>		<p>Running mosquitto_connet second time	e.g.</p>		<pre><code> mosquitto_connect(mosq, "mqtt.example.io",1883 , 60); 	</code></pre>		<p>ends up connecting to last one.</p>		<p>I tried to create two mosquitto structs but I dont know how to inform second one about message form subbed channel in order to get info from it, change it and push to proper broker. </p>	"
44277880,75568320,44277880,3,0,Wed May 31 09:25:00 EDT 2017,504554,"of course the other question here is why you can't just bridge the 2 brokers, instead of using a client in the middle?"
44277880,75568510,44277880,3,0,Wed May 31 09:29:00 EDT 2017,6463265,"I have to modify content of messages to publish based on messages from first one broker."
44277880,44278715,44277880,2,1,Wed May 31 07:47:00 EDT 2017,504554,"<p>Yes,</p>		<p>You need two totally separate instances of client. Which means two separate instances the <code>mosquitto</code> structure returned by the <code>mosquitto_new()</code> function. One for each broker.</p>		<p>At the moment you are re-using the same structure so it is only holding the details of the last call to <code>mosquitto_connect()</code></p>	"
44277880,44279585,44277880,2,2,Wed May 31 08:31:00 EDT 2017,429431,"<p>Something like this should do the job (I've not tested it though). You'll have to add error checking.</p>		<pre><code>#include &lt;stdio.h&gt;	#include &lt;mosquitto.h&gt;			void on_connect1(struct mosquitto *mosq, void *obj, int result)	{	    int rc = MOSQ_ERR_SUCCESS;		    if(!result){	        mosquitto_subscribe(mosq, NULL, "/v1/topic1", 0);	    }else{	        fprintf(stderr, "%s\n", mosquitto_connack_string(result));	    }	}		void on_message1(struct mosquitto *mosq, void *obj, const struct mosquitto_message *message)	{	    struct mosquitto *mosq2 = (struct mosquitto *)obj;		    mosquitto_publish(mosq, NULL, "/v1/topic2", message-&gt;payloadlen, message-&gt;payload, message-&gt;qos, message-&gt;retain);	}		int main(int argc, char *argv[])	{	    struct mosquitto *mosq1, *mosq2;		    mosquitto_lib_init();		    mosq2 = mosquitto_new(NULL, true, NULL);	    mosq1 = mosquitto_new(NULL, true, mosq2);		    mosquitto_connect_callback_set(mosq1, on_connect1);	    mosquitto_message_callback_set(mosq1, on_message1);		    mosquitto_connect(mosq2, "mqtt.example.io", 1883, 60);	    mosquitto_connect(mosq1, "localhost", 1883, 60);		    mosquitto_loop_start(mosq2);	    mosquitto_loop_forever(mosq1, -1, 1);		    mosquitto_destroy(mosq1);	    mosquitto_destroy(mosq2);		    mosquitto_lib_cleanup();		    return 0;	}	</code></pre>	"
44277880,75567753,44279585,3,0,Wed May 31 09:12:00 EDT 2017,6463265,"Thanks, I already managed that problem, but thanks to your answer I know  how to use third mosquitto_new arg."
