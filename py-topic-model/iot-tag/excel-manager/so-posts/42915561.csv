thread_ID, Id, ParentId, PostType, Score, CreationDate, OwnerID, Body
42915561,42915561,null,1,2,Mon Mar 20 23:04:00 EDT 2017,7742489,"<p>The situation: an industrial machine is connected to a Raspberry using a serial port (through USB). It is controlled by strings sent to the serial port.</p>		<p>The project: create an app for Raspberry controlling such machine.</p>		<p>The tools: Visual Studio 2015 on a PC connected to the Raspberry through Ethernet, where the app is being written in C# for Win 10 UWP and deployed to the Raspberry when built for ARM.</p>		<p>The problem: since the machine can take up to some minutes to execute the commands in the real world, it would be nice have a feedback on the Raspberry monitor about the machine current state (besides, obviously, the visual and acoustic clues the operator can have while operating).</p>		<p>There are several examples of SerialDevice code in the internet. I got my code from them. Creating the port:</p>		<pre><code>serialPort = await SerialDevice.FromIdAsync(Id);	serialPort.WriteTimeout = TimeSpan.FromMilliseconds(1000);	serialPort.ReadTimeout = TimeSpan.FromMilliseconds(2000);	serialPort.BaudRate = 9600;	serialPort.Parity = SerialParity.None;	serialPort.StopBits = SerialStopBitCount.One;	serialPort.DataBits = 8;	// serialPort.Handshake = SerialHandshake.None;	// serialPort.Handshake = SerialHandshake.RequestToSend;	serialPort.Handshake = SerialHandshake.RequestToSendXOnXOff;	</code></pre>		<p>And sending commands:</p>		<pre><code>public async Task WriteAsync(string cmdText)	{	    Task&lt;int&gt; storeAsyncTask;	    dataWriteObject = new DataWriter(serialPort.OutputStream);	    dataWriteObject.WriteString(cmdText);	    storeAsyncTask = dataWriteObject.StoreAsync().AsTask();	    int bytesWritten = await storeAsyncTask;	}	</code></pre>		<p>I'm not interested right now in reading data sent from the port. The machine doesn't do that. Now, the PC desktop program, whose this app is a simplified porting, has at some point the code to check the state:</p>		<pre><code>bool CTS = serialPort.ClearToSendState;	bool DSR = serialPort.DataSetReadyState;		if (CTS)	    if (DSR)                      // true true	        state = EnumStates.ERROR;	    else                          // true false	        state = EnumStates.READY;	else	    if (DSR)                      // false true	        state = EnumStates.BUSY;	    else                          // false false	        state = EnumStates.DISCONNECTED;	</code></pre>		<p>The problem is those states never change from false in the Win 10 app, while everything works for the PC version. There is only an unanswered old question about this, and it seems no one cares about the state of the port when creating examples. I tried every type of control flow flag, with no success. I tried to use various stuff the Intellisense of Visual Studio offers, but nothing good came out. Forcing the value serialPort.IsRequestToSendEnabled to true causes an Exception of invalid value.</p>		<p>Any tip is greatly appreciated.</p>	"
42915561,72942675,42915561,3,0,Tue Mar 21 09:09:00 EDT 2017,7742489,"@RitaHan-MSFT It is not the same app; the PC version is for x86, instead for Raspberry it is for ARM. The PC program uses classic NET framework while the new app is using the UWP. No, the Pin Changed event is not fired."
42915561,72938562,42915561,3,0,Tue Mar 21 06:59:00 EDT 2017,6601582,"Do you mean the same app works on PC but not on Raspberry Pi? Can you receive serialPort.PinChanged events?"
42915561,52484672,42915561,2,0,Mon Sep 24 17:42:00 EDT 2018,1742458,"<p>I'm seeing the exact same behavior for serial ports under Windows 10 UWP. <code>SerialPort.DataSetReadyState</code> never changes.  The only workaround I've found is to hook the SerialPinChange event, and capture DSR state changes there.  Unfortunately, this doesn't give you the value, only the fact that it changed, but it might be possible to track the value given a known initial state.</p>		<pre><code>        AddHandler SerialPort.PinChanged,	        Sub(sender As Object, e As PinChangedEventArgs)	            Select Case e.PinChange	                Case SerialPinChange.DataSetReady	                    DSRchanged = True	            End Select	        End Sub	</code></pre>	"
