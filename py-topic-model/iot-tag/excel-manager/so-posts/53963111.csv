thread_ID, Id, ParentId, PostType, Score, CreationDate, OwnerID, Body
53963111,53963111,null,1,1,Fri Dec 28 18:54:00 EST 2018,10844173,"<p>I am trying to make a simple hardware to turn off and on a lamp in my room remotely using a database I have. For this i wanted to use ESP8266 in the ESP-01 board.</p>		<p>For workbench testing I have a 2 amps 5v source. I used a 3.3V regulator (LD33V) to turn the ESP-01 on and managed to make a connection with a database where I have the "on/off flag". Works like a charm with a LED and a 330 ohms resistor.</p>		<p>Thing is after a few moments (I have not measured, but only a few minutes), the board turns off completely. I realised it could be an excessive current drain, so I uploaded the same code to a NodeMCU board and powered it with a cellphone charger, turning on and off the in-board LED. The same happened.</p>		<p>I am guessing it can be a software issue, because it doesn't seem to be hardware after these tests. Maybe I need to set any virtual flag, or something.</p>		<p>The ESP-01 has the following in the pins:	VCC: 3.3V from the regulator<br>	GND: 0V from the regulator<br>	GPI02: 330 ohms resistor and the LED<br>	GPIO0: floating (yes, I do ground it when programming)<br>	TX / RX: floating<br>	RST: Vcc<br>	CH_PD (enable): Vcc</p>		<pre><code>#include &lt;ESP8266WiFi.h&gt;	#include &lt;WiFiClient.h&gt;	#include &lt;ESP8266WebServer.h&gt;	#include &lt;ESP8266mDNS.h&gt;		#include &lt;MySQL_Connection.h&gt;	#include &lt;MySQL_Cursor.h&gt;		#define led 2 //pin of the external led		// Inicialização do WiFi	const char* ssid = "xxxxxx";	const char* pass = "xxxxxx";	byte mac[] = { 0xDE, 0xAD, 0xBE, 0xEF, 0xFE, 0xED }; // made-up MAC		WiFiClient client;		// Inicialização do MySQL	MySQL_Connection conn((Client *)&amp;client);	// Create an instance of the cursor passing in the connection	MySQL_Cursor cur = MySQL_Cursor(&amp;conn);	IPAddress server_addr(XXX, XXX , XXX, XXX);          // MySQL server IP	char user[] = "xxxxxx";           // MySQL user	char password[] = "xxxxxx";       // MySQL password	char BANCODEDADOS[] = "USE xxxxxx";		void toggle_lamp(void){		  // FAZ UM SELECT SIMPLES	  char query[] = "SELECT STATUS FROM devices WHERE ID = 1";	  MySQL_Cursor *cur_mem = new MySQL_Cursor(&amp;conn);	  cur_mem-&gt;execute(query);	  Serial.println("");	  Serial.print("Executando query: ");	  Serial.println(query);		  // Fetch the columns (required) but we don't use them.	  column_names *columns = cur_mem-&gt;get_columns();		  // Read the row (we are only expecting the one)	  row_values *row = NULL;	  //char* result = NULL;	  int lamp_status;		  do {	    row = cur_mem-&gt;get_next_row();	    if (row != NULL) {	     // result = row-&gt;values[0];	     lamp_status = atoi(row-&gt;values[0]);		    }	  } while (row != NULL);		  // Deleting the cursor also frees up memory used	  delete cur_mem;		  // USA O RESULTADO PARA ACENDER UM LED	  //int lamp_status = atoi(result);	  //Serial.println(result);	  Serial.println(lamp_status);	  if(lamp_status == 1){	    digitalWrite(led,HIGH); 	  }	  else{	    lamp_status = 0;	    digitalWrite(led,LOW);		  }		}		void setup(void){		  // Define a saída como output	  pinMode(led,OUTPUT);		  // Inicializa a porta Serial	  Serial.begin(115200);	  Serial.println("");		  // Inicializa a conexão WiFi	  WiFi.mode(WIFI_STA);	  WiFi.begin(ssid, pass);		  // Wait for connection	  while (WiFi.status() != WL_CONNECTED) {	    delay(500);	    Serial.print(".");	  }	  Serial.println("");	  Serial.print("Connected to ");	  Serial.println(ssid);	  Serial.print("IP address: ");	  Serial.println(WiFi.localIP());		  // REALIZA A CONEXÃO COM O MYSQL	  if (conn.connect(server_addr, 3306, user, password)) 	   {	      delay(1000);		      // Initiate the query class instance	      MySQL_Cursor *cur_mem = new MySQL_Cursor(&amp;conn);	      cur_mem-&gt;execute(BANCODEDADOS);		      Serial.println("");	      Serial.println("Conectado ao MySQL");	      Serial.print("Usuario:");	      Serial.println(user);	   }	   else	   {	      Serial.println("A conexão falhou");	      conn.close();	   }		} // end setup()		void loop(void){		  toggle_lamp();	  delay(1250);		}	</code></pre>	"
53963111,94803297,53963111,3,0,Mon Dec 31 01:55:00 EST 2018,2670348,"Have you tried connecting a large (say, 470µF electrolytic but the exact value doesn't matter a lot) capacitor between 3.3V and GND on the ESP? That might stabilize power enough for when it's not getting power from the PC. (just in case you're not used to them, electrolytic capacitors are polarized, so if you use one make sure the NEGATIVE terminal goes to GND)"
53963111,94853583,53963111,3,0,Wed Jan 02 14:59:00 EST 2019,10844173,"Hey John, Thanks for the help. I found the issue, it was a defective capacitor on the power source, but there was also a bug on the code. Since it never actually closed the MySQL connection, sometimes the connection would fall and it couldn't restablish because this was not on the loop. I added a function to start the connection every loop and close it after the queries."
53963111,94778949,53963111,3,0,Sat Dec 29 15:11:00 EST 2018,10844173,"To get it I tried using the ESP plugged to the PC (and powered by it as well), but I couldn't get the error to happen. Also, to see if there was a big current drain, I tried letting it ON powered by the supply and the regulator without powering the LED. The error happened"
53963111,94767135,53963111,3,0,Fri Dec 28 21:55:00 EST 2018,2670348,"It's possible that it's a software problem rather than power.		Have you tried monitoring the serial output when this happens? You may need to set the serial speed on your terminal program to 74880 - that's the speed that the boot loader will output exception and booting information. If you haven't tried monitoring the serial output, I'd temporarily change the program to use 74880 instead of 115200 (just so you can see its debugging output as well as the boot loader output) and run a terminal program with it to see if it shows you anything interesting."
