thread_ID, Id, ParentId, PostType, Score, CreationDate, OwnerID, Body
51795401,51795401,null,1,0,Sat Aug 11 00:19:00 EDT 2018,1266055,"<p>I have trouble understanding how to write asynchronous sending/receiving in Contiki. Suppose I am using the xmac layer, or any layer that is based on <code>packetbuf</code>. I am sending a message, or a list of packets. I start sending a message using <code>void(*send)(mac_callback_t sent_callback, void *ptr)</code>. This takes the message that is in the <code>global</code> buffer <code>packetbuf</code>, and tries to send it. Meanwhile while the send is pending (for example waiting for the other device to wake up or acknowledge the transmission), the device receives a packet from a third device.</p>		<p>Will this packet overwrite the packet waiting to be sent that is in the <code>packetbuf</code>? How should I handle this? </p>		<p>I thought that maybe you can't be trying to send a packets and listen for incoming packets, but then there is an obvious deadlock: 2 devices sending messages to each other at the same time. </p>		<p>I am porting a higher-level routing layer to Contiki. This is the second OS I am porting it to, but the previous OS didn't use a single buffer for both incoming and outgoing packets.</p>	"
51795401,51799981,51795401,2,1,Sat Aug 11 13:05:00 EDT 2018,2435820,"<p>The <code>packetbuf</code> is a space for short-term data and metadata storage. It's not meant to be used by code that blocks longer than a few timer ticks. If you can't send the packet immediately from your <code>send()</code> function, do not block there! You need to schedule a timer callback in the future and return <code>MAC_TX_DEFERRED</code>. To store packet data in between invocations of <code>send()</code>, use the <code>queuebuf</code> module.</p>		<p>The fact that there is a single <code>packetbuf</code> for both reception and transmission is not a problem, since the radio is a half-duplex communication medium anyway. It cannot both send and receive data at the same time. Similarly, a packet that is received is first stored in the radio chip's memory: it does not overwrite the <code>packetbuf</code>. Contiki interrupt handlers similarly never write to <code>packetbuf</code> directly. They simply wake up the rx handler process, which takes the packet from the radio chip and puts it in the <code>packetbuf</code>. Since one process cannot unexpectedly interrupt another, this operation is safe: a processing wanting to send a packet cannot interrupt the process reading another packet.</p>		<p>To summarize, the recommendations are:</p>		<ol>	<li>Do not block in Contiki process context (this is a generic rule when programming this OS, not specific to this question).</li>	<li>Do not the expect the contents of <code>packetbuf</code> are going to be saved across yielding the execution in Contiki process context. Serialize to a <code>queuebuf</code> if you need this.</li>	<li>Do not access the <code>packetbuf</code> from interrupt context.</li>	</ol>	"
