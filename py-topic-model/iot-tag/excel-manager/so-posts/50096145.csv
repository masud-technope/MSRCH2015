thread_ID, Id, ParentId, PostType, Score, CreationDate, OwnerID, Body
50096145,50096145,null,1,0,Mon Apr 30 07:51:00 EDT 2018,5698825,"<p>Obviously my current approach isn't how it should be done as it isn't working.	My project is software that plays audio based on a schedule received from a web server.</p>		<p>I have three threads, one thread is a listener which listens on a web socket for notifications about whether there is a new schedule we should download. This thread starts another thread which is a "Schedule Downloader", this makes http requests and downloads files. When it starts it checks the schedule and downloads files, after it does this once there is a flag set to false with a while loop on flag, so the thread is still running but not doing anything until that flag is changed. This flag is <code>boolean newSchedule</code>. When it is finished it starts a thread to play the music</p>		<p>The way I currently have it setup is that my method <code>onMessage()</code> in my listener <code>MyTopicClass</code> changes a flag in the schedule downloader to start downloading a schedule again. I can see this works from debugging. Receiving a notification calls the <code>getScheduleAgain()</code> method in my <code>ScheduleDownloader</code> class which changes the flag and my code starts checking/downloading schedules again. I can see this works correctly. What doesn't work as I intend is I am trying to set a flag in my <code>AudioPlayer</code> so it finishes so I can start a new one with the new schedule. What is going wrong is when I call the <code>setStopFlagToTrue()</code> on my audio player inside my <code>getScheduleAgain()</code> method, according to the debugger the audioplayer is <code>null</code>?</p>		<p>So my workflow is <code>MyTopic</code> within my <code>IotClient</code> listener thread when it receives a notification, it calls <code>onMessage()</code> in my <code>myTopic</code> which calls my <code>getScheduleAgain()</code> in my <code>Scheduledownloader</code>. This all works as intended except my <code>getScheduleAgain()</code> method calls a <code>setStopFlagToTrue</code> on my audioplayer thread but according to the debugger it is <code>null</code>?</p>		<p>Main.java</p>		<pre><code>      IotClient client = new IotClient("username");	  client.start();	</code></pre>		<p>IotClient</p>		<pre><code>     public class IotClient extends Thread {	   Thread t;	   String username;	   ScheduleDownloader downloader;	public IotClient(String username)  {	    this.username = username;	    downloader = new ScheduleDownloader("username,","password2","thread");	}	   public void run(){	    this.currentThread().setPriority(Thread.MAX_PRIORITY);	Thread.currentThread().setPriority(Thread.MAX_PRIORITY);	String clientEndpoint = "removed my end point here";       	// replace &lt;prefix&gt; and &lt;region&gt; with your own	String clientId = "1";                              // replace with your own client ID. Use unique client IDs for concurrent connections.		// AWS IAM credentials could be retrieved from AWS Cognito, STS, or other secure sources	AWSIotMqttClient client = new AWSIotMqttClient(clientEndpoint, clientId, "removed credentials ", "removed credentials");		// optional parameters can be set before connect()	try {	    client.connect();	} catch (AWSIotException e) {	    e.printStackTrace();	}	AWSIotQos qos = AWSIotQos.QOS0;	new ScheduleDownloader("dunnesdrogheda","password2","thread").start();	AWSIotTopic topic = new MyTopic("schedule/"+ username, qos,downloader);		try {	    client.subscribe(topic, true);	} catch (AWSIotException e) {	    e.printStackTrace();	}		while(true){	    try {	        Thread.sleep(1000);	    } catch (InterruptedException e) {	        e.printStackTrace();	    }	}	}	public void start(){	if (t == null) {	    t = new Thread (this, "IotClientThread");	    t.start ();	}	}			  }	</code></pre>		<p>MyTopic</p>		<pre><code>public class MyTopic extends AWSIotTopic {	ScheduleDownloader downloader;		public MyTopic(String topic, AWSIotQos qos, ScheduleDownloader downloader) {		    super(topic, qos);	    this.downloader = downloader;	}		@Override	public void onMessage(AWSIotMessage message) {	    System.out.println("Message recieved from topic: "+ message.getStringPayload());	    try {	        downloader.getScheduleAgain();	    } catch (InterruptedException e) {	        e.printStackTrace();	    }		}	}	</code></pre>		<p>ScheduleDownloader, removed non-relevant util methods for downloading files</p>		<pre><code>public class ScheduleDownloader extends Thread {	private Thread t;	private String threadName;		    String username;	    String password;	     volatile boolean newSchedule = true;	     AudioPlayer audioPlayer;		    public ScheduleDownloader(String username,String password,String threadName){	        this.username = username;	        this.password = password;	        this.threadName= threadName;	    }	    public void startPlayerThread(){		    }	    public void startAudioPlayer(Schedule schedule) throws UnsupportedAudioFileException, IOException, LineUnavailableException {	        audioPlayer = new AudioPlayer(schedule);	        audioPlayer.start();	    }	 public void start () {	    System.out.println("Starting " +  threadName );	    if (t == null) {	        t = new Thread (this, threadName);	        t.start ();	    }}	public synchronized void run() {	    try {		  while(true){	Thread.sleep(1000);	        while(newSchedule == true) {	            Schedule schedule = null;	            while (schedule == null) {	                System.out.println("Searching for schedule");	                schedule = getTodaysSchedule();	            }	            System.out.println("Schedule Found");	            boolean result = false;	            while (result == false) {	                result = downloadFiles(schedule);	            }	            System.out.println("Files Downloaded");	            startAudioPlayer(schedule);		            newSchedule = false;		         }	       }	    } catch (IOException e) {	        e.printStackTrace();	    }  catch (UnsupportedAudioFileException e) {	        e.printStackTrace();	    } catch (LineUnavailableException e) {	        e.printStackTrace();	    } catch (InterruptedException e) {	        e.printStackTrace();	    }	}	public void getScheduleAgain() throws InterruptedException {	        this.audioPlayer.setStopFlagToTrue();	        Thread.sleep(4000);	        newSchedule = true;	}	</code></pre>		<p>AudioDownloader, the <code>checkShouldWePlayAnAdvertisement</code> is the method that loops until the finish flag is supposed to be set to true</p>		<pre><code>public class AudioPlayer extends Thread {	Long currentFrameMusic;	Long currentFrameAdvertisement;	Clip clipMusic;	Clip clipAdvertisement;	private Thread t;	private volatile boolean stopFlag = false;		// current status of clip	String statusMusic;	String statusAdvertisement;		static AudioInputStream musicInputStream;	static AudioInputStream advertisementInputStream;	static String filePath;	Schedule schedule;		// constructor to initialize streams and clip	public AudioPlayer(Schedule schedule)	        throws UnsupportedAudioFileException,	        IOException, LineUnavailableException	{	    //setup audio stream for music first	    // create AudioInputStream object	this.schedule = schedule;	    appendMusicFiles(schedule);		    // create clip reference	    clipMusic = AudioSystem.getClip();		    // open audioInputStream to the clip	    clipMusic.open(musicInputStream);		    clipMusic.loop(Clip.LOOP_CONTINUOUSLY);	}		public void run(){	    playMusic();	    try {	        checkShouldWePlayAnAdvertisement();	    } catch (IOException e) {	        e.printStackTrace();	    } catch (UnsupportedAudioFileException e) {	        e.printStackTrace();	    } catch (LineUnavailableException e) {	        e.printStackTrace();	    } catch (InterruptedException e) {	        e.printStackTrace();	    }		    try {	        checkShouldWePlayAnAdvertisement();	    } catch (IOException e) {	        e.printStackTrace();	    } catch (UnsupportedAudioFileException e) {	        e.printStackTrace();	    } catch (LineUnavailableException e) {	        e.printStackTrace();	    } catch (InterruptedException e) {	        e.printStackTrace();	    }	    try {	        checkShouldWePlayAnAdvertisement();	    } catch (IOException e) {	        e.printStackTrace();	    } catch (UnsupportedAudioFileException e) {	        e.printStackTrace();	    } catch (LineUnavailableException e) {	        e.printStackTrace();	    } catch (InterruptedException e) {	        e.printStackTrace();	    }	}	public void start(){	    t = new Thread (this, "AudioPlayerThread");	    t.start ();	}	public void checkShouldWePlayAnAdvertisement() throws IOException, UnsupportedAudioFileException, LineUnavailableException, InterruptedException {	    ArrayList&lt;String&gt; playedAtTimes = new ArrayList&lt;&gt;();	    ArrayList&lt;Advertisement&gt; advertisementsToBePlayed = new ArrayList&lt;&gt;();	    boolean found;	    //played at times is used to keep track of what time we played advertisements	    //so when the loop reruns and the time hasnt changed it doesnt play it again	    while(stopFlag ==false){	        Thread.sleep(1000);	        found = false;	        ZonedDateTime zdt = ZonedDateTime.now();	        String timeHHMM =zdt.toString().substring(11,16);	        for(int i =0;i&lt;schedule.getAdvertisementScheduleItems().size();i++){	            if(schedule.getAdvertisementScheduleItems().get(i).getTimes().contains(timeHHMM)){	                //this item should be played now	                if(playedAtTimes.contains(timeHHMM)){	                    //we already played this,but the time hasnt changed when the loop ran again	                }else{	                    advertisementsToBePlayed.add(schedule.getAdvertisementScheduleItems().get(i).getAdvertisement());	                    found = true;	                }	            }	        }	        if(found== true) {	            playedAtTimes.add(timeHHMM);	            appendAdvertisementFiles(advertisementsToBePlayed);	            pauseMusic();	            playAdvertisements();	            stopAdvertisement();		            resumeAudioMusic();	        }	    }		    System.out.println("audio player is closing");	 clipMusic.close();	}	public synchronized void setStopFlagToTrue(){	    stopFlag = true;	}	</code></pre>	"
50096145,87208696,50096145,3,0,Mon Apr 30 07:59:00 EDT 2018,466862,"Have you tried making the `audioPlayer` field in `ScheduleDownloader` volatile? The other threads may never see the field other than `null`."
50096145,87208891,50096145,3,0,Mon Apr 30 08:07:00 EDT 2018,5698825,"Setting audioPlayer in ScheduleDownloader to volatile still results in a null audioplayer when this.audioPlayer.setStopFlagToTrue(); is called in getScheduleAgain()"
50096145,87209562,50096145,3,0,Mon Apr 30 08:31:00 EDT 2018,466862,"I think you haven't accounted for the first occurrence when no audio player has been initialized yet. To be honest, I think you need to reduce your code further (see [mcve]), because I feel there is too much for us to be used as human debuggers."
50096145,50096781,50096145,2,0,Mon Apr 30 08:35:00 EDT 2018,7819424,"<p>In IotClient.java, You have created two instances of ScheduleDownloader.</p>		<pre><code>public IotClient(String username) {	        this.username = username;	        downloader = new ScheduleDownloader("username,", "password2", "thread");	    }		new ScheduleDownloader("dunnesdrogheda", "password2", "thread").start();	        AWSIotTopic topic = new MyTopic("schedule/" + username, qos, downloader); 	</code></pre>		<p>And you have passed 1 instance to AWSIotTopic  and used another to spawn the thread with while(true)</p>		<p>The ScheduleDownloader's instance from MyTopic.java doesn't even know about audioPlayer and gives nullPointerException.</p>		<p>Try using same instance of ScheduleDownloader OR define audioPlayer to public static and it should work fine.</p>	"
50096145,87210626,50096781,3,0,Mon Apr 30 09:01:00 EDT 2018,5698825,"Hmmm that seems to be the right direction,I made audioPlayer static in ScheduleDownloader and "Audio Player is closing" prints three times.newSchedule is set to true.newSchedule is set to true,however the while(newSchedule == true) while loop does not seem to re-run,I have a print statement just underneath while(newSchedule == true),it prints on the application startup,but not when I set newSchedule = true from the getScheduleAgain() method"
50096145,87211430,50096781,3,0,Mon Apr 30 09:25:00 EDT 2018,5698825,"Making newSchedule boolean static and making audioPlayer makes everything work as intended.Thanks alot man"
