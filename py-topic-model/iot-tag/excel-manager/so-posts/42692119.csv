thread_ID, Id, ParentId, PostType, Score, CreationDate, OwnerID, Body
42692119,42692119,null,1,0,Thu Mar 09 09:57:00 EST 2017,6936305,"<p>I have a XSD file with a schema that is used to define an XML interface for sending values into my application from remote clients. Right now, the XSD have, lets say for simplicity 3 elements. </p>		<p>So in order to serialize and deserialize this in C# I can use the tool xsd.exe to generate C# classes and use those classes to serialize and deserialize XML with respect to the XSD.</p>		<p>This works, but then lets say I create a new version of the XSD, with a new fourth element to enable some server-side feature available if this element is specified for new remote clients, but I still want to support the old XSD (dont want or can change the software of the old remote clients), but the new classes generated from the new XSD wont be compatible with the old XMLs from the old XSD.</p>		<p>I suppose I could read the XML's directly with XDocument or similar, but I want to have the feature of only accepting XML's that can be validated against one of the XSD (and then take server-side decision depending on which XSD version it validates against). This is due to customer relation issues.</p>		<p>What is best practice to deal with this issues?</p>	"
42692119,42693364,42692119,2,1,Thu Mar 09 10:50:00 EST 2017,3798161,"<p>If I understand you correctly then you shouldn't need to support multiple XSD's if all you are trying to do is add an additional element to the schema. Instead, if you set the 'minOccurs' value to 0 for this new element and regenerate the CS file and use this to de-serialize your objects this should allow you to de-serialize requests for when the element is present and when it is not present. You can then just evaluate if the Property on the de-serialized object is null to determine whether the new feature should be enabled or not. See example XSD below:</p>		<pre><code>&lt;?xml version="1.0" encoding="utf-8"?&gt;	&lt;xs:schema elementFormDefault="qualified" xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;	  &lt;xs:element name="ClassName" nillable="true" type="ClassName" /&gt;	  &lt;xs:complexType name="ClassName"&gt;	    &lt;xs:sequence&gt;	      &lt;xs:element minOccurs="0" maxOccurs="1" name="Property1" type="Property1Type" /&gt;	      &lt;xs:element minOccurs="0" maxOccurs="1" name="Property2" type="Property2Type" /&gt;	    &lt;/xs:sequence&gt;	  &lt;/xs:complexType&gt;	&lt;/xs:schema&gt;	</code></pre>	"
42692119,42699321,42692119,2,1,Thu Mar 09 15:32:00 EST 2017,415448,"<p>Best practice is to avoid data binding technology if your schema is likely to change, especially if you need to handle multiple variants. Basically, XML is designed for flexibility and languages like C# aren't, so if you compile C# code to reflect a specific schema then you are locking yourself in. Data binding is great if nothing changes, but if you need to handle variety and change then either use a generic approach (such as DOM) or use XML-specific processing languages such as XSLT and XQuery.</p>	"
