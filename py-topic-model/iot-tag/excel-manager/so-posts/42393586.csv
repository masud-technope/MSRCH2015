thread_ID, Id, ParentId, PostType, Score, CreationDate, OwnerID, Body
42393586,42393586,null,1,0,Wed Feb 22 13:59:00 EST 2017,6124487,"<p>I need to implement a TCP comunication between an IoT device(custom) and an Android App. 	For the Wifi device we have a <strong>Server</strong> <strong>Socket</strong>, while in Android i have an AsyncTask as a Client Socket. Both the device and the smarthone are connected to the same network. </p>		<p>Here is the Android <strong>Client</strong> <strong>Socket</strong> code for the initialization/socket-read and socket-write:</p>		<p><strong>Variables</strong>:</p>		<pre><code>static public Socket nsocket; //Network Socket	static public DataInputStream nis; //Network Input Stream	static private OutputStream nos; //Network Output Stream	</code></pre>		<p><strong>AsyncTask method doInBackgroud</strong>:</p>		<pre><code>@Override	protected Boolean doInBackground(Void... params) { //This runs on a different thread	    boolean result = false;		    try {	        //Init/Create Socket	        SocketInit(IP, PORT);		        // Socket Manager	        SocketUpdate();	    } catch (IOException e) {	        e.printStackTrace();	        Log.i("AsyncTask", "doInBackground: IOException");	        clearCmdInStack();	        MainActivity.SocketDisconnectAndNetworkTaskRestart();	        result = true;	    } catch (Exception e) {	        e.printStackTrace();	        Log.i("AsyncTask", "doInBackground: Exception");	        result = true;	    } finally {	        try {	            SocketDisconnect();	        } catch (IOException e) {	            e.printStackTrace();	        } catch (Exception e) {	            e.printStackTrace();	        }	        Log.i("AsyncTask", "doInBackground: Finished");	    }	    return result;	}	</code></pre>		<p><strong>Socket Initializzation</strong>:</p>		<pre><code>public void SocketInit(String ip, int port) throws IOException {	    InetAddress addr = InetAddress.getByName(ip);	    SocketAddress sockaddr = new InetSocketAddress(addr, port);	    nsocket = new Socket();	    nsocket.setReuseAddress(false);      	    nsocket.setTcpNoDelay(true);           	    nsocket.setKeepAlive(true);          	    nsocket.setSoTimeout(0);	    nsocket.connect(sockaddr, 0);     	    StartInputStream();	    StartOutputStream();	}	</code></pre>		<p><strong>Read from Socket</strong>:</p>		<pre><code>private void SocketUpdate() throws IOException, ClassNotFoundException {	    int read = 0;	    // If connected Start read	    if (socketSingleton.isSocketConnected()) {	        // Print "Connected!" to UI	        setPublishType(Publish.CONNECTED);	        publishProgress();		        if(mConnectingProgressDialog != null)	            mConnectingProgressDialog.dismiss();  //End Connecting Progress Dialog Bar		        //Set Communications Up	        setCommunicationsUp(true);		        Log.i("AsyncTask", "doInBackground: Socket created, streams assigned");	        Log.i("AsyncTask", "doInBackground: Waiting for inital data...");	        byte[] buffer = new byte[3];		        do{	            nis.readFully(buffer, 0, 3);	            setPublishType(Publish.READ);		            publishProgress(buffer);	        }while(!isCancelled());	        SocketDisconnect();	    }	}	</code></pre>		<p><strong>Streams init</strong>:</p>		<pre><code>public void StartInputStream() throws IOException{	    nis = new DataInputStream(nsocket.getInputStream());	}		public void StartOutputStream() throws IOException{	    nos = nsocket.getOutputStream();	}	</code></pre>		<p><strong>Read and Write methods</strong>:</p>		<pre><code>public int Read(byte[] b, int off, int len) throws  IOException{	    return nis.read(b, off, len); //This is blocking	}		public void Write(byte b[]) throws IOException {	    nos.write(b);	    nos.flush();	}		public boolean sendDataToNetwork(final String cmd)	{	    if (isSocketConnected())	    {	        Log.i("AsyncTask", "SendDataToNetwork: Writing message to socket");	        new Thread(new Runnable()	        {	            public void run()	            {	                try	                {	                    Write(cmd.getBytes());	                }	                catch (Exception e)	                {	                    e.printStackTrace();	                    Log.i("AsyncTask", "SendDataToNetwork: Message send failed. Caught an exception");	                }	            }	        }).start();		        return true;	    }		    Log.i("AsyncTask", "SendDataToNetwork: Cannot send message. Socket is closed");	    return false;	}	</code></pre>		<hr>		<p>The application is very simple, the android app sends a command(via sendDataToNetwork method) to the IoT device and the latter sends back an "ACK" Command string. </p>		<hr>		<p><strong>The problem</strong></p>		<p>The problem is that while the IoT device always receives the command, the smartphone rarely gets the ACK back. Sometimes i get something like "ACKACKACKACK". By debugging the IoT device i'm sure that it successfully sends back the ACK, so the problem lies in the InputStream read() method which doesn't retrieve the string right away. </p>		<p><em>Is there a way to empty the InputStream buffer right away, so that i get an "ACK" string back from the IoT device every time i send a command?</em></p>		<hr>		<p><strong>Update</strong></p>		<p>I've updated the socket config so that there are no more buffer limitations and i've replaced read() method with readFully. It greatly improved, but still make some mistakes. For istance one out of 2-3 times no ack is received and i get 2 ack the next turn. Is this perhaps the computational limit of the IoT device? Or is there still margin for a better approach?</p>	"
42393586,71935442,42393586,3,1,Wed Feb 22 14:19:00 EST 2017,2108972,"`nsocket.setReceiveBufferSize(20);   `. Why are you messing around with buffer sizes?"
42393586,71935522,42393586,3,1,Wed Feb 22 14:21:00 EST 2017,2108972,"If you only expect a string of three characters like ACK then use a read size of 3 in your read function."
42393586,71935840,42393586,3,0,Wed Feb 22 14:28:00 EST 2017,6124487,"@greenapps by setting nsocket.setReceiveBufferSize(20); it improved a bit the success rate. I tried calling read() with a lenght of 3 but nothing improved."
42393586,71936268,42393586,3,1,Wed Feb 22 14:38:00 EST 2017,2108972,"Let the device just send more data."
42393586,71937543,42393586,3,0,Wed Feb 22 15:06:00 EST 2017,6124487,"@greenapps I tried, if you send more ACK strings it improves just a bit. But still not a solution and you also lose the sincronism, so you won't know when that ACK was sent!"
42393586,42397668,42393586,2,1,Wed Feb 22 16:55:00 EST 2017,207421,"<blockquote>	  <p>the problem lies in the InputStream read() method which doesn't empty the buffer right away.</p>	</blockquote>		<p>I don't know what 'empty the buffer' means here, but <code>InputStream.read()</code> is specified to return as soon as even one byte has been transferred.</p>		<blockquote>	  <p>Is there a way to empty the InputStream buffer right away, so that i get an "ACK" string back from the IoT device every time i send a command?</p>	</blockquote>		<p>The actual problem is that you could be reading <em>more</em> than one ACK at a time. And there are others.</p>		<ol>	<li>If you're trying to read exactly three bytes, you should be using <code>DataInputStream.readFully()</code> with a byte array of three bytes.</li>	<li>This will also get rid of the need for the following array copy.</li>	<li>You should not mess with the socket buffer sizes except to increase them. 20 and 700 are both ridiculously small values, and will not be the actual values used, as the platform can adjust the value supplied. Your claim that this improved things isn't credible.</li>	<li>You should not spin-loop while <code>available()</code> is zero. This is literally a waste of time. Your comment says you are blocked in the following read call. You aren't, although you should be. You are spinning here. Remove this.</li>	</ol>	"
42393586,71978624,42397668,3,0,Thu Feb 23 13:10:00 EST 2017,6124487,"The code i use now is listed on my post, please tell me if is there anything wrong. And yes i can't get less than 3 bytes with readFully(), but sometimes i get nothing. When i get nothing, the next cmd sent receives two ACK one after another( readFully gets two "ACK", not "ACKACK")."
42393586,72005928,42397668,3,0,Fri Feb 24 03:45:00 EST 2017,207421,"You can't get nothing from `readFully()` unless it throws an `IOException` of some kind. Unclear what on earth you're talking about frankly. `readFully()` doesn't return a count, so the `while (read != -1)` condition is futile. The loop should terminate when `EOFException` is thrown. `isConnected()` doesn't magically become false when the peer disconnects, so testing that is also futile. I also don't know why you're using threads for a simple request/ACK protocol."
42393586,72017846,42397668,3,0,Fri Feb 24 10:58:00 EST 2017,6124487,"when i say that i get nothing from readFully(), i mean that it doesn't return at all (not that i get an empty buffer) it stays blocked when instead i shoud get an ACK! As for while(read != -1) your right, it was a left over from when i was using read(), i've updated the code."
42393586,72018049,42397668,3,0,Fri Feb 24 11:04:00 EST 2017,6124487,"As for the thread... Correct me if i'm wrong, but since read function is blocking, not using a thread would mean blocking the UI. I do however have a doubt about the usage of AsyncTask which i think should be used for short operations. Is it perhaps a better idea to use a bound service?"
42393586,71973426,42397668,3,0,Thu Feb 23 11:07:00 EST 2017,6124487,"thank you! I've updated the code and it greatly improved, but still make some mistakes. For istance one out of 2-3 times, no ack is received and i get 2 ack the next turn. Is this perhaps the computational limit of the IoT device? Or is there still margin for a better approach?"
42393586,71973732,42397668,3,0,Thu Feb 23 11:15:00 EST 2017,207421,"You cannot possibly get no ACKs or two ACKs if you have used all the suggestions in this answer. You can only get three bytes at a time if you only read three bytes at a time, and you can't possibly get less if you use `readFully()`."
42393586,72018723,42397668,3,1,Fri Feb 24 11:21:00 EST 2017,207421,"I know nothing about `SyncTask`, and I intend to keep it that way, but you should send the request and read the ACK in the same thread. You shouldn't send a new request until the old one has been acknowledged."
