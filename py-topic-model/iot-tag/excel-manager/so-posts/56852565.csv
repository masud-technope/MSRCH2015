thread_ID, Id, ParentId, PostType, Score, CreationDate, OwnerID, Body
56852565,56852565,null,1,0,Tue Jul 02 12:31:00 EDT 2019,10169230,"<p>i have used servo motors for pantilt  to track faces 	but the thing is the servo aren't directly connected to the raspberry 	instead im using 16channel adafruit pca9685 to control the servos	all the tutorials which teach face-tracking using raspberry aren't using such channels so i tried to figure out my own ways of making it happen </p>		<pre><code>for frame in camera.capture_continuous(rawCapture, format = 'bgr', use_video_port = True):	        image = frame.array		        resized = cv2.resize(image, (320, 240))	        gray = cv2.cvtColor(resized,cv2.COLOR_BGR2GRAY)		        faces = face_cascade.detectMultiScale(gray, 1.1, 5)	        if len(faces) &gt; 0:	            for (x, y, w, h) in faces:	                # Track(pan, tilt, Point(x + w/2.0, y+ h/2.0))	                break	        faces_resized = [(int(scale[0]*x), int(scale[1]*y), int(scale[0]*w), int(scale[1]*h)) for (x, y, w, h) in faces]	        for (x,y,w,h) in faces_resized:	            cv2.rectangle(image,(x,y),(x+w,y+h),(255,255,0),2)	</code></pre>		<p>to this part the code is absolutely clear the face is getting detected perfectly  fine but using this i want to track and change my servo motors position </p>		<p>i just need the code that makes it happen 	my adafruit board code structure</p>		<pre><code>            pwm.set_pwm(0, 0,cam_pan)	0 for index of channels 	0 min angle	</code></pre>		<p>cam_pan the angle it is supposed to move </p>		<p>considering those parameters i just want to control the movements of my servo/pantilt to move accordingly</p>		<p>i have tried to control the motors through this </p>		<pre><code>x = x + (w/2)	        y = y + (h/2)		        # Correct relative to center of image	        turn_x  = float(x - (FRAME_W/2))	        turn_y  = float(y - (FRAME_H/2))		        # Convert to percentage offset	        turn_x  /= float(FRAME_W/2)	        turn_y  /= float(FRAME_H/2)		        # Scale offset to degrees	    turn_x   = 2 # VFOV	    turn_y   = 2 # HFOV	    if x &gt; turn_x:	        cam_pan  += -turn_x	        pwm.set_pwm(0, 0,cam_pan)	    elif x &lt; turn_x:		        cam_pan  += +turn_x	        pwm.set_pwm(0, 0,cam_pan)	</code></pre>		<p>but its of no use the servo motors just started jerking a bit</p>		<pre><code>from picamera.array import PiRGBArray	from picamera import PiCamera	import time	import cv2	# from pisoc import *	import Adafruit_PCA9685	pwm = Adafruit_PCA9685.PCA9685()	FRAME_W = 180	FRAME_H = 100	cam_pan = 90	cam_tilt = 60		if __name__ == "__main__":		    camera = PiCamera()	    camera.resolution = (640, 480)	    camera.framerate = 32	    rawCapture = PiRGBArray(camera, size = camera.resolution)		    face_cascade = cv2.CascadeClassifier('/usr/local/share/OpenCV/lbpcascades/lbpcascade_frontalface.xml')		    scale = (camera.resolution[0]/320.0, camera.resolution[1]/240.0)		    time.sleep(0.1)		    for frame in camera.capture_continuous(rawCapture, format = 'bgr', use_video_port = True):	        image = frame.array		        resized = cv2.resize(image, (320, 240))	        gray = cv2.cvtColor(resized,cv2.COLOR_BGR2GRAY)		        faces = face_cascade.detectMultiScale(gray, 1.1, 5)	        if len(faces) &gt; 0:	            for (x, y, w, h) in faces:	                # Track(pan, tilt, Point(x + w/2.0, y+ h/2.0))	                break	        faces_resized = [(int(scale[0]*x), int(scale[1]*y), int(scale[0]*w), int(scale[1]*h)) for (x, y, w, h) in faces]	        for (x,y,w,h) in faces_resized:	            cv2.rectangle(image,(x,y),(x+w,y+h),(255,255,0),2)	            # Track first face		            # Get the center of the face	            x = x + (w/2)	            y = y + (h/2)		            # Correct relative to center of image	            turn_x  = float(x - (FRAME_W/2))	            turn_y  = float(y - (FRAME_H/2))		            # Convert to percentage offset	            turn_x  /= float(FRAME_W/2)	            turn_y  /= float(FRAME_H/2)		            # Scale offset to degrees	        turn_x   = 2 # VFOV	        turn_y   = 2 # HFOV	        if x &gt; turn_x:	            cam_pan  += -turn_x	            pwm.set_pwm(0, 0,cam_pan)	        elif x &lt; turn_x:		            cam_pan  += +turn_x	            pwm.set_pwm(0, 0,cam_pan)	        # cam_tilt += turn_y			        # Clamp Pan/Tilt to 0 to 180 degrees	        # cam_pan = max(0,min(180,cam_pan))	        # cam_tilt = max(0,min(180,cam_tilt))		        # Update the servos	        # pwm.set_pwm(0, 0,cam_pan)		            # print(cam_pan-90, cam_tilt-90)	            #	            # # Clamp Pan/Tilt to 0 to 180 degrees	            # cam_pan = max(0,min(180,cam_pan))	            # # cam_tilt = max(0,min(180,cam_tilt))	            #	            # # Update the servos	            # pwm.set_pwm(0, 0,cam_pan)	            #	            # # pan(int(cam_pan-90))	            # # tilt(int(cam_tilt-90))		            break			        cv2.imshow("Result", image)	        key = cv2.waitKey(1) &amp; 0xFF		        rawCapture.truncate(0)		        if key == ord('q') or key == 27:	            break	</code></pre>		<p>here is the complete code</p>		<p>i dont what exactly the issue is 	im not even sure if the issue is with the code part 	but i just want to change servo motors according to the face</p>	"
56852565,100255935,56852565,3,0,Tue Jul 02 12:54:00 EDT 2019,6542361,"Sounds like part of the problem is trying to get it all to work together at once. Small testable units are key. Have you been able to move the servos independently?		If not, try to set up a smaller test program that *only* moves the servos back and forth and step up from there."
56852565,100256403,56852565,3,0,Tue Jul 02 13:06:00 EDT 2019,10169230,"yes i have tried runinng it as units and its working perfectly fine"
