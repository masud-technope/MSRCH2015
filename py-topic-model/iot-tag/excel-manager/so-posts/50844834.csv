thread_ID, Id, ParentId, PostType, Score, CreationDate, OwnerID, Body
50844834,50844834,null,1,0,Wed Jun 13 19:25:00 EDT 2018,1185460,"<p>For some IoT communication I need to transmit some information over SMS, some of them being timestamp precise to the seconds, in order to save as much place as possible, I would like to encode them in base64</p>		<p>How to do this in C ? (if possible without malloc)</p>		<p>(of course I'm glad to hear if there's a more efficient, "no too custom" method of encoding an int32 in a SMS-compliant way)</p>	"
50844834,88693251,50844834,3,0,Wed Jun 13 19:32:00 EDT 2018,1185460,"@EugeneSh. the previous version of the code was simply printing the number in decimal, so it was eating more SMS charaters than necessary,  for the how yes actually the goal was to put the answer i came up with here :) , when googling i only found generic solution for encoding array of bytes that were using loops and malloc"
50844834,88693289,50844834,3,0,Wed Jun 13 19:33:00 EDT 2018,4253229,"Which characters SMS is able to transmit?"
50844834,88693520,50844834,3,0,Wed Jun 13 19:40:00 EDT 2018,1185460,"I would have said any printable characters of ASCII to be safe, it should be possible to use other encoding but I don't enough stuff about SMS yet."
50844834,88693688,50844834,3,0,Wed Jun 13 19:45:00 EDT 2018,4253229,"If any printable character is safe (what is printable by the way?), then you can encode the number into base-X, where X is the number of the available characters."
50844834,88727095,50844834,3,0,Thu Jun 14 16:45:00 EDT 2018,1185460,"@bruceg yes i'm aware of this, but i can't transmit it as binary as it needs to go through SMS , my baseline was more the base10 serialisation that is used currently"
50844834,88696825,50844834,3,0,Wed Jun 13 21:38:00 EDT 2018,1212725,"encoding binary data using `base64` EXPANDS it.  Each base64 output digit can encode only only 6 bits"
50844834,88698792,50844834,3,0,Wed Jun 13 23:37:00 EDT 2018,1475978,"[Base85](https://en.wikipedia.org/wiki/Ascii85) only requires 5 characters to pack a 32-bit timestamp."
50844834,88693098,50844834,3,0,Wed Jun 13 19:27:00 EDT 2018,4253229,"base64 won't save you much space. As for "how" - implement a function or use an existing library."
50844834,88693140,50844834,3,1,Wed Jun 13 19:28:00 EDT 2018,15168,"What's the problem?  Encoding 32-bits requires 6 bytes of Base-64 encoding (5 groups of 6 bits, one group of 2 bits).  That's two bytes better than simple hex encoding, and four bytes better than decimal encoding  Go for it!"
50844834,50844889,50844834,2,0,Wed Jun 13 19:29:00 EDT 2018,1185460,"<p>For the moment I came up with this </p>		<pre><code>void base64_encode_timestamp(	    uint32_t timestamp,	    char encoded_data[6]	) {		    // 26 because we encode 6 bits by 6, and it's a 32 bits integer	    // so  32 - 6 = 26	    // and &amp; 0x3F is a mask for 0b111_111	    encoded_data[0] = encoding_table[(timestamp &gt;&gt; 26) &amp; 0x3F];	    encoded_data[1] = encoding_table[(timestamp &gt;&gt; 20) &amp; 0x3F];	    encoded_data[2] = encoding_table[(timestamp &gt;&gt; 14) &amp; 0x3F];	    encoded_data[3] = encoding_table[(timestamp &gt;&gt; 8) &amp; 0x3F];	    encoded_data[4] = encoding_table[(timestamp &gt;&gt; 2) &amp; 0x3F];	    // here &lt;&lt; 4 is actually "&gt;&gt; -2" because we have 2 bits remaining	    // that we need to pad with four '0' 	    encoded_data[5] = encoding_table[(timestamp &lt;&lt; 4) &amp; 0x3F];	}		// a main to show that it works	int main() {		    // Wednesday, 13-Jun-18 09:56:27 UTC	    uint32_t timestamp = 1528883787;	    char timestamp_base64[6] = {};	    base64_encode_timestamp(timestamp, timestamp_base64);	    printf("%.6s\n", timestamp_base64);	}	</code></pre>		<p>note that it's not exactly valid as it's missing the <code>==</code> for padding, but in python one can do </p>		<p>(my_string + '===').decode('base64')</p>		<p>and it will works (even if there's already some padding) , which is a good tradeoff for a 25% decrease in space.  </p>	"
