thread_ID, Id, ParentId, PostType, Score, CreationDate, OwnerID, Body
49702461,49702461,null,1,-1,Fri Apr 06 23:59:00 EDT 2018,2881550,"<p>I'm currently dealing with a SigFox-based IoT device which can send messages with a payload up to 12 bytes in size. This means that the chip manufacturer usually has to get creative. I'm currently dealing with a message that looks like this: </p>		<pre><code>typedef struct {	    byte MsgId; // Message Identification Value = 0x01	    unsigned int Start :1; // Start Message	    unsigned int Move :1; // Object Moving	    unsigned int Stop :1; // Object Stopped	    unsigned int Vibr :1; // Vibration Detected	    int16 Temp; // Temperature in 0,01 degC	    byte GPSFixAge; // bit 0..7 = Age of last GPS Fix in Minutes,	    byte SatCnt_HiLL; // bit 0..4 = SatInFix, bit5 Latitude 25 bit 6,7 = Longitude 25,26	    byte Lat[3]; // bit 0..23 = latitude bit 0..23	    byte Lon[3]; // bit 0..23 = longitude bit 0..23	}	</code></pre>		<p>I suppose that the Start-Move-Stop-Vibr data is probably supposed to be interpreted as a boolean, but it's encoded as a bitfield nibble to save space. The only thing I don't know is whether I should consider start to be the least significant or most significant bit. F.e:</p>		<p><code>0x 00 8 ...</code></p>		<p>The 8 here represents the Start-Move-Stop-Vibr data, where the most significant bit is the highest. But does this mean the message is of a Start type or rather a Vibr?</p>	"
49702461,86418687,49702461,3,6,Sat Apr 07 00:07:00 EDT 2018,3386109,"The C standard leaves it up to the implementation to decide how bitfields are packed into the containing object. So putting bitfields into message definitions is bad practice. Instead, you should have a `byte Flags`, and use bitwise operations to extract the bits."
49702461,86419263,49702461,3,2,Sat Apr 07 00:59:00 EDT 2018,1401213,"How do you know whether the two bytes that form the Temp value are ordered little or big endian?  The point is that you can't know for certain given only this struct definition and the same goes for the order of the bits in the bitfield."
49702461,86419267,49702461,3,1,Sat Apr 07 01:00:00 EDT 2018,2299087,"You could ask the SigFox people directly - see https://build.sigfox.com/steps/technical-quickstart#get-started-links"
49702461,86419384,49702461,3,3,Sat Apr 07 01:15:00 EDT 2018,16007,"Using structs across compile domains is a very very bad idea.  Using bitfields in general is equally bad, significantly worse if part of a structure used across a compile domain.  You are creating work and maintenance and headaches for yourself.  This is one ghee whiz feature of the language you should avoid at all costs."
49702461,86422607,49702461,3,0,Sat Apr 07 06:43:00 EDT 2018,168986,"The fact that they are bitfields would suggest that a message may be both vibr and start simultaneously.  If all types were unique, you&amp'd need just two bits.  The documentation for your compiler should describe the implementation behaviour of bitfields. Moreover, the documentation for the product should describe messaging formats.  It would also be possible to reverse engineer it.  All that will be far easier for you to do than for your s to guess."
49702461,86426057,49702461,3,0,Sat Apr 07 10:32:00 EDT 2018,2881550,"Hey guys, thanks a lot for all the feedback. As mentioned in this comment thread, I think the best case for this would be to get in touch with the manufacturers and ask for additional information before I make to much assumptions about the structure. The problem is that I don't have access to an easy test-bench solution for the module so reverse-engineering would be too time consuming. Thanks again!"
49702461,86418713,49702461,3,1,Sat Apr 07 00:10:00 EDT 2018,2318649,"Referring to the device manufacturer is likely more reliable than guessing. Or if desperate look at more than one message, then vibrate the device and see what it sends. Or use a crystal ball."
49702461,86418720,49702461,3,0,Sat Apr 07 00:10:00 EDT 2018,1505939,""nibble" means 4 bits,  `:1` means 1 bit"
49702461,49727683,49702461,2,0,Mon Apr 09 07:33:00 EDT 2018,584518,"<blockquote>	  <p>I suppose that the Start-Move-Stop-Vibr data is probably supposed to be interpreted as a boolean, but it's encoded as a bitfield nibble to save space. </p>	</blockquote>		<p>Rather, they try to model a certain binary presentation with a bit-field. This is highly compiler-specific, so code like this will only work on a certain given compiler.</p>		<blockquote>	  <p>The only thing I don't know is whether I should consider start to be the least significant or most significant bit</p>	</blockquote>		<p>You can't know that, which bit that is the most significant is not specified by the standard. In addition, CPU (and possibly network protocol) endianess might come into play here.</p>		<p>The only way to know this is to read the specific compiler documentation.</p>		<p>This is why structs in general and bit-fields in particular are unsuitable for mapping raw binary data. The only portable way to write this code would have been to use a raw <code>uint8_t</code> array buffer, which can then be de-serialized into various variables.</p>	"
