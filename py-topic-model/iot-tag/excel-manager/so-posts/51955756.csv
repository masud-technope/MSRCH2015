thread_ID, Id, ParentId, PostType, Score, CreationDate, OwnerID, Body
51955756,51955756,null,1,1,Tue Aug 21 19:51:00 EDT 2018,9161669,"<p>I am trying to write a program to control home automation devices. This involves a <code>WebSocket</code> server that runs infinitely in a background thread listening for clients. The client sends JSON packets that contain settings. When the server gets a JSON packet, I want it to read and change any settings as needed in the <code>Main()</code></p>		<p>I have a working <code>WebSocket</code> server and I have tried to use the <code>PropertyChangedEvent</code> but it never seems to see the handler. I suspect this occurs because they exist in different threads.</p>		<p>I have attached my code below as well as the example I have been working off of. There is a chance I am way off the mark here but this is the best I could find with the reading I have been doing.</p>		<p>Any help would be appreciated!</p>		<p>This is the Main():</p>		<pre><code>using System;	using System.Threading;	using System.ComponentModel;		namespace HomeAutomation	{	    class Controller	    {	        static void Main(string[] args)	        {	            bool passGo = false;	            Thread SocketThread = new Thread(Socket.WebSocketServer);	            SocketThread.IsBackground = true;	            SocketThread.Start();		            //This line lets the user know the Socket Thread is running in the background	            Console.WriteLine("Socket Thread is running in the background: {0}", SocketThread.IsBackground);	            do {		                char input = Console.ReadKey().KeyChar;	                if (input == 'x')	                {	                    passGo = true;	                }	            } while (passGo == false);	            Console.ReadLine();	            /*	            Settings s = new Settings();	            s.PropertyChanged += new PropertyChangedEventHandler(S_PropertyChanged);	            while (true)	            {	                string str = Console.ReadLine();	                s.State = str;	            }*/	        }		        public static void S_PropertyChanged(object sender, PropertyChangedEventArgs e)	        {	            Settings RecSettings = (Settings)sender;		            Console.WriteLine("The {0} has changed to {1}", e.PropertyName, RecSettings.State);	        }		    }		    public class Settings : INotifyPropertyChanged	    //The Class Object 'Settings' is used to recieve the variable(s) from the client software	    {	        #region INotifyPropertyChanged Members	        public event PropertyChangedEventHandler PropertyChanged;	        #endregion		        string state = string.Empty;	        public string State	        {	            get { return state; }	            set	            {	                state = value;	                if (PropertyChanged != null)	                {	                    PropertyChanged(this, new PropertyChangedEventArgs("State"));	                    Console.WriteLine("Event has been called");	                }	            }	        }	    }	}	</code></pre>		<p>This is my webSocket:</p>		<pre><code>using System;	using System.Net;	using System.Net.Sockets;	using System.Text;	using System.Threading;	using Newtonsoft.Json;		namespace HomeAutomation	{	    class Socket	    {	        public static void WebSocketServer()	        {	            //Declaring variables used in the program	            IPAddress ipAddress = Dns.GetHostEntry("localhost").AddressList[0];	            TcpListener server = new TcpListener(ipAddress, 8080);		            try	            {	                //Starts the server	                server.Start();	                Console.WriteLine("Starting Server...");	            }	            catch (Exception ex)	            {	                //If the server cannot start the error will be caught and printed to console	                Console.WriteLine(ex.ToString());	                Console.ReadLine();	            }	            while (true)	            {	                TcpClient client = server.AcceptTcpClient();	                MakeNewConnection(client);	            }	        }		        public static void MakeNewConnection(TcpClient client)	        {	            var thread = new Thread(NewClient);	            thread.Start(client);	        }		        public static void NewClient(object data)	        {	            var client = (TcpClient)data;	            Settings RecSettings = new Settings();		            //Lets you know the address of the connected client	            string address = client.Client.AddressFamily.ToString();	            Console.WriteLine("{0} has connected!", address);		            //creates a network stream for information to flow through	            NetworkStream stream = client.GetStream();		            byte[] receivedBuffer = new byte[100];	            stream.Read(receivedBuffer, 0, receivedBuffer.Length);		            StringBuilder msg = new StringBuilder();		            foreach (byte b in receivedBuffer)	            {	                if (b.Equals(00))	                {	                    break;	                }	                else	                {	                    msg.Append(Convert.ToChar(b).ToString());	                }	            }		            Console.WriteLine("Client Says: {0}", msg.ToString());		            RecSettings = JsonConvert.DeserializeObject&lt;Settings&gt;(msg.ToString());		            Console.WriteLine(RecSettings.State.ToString());		            RecSettings.State = "Off";		            int byteCount = Encoding.ASCII.GetByteCount("Thank you");	            byte[] sendData = new byte[byteCount];	            sendData = Encoding.ASCII.GetBytes("Thank you");	            stream.Write(sendData, 0, sendData.Length);	        }	    }	}	</code></pre>		<p>This is the event handler example I am using:</p>		<pre><code>using System;	using System.ComponentModel;		namespace HomeAutomation	{	    class Program	    {	        static void Main(string[] args)	        {	            TestClass sample = new TestClass();	            sample.PropertyChanged += new PropertyChangedEventHandler(sample_PropertyChanged);	            while (true)	            {	                string str = Console.ReadLine();	                int val;	                if (int.TryParse(str, out val))	                    sample.TestValue = val;	            }	        }		        static void sample_PropertyChanged(object sender, PropertyChangedEventArgs e)	        {	            TestClass sample = (TestClass)sender;	            /*	             * Use expression behind if you have more the one property instead sample.TestValue	             * typeof(TestClass).GetProperty(e.PropertyName).GetValue(sample, null)*/	            Console.WriteLine("Value of property {0} was changed! New value is {1}", e.PropertyName, sample.TestValue);	        }	    }		    public class TestClass : INotifyPropertyChanged	    {		        #region INotifyPropertyChanged Members		        public event PropertyChangedEventHandler PropertyChanged;		        #endregion		        int testValue = 0;	        public int TestValue	        {	            get { return testValue; }	            set	            {	                testValue = value;	                if (PropertyChanged != null)	                    PropertyChanged(this, new PropertyChangedEventArgs("TestValue"));	            }	        }	    }	}	</code></pre>	"
51955756,51955902,51955756,2,0,Tue Aug 21 20:02:00 EDT 2018,242029,"<p>You may want to wrap the contents of your WebSocket response in code that invokes it in the Dispatcher thread.  </p>		<pre><code>System.Windows.Application.Current.Dispatcher.Invoke(new Action(() =&gt;	{	     ... response handler code		}	</code></pre>	"
