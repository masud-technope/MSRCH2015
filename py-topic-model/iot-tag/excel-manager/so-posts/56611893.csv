thread_ID, Id, ParentId, PostType, Score, CreationDate, OwnerID, Body
56611893,56611893,null,1,0,Sat Jun 15 15:51:00 EDT 2019,3210471,"<p>I try to develop an automation to register new IoT device with public RSA pem certificate but I have a problem which is I don't know the reason.</p>		<p>The problem is RSA_PEM public pem is generated my automation is rejected by GCP IoT Server with an error. That error is "The key data for the device credential in position 1 is invalid. Make sure the format is correct: Invalid RS256 public key"</p>		<p>When I debug the my code, the pem public certificate looks fine. But I am not sure that.</p>		<p>I am sharing go code that generate private and public certificates in paired.</p>		<pre class="lang-golang prettyprint-override"><code>package cert		import (	    "bytes"	    "crypto/rand"	    "crypto/rsa"	    "crypto/x509"	    "encoding/pem"		    "io"	)		type CertificateRSA struct {	    Private io.Reader	    Public  io.Reader	}		func Create() (*CertificateRSA, error) {		    bitSize := 2048	    key, err := rsa.GenerateKey(rand.Reader, bitSize)	    if err != nil {	        return nil, err	    }		    var privateKey = &amp;pem.Block{	        Type:  "RSA PRIVATE KEY",	        Bytes: x509.MarshalPKCS1PrivateKey(key),	    }		    var priBuff bytes.Buffer	    err = pem.Encode(&amp;priBuff, privateKey)	    if err != nil {	        return nil, err	    }		    // asn1Bytes := x509.MarshalPKCS1PublicKey(&amp;key.PublicKey)	    asn1Bytes := x509.MarshalPKCS1PublicKey(&amp;key.PublicKey)		    var publicKey = &amp;pem.Block{	        Type:  "PUBLIC KEY",	        Bytes: asn1Bytes,	    }		    var pubBuff bytes.Buffer		    err = pem.Encode(&amp;pubBuff, publicKey)	    return &amp;CertificateRSA{	        Private: &amp;priBuff,	        Public:  &amp;pubBuff,	    }, err	}		</code></pre>		<p>Can you see any problem in my code ?</p>		<p>And this code can generates certificates like as these:</p>		<pre><code>-----BEGIN RSA PRIVATE KEY-----	MIIEowIBAAKCAQEA0FGWENPInhIfCLDTqCFKFsyrvmzKsEjJtHEL0Tqh0LtHDWG5	Sh7MT7/x/xNAFc00zmgGG+PPaJDP/7gkGJitRAXcJOlKwlowgmVTf+QGwH81pq3o	ZNRd0mEXbF0EuPBRNt/9TzkZPAlPDGruMCiMq9LWsoIflx+u/3UmXgsyMQTs5vSM	z4T5VCELHGCtfZfBrDAP19KzwjFEUTEzX+Llotp0mO6+cRCslVvSK3xd8KIk2cOm	AXEmCavZnwuVsqCVmNZFoQZvFszisMf5cXZRDstKCGsqDgqIGM5dMMrBS92CqZ4u	j6h9zbMG7J9oXsVmVFiQ++hS0TLJdWwMD+uhWQIDAQABAoIBAAbKIfH6dRdxz8Eg	wkVAkIGduhtCwHhuZuSSqqfvGUcMU4yEGt3nkxEmWGTP487SGV6A1XIjQqdN0Pms	rsB+eWc2Ka6qS915wwr88nPAotezTbRZBrICmew5beICRh0g+ASp2D+0xLXIN+NX	uNuo9qzC+mxnAVCTn8iDsPRvuPsP9vJSy5zIzPWURdPBQ3Ny1pbj+odqwDdUw8q7	FfUmGHC7a5oKex3vxDhDL8OPc3KjynFJdm1YqUagLzppDHMZtI2rNAYfWrkrJVB7	zlX3m0hUDDrvHbQBiqGUj2qI2MqgrFlcK0HSryJdCz4tVdYY3qBi/tZrwOAvnSkv	zNFT6AECgYEA9veJpGwUYdRhWyo05xsatDJ+KvBpizi66Iu2Lu+fRQUuwYaC0DSV	BMr1ktbJzbgbu4XDNrJ8GKrqka06vGjaYVhw1C56LU83hHsckTx+K3fpb9wkFamE	gCZG3uAqflLsEPZ6xPHLe1U+SDZfghLrH90JYi7tTULReAVy5zVs8iECgYEA1/Aq	6ls9kPtJWLEU299WdNGYy5Fx1N8oUj5sjYTfPf/27OeBXWg+CKBIhXk534z9pwqq	LUs7NbmqhuocuxFtE7oxdwqXqUR7qYUdpVuRZ8EmVvBuUGxI1MG6MMKxHxSSpTs5	3tTDAd2WlwPX3jbqAj2WOiL2T97cXNjYyKxiuDkCgYBbI0RnKf9njtGSrAOz2XvE	TfHjdK7uUrQfBxfnQER9WwlDH5l8rjrj9uYjFyKHyU5qqFU/BSTokYJY2h2X0/Xr	AJE6rCAoQliRikEjk7hX4DuELTAf0lv0UqvKqdzkm0NEi0EJFtXpoK6IRZB/Vu3v	50kEM58c6PCWIyShEEUxIQKBgQCg63qf0UTNMWaUcMqxm/sq7TNnqMjisTa0K47r	27Qd2Q1juJZATLnF5eSFizSkssYoYJs3S9QhEm7RQdANXEwkImJQaxVgcAeT6f6Q	xu9SGa9/pIcg6cFQw9oEEmK6XbN27O8Qbw+v6Tka6yNIlzXGW60DQCC8nsErc/IB	ge3DiQKBgA3183wzRLj7oZD/KJHW+BY0Y6ljZ8EQQ5anc3RFsQrJ48MdPtRNvC49	Oe0T2lRznVdiPcGY8DKlBMYXQ4jiXZxpWmM8jNkJYPBhx9rq8zBDESo8DKSFd1Jo	lNADlBGDEPYgxG29hnSOrBf5TI1Fkj15RVZOJ79uaefp98ACIgkl	-----END RSA PRIVATE KEY-----	</code></pre>		<pre><code>-----BEGIN PUBLIC KEY-----	MIIBCgKCAQEA0FGWENPInhIfCLDTqCFKFsyrvmzKsEjJtHEL0Tqh0LtHDWG5Sh7M	T7/x/xNAFc00zmgGG+PPaJDP/7gkGJitRAXcJOlKwlowgmVTf+QGwH81pq3oZNRd	0mEXbF0EuPBRNt/9TzkZPAlPDGruMCiMq9LWsoIflx+u/3UmXgsyMQTs5vSMz4T5	VCELHGCtfZfBrDAP19KzwjFEUTEzX+Llotp0mO6+cRCslVvSK3xd8KIk2cOmAXEm	CavZnwuVsqCVmNZFoQZvFszisMf5cXZRDstKCGsqDgqIGM5dMMrBS92CqZ4uj6h9	zbMG7J9oXsVmVFiQ++hS0TLJdWwMD+uhWQIDAQAB	-----END PUBLIC KEY-----	</code></pre>	"
56611893,99807877,56611893,3,0,Sun Jun 16 07:48:00 EDT 2019,3210471,"@JamesKPolk thank you for comment. But using the header recommended by you  instead of "PUBLIC KEY" doesn't work. I am getting same error by GCP IoT Core API.		I think that my go code can't generate RSA Keys like as openssl command. For example  the outputs of this command `openssl genrsa -out rsa_private.pem 2048 && openssl rsa -in rsa_private.pem -pubout -out rsa_public.pem`  are verified by GCP IoT Core API."
56611893,100323276,56611893,3,0,Thu Jul 04 12:39:00 EDT 2019,3210471,"I could not figure out any way to generate valid pem file via above code. So I  have written an wrapper on `ssh` command."
56611893,99799581,56611893,3,0,Sat Jun 15 16:58:00 EDT 2019,238704,"The public key is not a valid format. The header suggests a base64-encoded SubjectPublicKeyInfo structure but the contents are actually an RSAPublicKey structure. An RSAPublicKey structure should start out "BEGIN RSA PUBLIC KEY"."
56611893,56612684,56611893,2,0,Sat Jun 15 17:34:00 EDT 2019,238704,"<p>The encoding header and the encoding method don't match. If you want to use</p>		<pre><code>asn1Bytes := x509.MarshalPKCS1PublicKey(&amp;key.PublicKey)	</code></pre>		<p>then the <code>pem.Block</code> Type should be <code>Type:  "RSA PUBLIC KEY",</code>.</p>		<p>If you want the other common public key format, a SubjectPublicKeyInfo ASN.1 structure, then keep the <code>pem.Block</code> as you have it and instead use</p>		<pre><code>asn1Bytes, err := x509.MarshalPKIXPublicKey(&amp;key.PublicKey)	</code></pre>		<p>I don't know what GCP is expecting but it's almost certainly one or the other.</p>	"
56611893,99804856,56612684,3,0,Sun Jun 16 00:54:00 EDT 2019,238704,"@JohnHanley: Thanks. Do you happen to have a link to right docs, or is it something you discovered by trial and error?"
56611893,99805010,56612684,3,1,Sun Jun 16 01:15:00 EDT 2019,8016720,"It is more of a convention with the cloud vendors as PKCS #1 is easier to decode. However, I just looked up the IoT certificate create command: `openssl req -x509 -newkey rsa:2048 -keyout rsa_private.pem -nodes -out rsa_cert.pem -subj "/CN=unused"` and that command generates PKCS #8. https://cloud.google.com/iot/docs/how-tos/credentials/keys"
56611893,99807910,56612684,3,0,Sun Jun 16 07:51:00 EDT 2019,3210471,"@JamesKPolk  using `RSA PUBLIC KEY` as TYPE doesn't work."
56611893,57752201,56611893,2,0,Mon Sep 02 06:17:00 EDT 2019,4052858,"<p>I faced the same issue.	I could solve this with the following code.</p>		<pre><code>package cloudIotCore		import (	    "crypto/rand"	    "crypto/rsa"	    "crypto/x509"	    "encoding/pem"	    "os"	)		func create() {		    //	    // Create key	    //	    reader := rand.Reader	    bitSize := 2048		    key, err := rsa.GenerateKey(reader, bitSize)	    if err != nil {	        panic(err)	    }		    publicKeyAsc1Bytes, err := x509.MarshalPKIXPublicKey(&amp;(key.PublicKey))	    if err != nil {	        panic(err)	    }		    publicPemKey := &amp;pem.Block{	        Type:  "PUBLIC KEY",	        Bytes: publicKeyAsc1Bytes,	    }		    privatePemKey := &amp;pem.Block{	        Type:  "RSA PRIVATE KEY",	        Bytes: x509.MarshalPKCS1PrivateKey(key),	    }		    //	    // Create Device with publicPemKey	    //		    :		    //	    // Save pem files	    //		    publicPemFile, err := os.Create(PATH_TO_PUBLICKEY)	    if err != nil {	        panic(err)	    }	    defer publicPemFile.Close()		    err = pem.Encode(publicPemFile, publicPemKey)	    if err != nil {	        panic(err)	    }		    privatePemFile, err := os.Create(PATH_TO_PRIVATEKEY)	    if err != nil {	        panic(err)	    }	    defer privatePemFile.Close()		    err = pem.Encode(privatePemFile, privatePemKey)	    if err != nil {	        panic(err)	    }		}	</code></pre>	"
