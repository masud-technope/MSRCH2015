thread_ID, Id, ParentId, PostType, Score, CreationDate, OwnerID, Body
30127477,30127477,null,1,1,Fri May 08 15:27:00 EDT 2015,127018,"<p>I'm a huge fan of using Unity for .NET applications to keep code module and dependencies "manageable" in large code-bases. I've used it for years with .NET by dropping assemblies into the main program's program directory and re-configuring an IoC configuration file (usually the .exe.config file), injecting new behaviour into a program without needing to re-compile the main program.</p>		<p>However, I have started my foray into writing universal apps for Windows Store and more importantly, Windows IoT - however because these apps are "packaged up" during compilation, I'm finding it difficult to understand how best to continue doing this.</p>		<p>One possible option would be to compile the "modules" (PCL/Universal class libraries) and include them (and their dependencies) as "Content" files within the Universal app, then use reflection to load types from these assemblies during the start-up of the program via reflection.</p>		<p>Another option would be to include all modules and their dependencies into the main program's project references before compilation but using "poor man's dependency injection to hard code the registrations and resolutions", but this feels really wrong to me - I'd ideally like to keep the separation of dependencies if at all possible?</p>		<p>Any ideas...?</p>		<p>PS. I'm not tied to Unity in any way, if there is another IoC library that does it better on this platform then fine - but Unity is what I already know and love!</p>	"
30127477,30128104,30127477,2,1,Fri May 08 15:58:00 EDT 2015,3825959,"<p>I do this using Castle Windsor. You can probably use the same approach with Unity:</p>		<ul>	<li>Limit references only to when an assembly needs a type defined in	another assembly</li>	<li>Define a class (or classes depending on how you want to organize) for IoC configuration in each assembly by implementing IWindsorInstaller and configure DI using the fluent API inside the implemented <code>Install</code> method.</li>	<li>Define a container instance inside your app root</li>	<li>At application start, use reflection to find all types implementing	IWindsorInstaller in the bin folder and run their <code>Install</code> method,	passing in the container instance</li>	</ul>		<p>This way you can keep your dependencies separate, and you don't have to worry about adding extra references or adding .dlls as content files.</p>	"
30127477,48447898,30128104,3,0,Mon May 11 14:55:00 EDT 2015,127018,"Thanks @marboilerplate, I do have some contention with keeping the interface and implementation in the same assembly and also hard coding the IoC behaviour in assemblies too - Ideally I'd like to keep IoC configuration details out of the source code."
30127477,48448847,30128104,3,0,Mon May 11 15:15:00 EDT 2015,3825959,"@tommed I think that the IoC paradigm you describe works well for managing standalone/versioned dlls that can be just dropped in, but for scenarios where a piecemeal deployment isn't really feasible, that paradigm offers quickly diminishing returns. Ultimately the main benefit of decoupling when you have a strict build process is that a dependency-specific change is localized, even if you end up building everything. I usually start with what I described and break out/decouple further if I encounter limitations. Programming to the interface and not the implementation is the most important part."
30127477,48449227,30128104,3,0,Mon May 11 15:25:00 EDT 2015,3825959,"@tommed as for hard coding, it might seem like it, but it's not. You define a stateless method in the assemblies for configuration and on startup the composition root/bootstrapper in the main application passes that container in to each assembly method. This is acceptable as the IoC code is agnostic to what container it is passed, as opposed to referencing the container/composition root. The IoC code is also never referenced by anything but the bootstrapper. Hard coding would be referencing the container in your dependency objects, which is what would really be your "source code"."
30127477,48492827,30128104,3,0,Tue May 12 14:31:00 EDT 2015,3825959,"@tommed If you want the interface and the implementation in separate assemblies, then you would want the configuration in the implementation assembly to avoid the problem you're describing (which means the interface assembly wouldn't have any configuration--its role is exclusively to define a contract). I believe this also solves your constructor arguments problem--when you change the constructor arguments of an implementation, you update the corresponding config in the same assembly."
30127477,48493235,30128104,3,0,Tue May 12 14:39:00 EDT 2015,3825959,"@tommed I think the scenario you're describing with adding a new implementation assembly to an app with an existing interface/implementation assembly is a bit of an edge case, especially since you'll be rebuilding the app anyway, but if you really wanted to "bolt on" a new assembly with implementations without changing an existing hybrid interface/implementation assembly, then you would add only the configuration for the new implementations in the implementation assembly. As for conflicts, I'm not sure how flexible Unity is, but I know you can override an existing registration with Windsor."
30127477,48523002,30128104,3,1,Wed May 13 08:15:00 EDT 2015,127018,"Thanks @moarboilerplate - Good points thanks for bearing with me - it's certainly a different way of doing things (ie. no single composition and no concept of a resolution root), but it's clearly the way it'll have to work for Windows Store apps. Thanks for sharing your experience!"
30127477,48479014,30128104,3,0,Tue May 12 09:31:00 EDT 2015,127018,"Interesting angle - but if I wanted to create a new assembly that implemented the interface - I would have to have a dependency on the assembly that contains the interface and all the previous implementations, that would break the cascading dependency design. Also, what if I want to change the injected ctor arguments after I deployed the assembly? The injection logic is hard-coded so this wouldn't work...?"
30127477,48366514,30128104,3,0,Fri May 08 16:14:00 EDT 2015,127018,"So how do you go about distributing those assemblies in a Universal App whilst keeping the isolation?"
30127477,48367109,30128104,3,0,Fri May 08 16:29:00 EDT 2015,3825959,"@tommed Define both your interface and the implementation together in a referenced assembly and wire it up inside a configuration defined in that assembly, and only reference the interface from the main app. I'd question the need to split up the interface and implementation, but if you do, then you would need to define the interface in an intermediary assembly."
30127477,48367249,30128104,3,0,Fri May 08 16:33:00 EDT 2015,3825959,"@tommed the isolation comes from being able to switch out an underlying implementation as long as the interface stays the same."
