thread_ID, Id, ParentId, PostType, Score, CreationDate, OwnerID, Body
54662037,54662037,null,1,0,Wed Feb 13 03:25:00 EST 2019,1927361,"<p>I setup a VM running a ThingsBoard broker for an IoT project I'm working on and running into some odd problems. I'm using an ESP32 with a few sensors connected (temperature, humidity, pressure, etc.) and want to simply push these values to the ThingsBoard broker using MQTT. I created a test program based on the code sample provided by ThingsBoard, but am having issues connecting to the server. Here is my code below:</p>		<pre><code>#include &lt;WiFi.h&gt;	#include &lt;Wire.h&gt;	#include &lt;OneWire.h&gt;	#include &lt;PubSubClient.h&gt;	#include &lt;Adafruit_Sensor.h&gt;	#include &lt;Adafruit_BME280.h&gt;	#include &lt;DallasTemperature.h&gt;		// Constants	#define ONE_WIRE_PIN  14  // One-Wire pin for water temperature sensor	#define TURBIDITY_PIN 36  // Analog pin for turbidity sensor	#define SEALEVELPRESSURE_HPA (1013.25)		// WiFi Login Info	#define ssid              "WiFiNetwork"	#define password          "password"		// MQTT Broker IP address:	#define mqtt_server       "192.168.0.10"	#define mqtt_server_port  1883		// MQTT Client Info	#define MQTT_CLIENT_NAME "ESP32"	#define ACCESS_TOKEN "ESP32_DEMO_TOKEN"		// Sensor Variables	float airTemperature = 0;	float waterTemperature = 0;	float humidity = 0;	float pressure = 0;	float altitude = 0;	float turbidity = 0;		// Control Variables	long lastMsg = 0;   // keeps track of timestamp since the last message was sent		// Objects	Adafruit_BME280 BME280; // I2C	OneWire oneWire_in(ONE_WIRE_PIN);	DallasTemperature temperature_sensor(&amp;oneWire_in);		WiFiClient espClient;	PubSubClient client(espClient);		void setup() {	  int status = 0;		  Serial.begin(115200);		  // Initialize BME280	  status = BME280.begin();  	  if (!status) {	      while(true) {	        Serial.println("Could not find a valid BME280 sensor, check wiring!");	        delay(5000);	      }	  }		  // Initialize the One-Wire Temperature Sensor	  temperature_sensor.begin();		  // Initialize the WiFi and MQTT connections	  setup_wifi();	  client.setServer(mqtt_server, mqtt_server_port);	  client.setCallback(mqtt_callback);	}		void loop() {	  // Update/refresh the Wifi/MQTT connection	  updateWirelessConnection();		  // Read and transmit the sensor values every 5 seconds	  long now = millis();	  if (now - lastMsg &gt; 5000) {	    lastMsg = now;		    // Read all the sensor values	    collectMeasurements();		    // Publish updated sensor values	    publishMeasurements();		    // Print all sensor values	    printMeasurements();	  }	}		void updateWirelessConnection()	{	  if (!client.connected()) {	    reconnect();	  }		  client.loop();	}		void printMeasurements()	{	  Serial.print("Air Temperature: ");	  Serial.print(airTemperature);	  Serial.println( " *C");		  Serial.print("Air Pressure: ");	  Serial.print(pressure);	  Serial.println( " hPa");		  Serial.print("Humidity: ");	  Serial.print(humidity);	  Serial.println( " %RH");		  Serial.print("Altitude: ");	  Serial.print(altitude);	  Serial.println( " m");		  Serial.print("Water Temperature: ");	  Serial.print(waterTemperature);	  Serial.println( " *C");		  Serial.print("Water Turbidity: ");	  Serial.print(turbidity);	  Serial.println( " NTUs");		  Serial.println();	}		void collectMeasurements()	{	  // Read the measurements from the BME280 sensor	  airTemperature = BME280.readTemperature();	  pressure = BME280.readPressure() / 100.0F;	  altitude = BME280.readAltitude(SEALEVELPRESSURE_HPA);	  humidity = BME280.readHumidity();		  // Read the water temperature sensor	  temperature_sensor.requestTemperatures();	  waterTemperature = temperature_sensor.getTempCByIndex(0);		  // Read the turbidity sensor	  turbidity = calculateTurbidityValue(analogRead(TURBIDITY_PIN), waterTemperature);	}		// Calculates the temperature-compensated Turbidity value based on the raw ADC voltage and water temperature in celsius	float calculateTurbidityValue(int adcValue, float waterTemp)	{	  // Convert ADC value to original voltage reading	  float voltage = adcValue * (5.0 / 4096.0);		  // Correct the voltage value for temperature	  // TODO: TBD later		  // Convert the voltage to NTUs	  float NTUs = -1120.4 * pow(voltage, 2.0) + 5742.3 * voltage - 4352.9;		  if (NTUs &lt; 0) {	    return 0;	  } else {	    return NTUs;	  }	}		// Publishes all measurements to the MQTT broker	void publishMeasurements()	{	  // Create Payload string	  // Paylod String format: {"key1":"value1", "key2":"value2"}	  String payload1 = "{";	  payload1 += "\"airTemperature\":";   payload1 += airTemperature;    payload1 += ",";	  payload1 += "\"pressure\":";         payload1 += pressure;          payload1 += ",";	  payload1 += "\"humidity\":";         payload1 += humidity;	  payload1 += "}";		  String payload2 = "{";	  payload2 += "\"altitude\":";         payload2 += altitude;          payload2 += ",";	  payload2 += "\"waterTemperature\":"; payload2 += waterTemperature;  payload2 += ",";	  payload2 += "\"turbidity\":";        payload2 += turbidity;	  payload2 += "}";		  transmitPayload(payload1);	  transmitPayload(payload2);	}		void transmitPayload(String payload)	{	  // Convert Payload string to c-string and transmit	  char attributes[500];	  payload.toCharArray(attributes, 500);	  client.publish("v1/devices/me/telemetry", attributes);	}		void setup_wifi() {	  delay(10);		  // We start by connecting to a WiFi network	  Serial.println();	  Serial.print("Connecting to ");	  Serial.println(ssid);		  WiFi.begin(ssid, password);		  while (WiFi.status() != WL_CONNECTED) {	    delay(500);	    Serial.print(".");	  }		  Serial.println("");	  Serial.println("WiFi connected");	  Serial.println("IP address: ");	  Serial.println(WiFi.localIP());	}		void mqtt_callback(char* topic, byte* message, unsigned int length) {	  Serial.print("Message arrived on topic: ");	  Serial.print(topic);	  Serial.print(". Message: ");	  String messageTemp;		  for (int i = 0; i &lt; length; i++) {	    Serial.print((char)message[i]);	    messageTemp += (char)message[i];	  }	  Serial.println();		  // Feel free to add more if statements to control more GPIOs with MQTT		  // If a message is received on the topic esp32/output, you check if the message is either "on" or "off". 	  // Changes the output state according to the message	  /*if (String(topic) == "esp32/output") {	    Serial.print("Changing output to ");	    if(messageTemp == "on"){	      Serial.println("on");	      digitalWrite(ledPin, HIGH);	    }	    else if(messageTemp == "off"){	      Serial.println("off");	      digitalWrite(ledPin, LOW);	    }	  }*/	}		void reconnect() {	  // Loop until we're reconnected	  while (!client.connected())	  {	    Serial.print("Attempting MQTT connection...");	    // Attempt to connect	    if (client.connect(MQTT_CLIENT_NAME, ACCESS_TOKEN, NULL)) {	      Serial.println("connected");	      // Subscribe	      //client.subscribe("esp32/output");	    } else {	      Serial.print("failed, rc=");	      Serial.print(client.state());	      Serial.println(" try again in 5 seconds");	      // Wait 5 seconds before retrying	      delay(5000);	    }	  }	}	</code></pre>		<p>For those interested, the code that actually reads the sensor values and prints them out works fine, the issue is the code that connects to the ThingsBoard server. When I run this code, this is what I see in the serial terminal:</p>		<blockquote>	  <p>ets Jun  8 2016 00:22:57</p>	  	  <p>rst:0x1 (POWERON_RESET),boot:0x13 (SPI_FAST_FLASH_BOOT)	  configsip: 0, SPIWP:0xee	  clk_drv:0x00,q_drv:0x00,d_drv:0x00,cs0_drv:0x00,hd_drv:0x00,wp_drv:0x00	  mode:DIO, clock div:1	  load:0x3fff0018,len:4 	  load:0x3fff001c,len:928 	  ho 0 tail 12 room 4 	  load:0x40078000,len:9280	  load:0x40080400,len:5848	  entry 0x40080698</p>	  	  <p>Connecting to WiFiNetwork	  ....	  WiFi connected	  IP address: 	  192.168.0.15 	  Attempting MQTT connection...failed, rc=-1 try again in 5 seconds	  Attempting MQTT connection...failed, rc=-1 try again in 5 seconds</p>	</blockquote>		<p>From looking at the <a href="https://pubsubclient.knolleary.net/api.html" rel="nofollow noreferrer">PubSubClient library documentation</a>, a status code of -1 means "the client is disconnected cleanly", which doesn't really make sense...</p>		<p>So assuming that there may be something wrong with my ThingsBoard server, I used the MQTT.js client sample files from the <a href="https://thingsboard.io/docs/getting-started-guides/helloworld/#pushing-data-from-the-device" rel="nofollow noreferrer">ThingsBoard Getting Started Guide</a> and modified the .bat and .json files to match my inputs as follows:</p>		<p><strong>mqtt-js.bat</strong></p>		<pre><code>@echo off		REM Set ThingsBoard host to "demo.thingsboard.io" or "localhost"	set THINGSBOARD_HOST=192.168.0.10		REM Replace YOUR_ACCESS_TOKEN with one from Device details panel.	set ACCESS_TOKEN=ESP32_DEMO_TOKEN		REM Read serial number and firmware version attributes	set /p ATTRIBUTES=&lt;attributes-data.json		REM Read timeseries data as an object without timestamp (server-side timestamp will be used)	set /p TELEMETRY=&lt;telemetry-data.json		REM publish attributes and telemetry data via mqtt client	node publish.js	</code></pre>		<p><strong>telemetry-data.json</strong></p>		<pre><code>{"airTemperature":21, "humidity":55.0, "pressure": 101.6}	</code></pre>		<p>When I execute the .bat file, the data publishes to my server without issues!</p>		<p>The strange thing is that this MQTT.js file does not seem to need the port 8080 specified like my Arduino code does. It's clear that the problem lies with the Arduino code and not the server itself, but I'm absolutely stumped... Any ideas?</p>		<p><strong>EDIT:</strong> After correcting the problem with the incorrect MQQT port number the server was able to connect properly. Then after some testing, I noticed that the payload string was not updating on the dashboard at all once all the variables were included. It turned out that the string was too long to transmit correctly, so I updated the code to split the string into two transmissions, which ultimately fixed everything.</p>	"
54662037,54662457,54662037,2,3,Wed Feb 13 04:21:00 EST 2019,2670348,"<p>You said that you're running ThingsBoard in a VM.</p>		<p>Unless you've explicitly configured it otherwise, that VM will only be reachable by software running on the same computer as the VM. That's why the .bat file works.</p>		<p>VMs generally set up a private virtual network inside the computer that they're running on with only themselves and that computer on the network.</p>		<p>You'll need to check the documentation for your VM software to figure out how to make the VM reachable from other computers on the network your Windows machine is connected to.</p>		<p>It's also possible you're using the wrong port number. MQTT normally uses 1883, not 8080 as your ESP32 code has defined. I would verify this first before digging into the configuration of the VM.</p>	"
54662037,96140719,54662457,3,0,Wed Feb 13 17:05:00 EST 2019,1927361,"Thank you! Yes, the incorrect port number was exactly the problem!"
