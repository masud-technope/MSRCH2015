thread_ID, Id, ParentId, PostType, Score, CreationDate, OwnerID, Body
52310530,52310530,null,1,0,Thu Sep 13 09:19:00 EDT 2018,2176499,"<p>I am trying to use SSL client verification to connect to a remote AWS IoT endpoint. I have three files:</p>		<pre><code>- CA Root Certificate File	- Certificate File	- Private Key	</code></pre>		<p>The connection to the endpoint is successful if I use SSL_CTX_load_verify_locations, SSL_CTX_use_certificate_chain_file and SSL_CTX_use_PrivateKey_file.</p>		<pre><code>    if (!SSL_CTX_load_verify_locations(p_ssl_context_, root_ca_location_.c_str(), NULL)) {	        AWS_LOG_ERROR(OPENSSL_WRAPPER_LOG_TAG, " Root CA Loading error");	        return ResponseCode::NETWORK_SSL_ROOT_CRT_PARSE_ERROR;	    }		    // TODO: streamline error codes for TLS	    if (0 &lt; device_cert_location_.length() &amp;&amp; 0 &lt; device_private_key_location_.length()) {	        AWS_LOG_DEBUG(OPENSSL_WRAPPER_LOG_TAG, "Device crt : %s", device_cert_location_.c_str());	        if (!SSL_CTX_use_certificate_chain_file(p_ssl_context_, device_cert_location_.c_str())) {	            AWS_LOG_ERROR(OPENSSL_WRAPPER_LOG_TAG, " Device Certificate Loading error");	            return ResponseCode::NETWORK_SSL_DEVICE_CRT_PARSE_ERROR;	        }	        AWS_LOG_DEBUG(OPENSSL_WRAPPER_LOG_TAG, "Device privkey : %s", device_private_key_location_.c_str());	        if (1 != SSL_CTX_use_PrivateKey_file(p_ssl_context_,	                                             device_private_key_location_.c_str(),	                                             SSL_FILETYPE_PEM)) {	            AWS_LOG_ERROR(OPENSSL_WRAPPER_LOG_TAG, " Device Private Key Loading error");	            return ResponseCode::NETWORK_SSL_KEY_PARSE_ERROR;	        }	    }	    certificates_read_flag_ = true;	</code></pre>		<p>However, the call doesn't work if I construct the chain manually by adding the certificates using string buffers. The error returned is "An unknown occurred while waiting for the TLS handshake to complete.".</p>		<pre><code>    X509_STORE* store = SSL_CTX_get_cert_store(p_ssl_context_);	    X509 *rootCACertificate, *deviceCertificate;	    RSA *privateKey;	    BIO *bio;		    std::string rootCACertificateBuffer;	    std::string deviceCertificateBuffer;	    std::string privateKeyBuffer;		    rootCACertificateBuffer = 	    "-----BEGIN CERTIFICATE-----\n"		    "-----END CERTIFICATE-----\n";		    deviceCertificateBuffer = 	    "-----BEGIN CERTIFICATE-----\n"		    "-----END CERTIFICATE-----\n";		    privateKeyBuffer = 	    "-----BEGIN RSA PRIVATE KEY-----\n"		    "-----END RSA PRIVATE KEY-----\n";		    bio = BIO_new(BIO_s_mem());	    BIO_puts(bio, rootCACertificateBuffer.c_str());	    rootCACertificate = PEM_read_bio_X509(bio, NULL, 0, NULL);	    X509_STORE_add_cert(store, rootCACertificate);	    BIO_free(bio);		    bio = BIO_new(BIO_s_mem());	    BIO_puts(bio, deviceCertificateBuffer.c_str());	    deviceCertificate = PEM_read_bio_X509(bio, NULL, 0, NULL);	    X509_STORE_add_cert(store, deviceCertificate);	    BIO_free(bio);		    bio = BIO_new(BIO_s_mem());	    BIO_puts(bio, privateKeyBuffer.c_str());	    privateKey = PEM_read_bio_RSAPrivateKey(bio, NULL, 0, NULL);	    SSL_CTX_use_RSAPrivateKey(p_ssl_context_, privateKey);	    BIO_free(bio);		    SSL_CTX_build_cert_chain(p_ssl_context_,SSL_BUILD_CHAIN_FLAG_CHECK );		    certificates_read_flag_ = true;	</code></pre>	"
52310530,91594984,52310530,3,0,Fri Sep 14 01:44:00 EDT 2018,2176499,"I have dug deeper into the problem and I am getting a SSL_ERROR_WANT_READ error from SSL_Connect()"
52310530,91568637,52310530,3,2,Thu Sep 13 09:37:00 EDT 2018,1322972,"If you're the *least* bit interested in where the wheels fall off the wagon, perhaps checking the otherwise-ignored return results of that smattering of OpenSSL library calls may divulge something useful, particularly the SSL_CTX_xxxx family."
52310530,91569357,52310530,3,0,Thu Sep 13 09:55:00 EDT 2018,2176499,"Apologies for the sloppy no-checking code. Let me add in the the checks and update the question."
