thread_ID, Id, ParentId, PostType, Score, CreationDate, OwnerID, Body
42961534,42961534,null,1,2,Wed Mar 22 19:59:00 EDT 2017,7753110,"<p>I am new to MQTT and working with the mosquitto broker and development libraries. </p>		<p>I have a usecase where different subscribers may want to subscribe to a given topic but would want the data at different rates. So, subscriber1 may want it only on change from the previous value while subscriber2 may want it on a fixed cadence, say, every few mins/seconds.</p>		<p>Is there a way to configure that in the mosquitto broker? Or any other broker that supports it?</p>	"
42961534,73017381,42961534,3,0,Wed Mar 22 20:03:00 EDT 2017,1342232,"With or without MQTT, on PubNub you would need two separate channels: topic-delta and topic-cadence. Each subscribe would subscribe to different channels. The publisher would publish data at the regular cadence on topic-cadence and `if currentValue <> lastValue, publish to topic-delta`. Does that make sense?"
42961534,73017470,42961534,3,0,Wed Mar 22 20:05:00 EDT 2017,1342232,"Optionally, with PubNub, you could use Stream Filters to publish a meta-data key that is true if the value has changes from the previous and the subscriber to the channel that only wants changes, the client would create a set a filter to only receive messages with that meta-data key set to true."
42961534,73074340,42961534,3,0,Fri Mar 24 04:48:00 EDT 2017,1342232,"Posted an official answer below."
42961534,73065000,42961534,3,0,Thu Mar 23 20:47:00 EDT 2017,7753110,"Yes, that's what I thought I'd do if I didn't find a good solution. However, this seemed so basic that I thought that at least some broker implementations would support it."
42961534,42962164,42961534,2,1,Wed Mar 22 20:35:00 EDT 2017,504554,"<p>No, there is no way to configure mosquitto (or any full fledged broker that I am aware of) to do that, it will deliver every message sent to a topic to all subscribers at the rate the publisher sends new messages.</p>		<p>If you really must have this feature then the best you could do is probably take something like mosca (<a href="https://github.com/mcollina/mosca" rel="nofollow noreferrer">https://github.com/mcollina/mosca</a>) and use the hooks it provides to build your own broker, but it would be a nasty hack and it still wouldn't normally redeliver the same message if no new one had arrived for the constant cadence problem</p>		<p>But it would be so much easier to just keep a little state in the clients to throw duplicates away messages and and event loop that just processed the last message if a new one hadn't arrived yet.</p>	"
42961534,42991628,42961534,2,2,Fri Mar 24 04:48:00 EDT 2017,1342232,"<h1>Channel Data Segregation</h1>		<p>With or without MQTT, on PubNub you would need two separate channels: one for delta data and one for regular cadence data and there are three strategies you can employ. </p>		<h2>Two Channels</h2>		<p>The clients wanting only the data changes would subscribe to <code>topic-change</code>. The subscribers wanting a regular cadence of data would subscribe to both <code>topic-cadence</code> and <code>topic-change</code>. </p>		<p>The publisher would publish data at the regular cadence on <code>topic-cadence</code> and <code>if currentValue !=lastValue</code>, publish to <code>topic-change</code>. So both types of subscribers get the data they want.</p>		<h2>Stream Filters</h2>		<p>Another option with PubNub, you could use <a href="https://www.pubnub.com/docs/nodejs-javascript/stream-filtering-tutorial#publishing-with-meta" rel="nofollow noreferrer">Stream Filters to publish</a> a meta-data value equal to "1" if the value has changed from the previous and "0" if the value is the same as the last value published. The values would only be published to one channel, <code>topic-cadence</code>. </p>		<pre class="lang-js prettyprint-override"><code>pubnub.publish(	    {	        channel: "topic-cadence", 	        message: {"price" : 102.34},	        meta: {"change": "1"}	    },	    function(status, response) {	        // handle publish success/fail here	    }	);	</code></pre>		<p>Clients that want all the data would subscribe like normal. But for clients that only want changes, <a href="https://www.pubnub.com/docs/web-javascript/stream-filtering-tutorial#subscribing-with-filtering" rel="nofollow noreferrer">the client would set a filter</a> to only receive messages with that meta-data key set to "1". The client inits PubNub as usual, adds the listener (to receive published messages) and subscribes to the channel <code>topic-cadence</code>, but also sets a filter.</p>		<pre><code>pubnub.setFilterExpression("change=1");	pubnub.subscribe("channels" : ["topic-cadence"]);	</code></pre>		<p>And now this client will only have messages sent to it if the data has changed while the client without the filter will get all data that is published at the regular cadence.</p>		<h2>Wildcard Channels</h2>		<p>Using <a href="https://www.pubnub.com/docs/web-javascript/stream-controller#wildcard-subscribe" rel="nofollow noreferrer">Wildcard Subscribe</a> the solution is very similar to the first. The publisher will publish values on a channel named <code>topic.cadence</code> as long as the data is the same. If the value changes, it will be published to a channel named <code>topic.delta</code>. The dots (<code>.</code>) in the channel names are important because clients will be able to subscribe using a wildcard - the asterisk (<code>*</code>).</p>		<p>Clients that only want changes in the value will subscribe to <code>topic.change</code>.</p>		<pre><code>pubnub.subscribe("channels" : ["topic.change"]);	</code></pre>		<p>And clients that want all of the value in a cadence will subscribe to both of the channels using a wildcard subscribe.</p>		<pre><code>pubnub.subscribe("channels" : ["topic.*"]);	</code></pre>		<p>This just means that data published to any channel that starts with <code>topic.</code> and has some <em>sub-channel</em> name - <code>topic.change</code>, <code>topic.foo</code>, <code>topic.bar</code> - will receive that data.</p>	"
