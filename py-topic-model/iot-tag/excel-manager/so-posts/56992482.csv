thread_ID, Id, ParentId, PostType, Score, CreationDate, OwnerID, Body
56992482,56992482,null,1,0,Thu Jul 11 15:17:00 EDT 2019,11770992,"<p>I am setting up a project that relays wearable device information (in this case, the GearFit2 from samsung) to an MQTT broker, but it is unable to connect to the SSL server. Ultimately, the error I get I traced to SSLSocket_error (within SSLSocket.c), which then has a return value of SSL_ERROR_SSL</p>		<p>The idea came form an implementation by Jiwon Park : <a href="https://craftroom.tizen.org/mqtt/" rel="nofollow noreferrer">https://craftroom.tizen.org/mqtt/</a>. Basically, I have been successful in connecting to a non-SSL server, but not an SSL server (which is intended for this project)</p>		<pre><code>    #define ADDRESS     "ssl://webdemo.edu:8883"	    #define USERNAME "username"	    #define PASSWORD "password"		    void sensor_event_callback(sensor_h sensor, sensor_event_s *event, void *user_data)	    {	        dlog_print(DLOG_DEBUG, LOG_TAG, "callback reached");			        MQTTClient client;	        MQTTClient_connectOptions conn_opts = MQTTClient_connectOptions_initializer;	        MQTTClient_message pubmsg = MQTTClient_message_initializer;	        MQTTClient_deliveryToken token;	        MQTTClient_SSLOptions sslopts = MQTTClient_SSLOptions_initializer;		        signal(SIGINT, cfinish);	        signal(SIGTERM, cfinish);			        rc = MQTTClient_create(&amp;client, ADDRESS, "host", MQTTCLIENT_PERSISTENCE_NONE, NULL);		        conn_opts.keepAliveInterval = 20;	        conn_opts.cleansession = 1;	        conn_opts.username = USERNAME;	        conn_opts.password = PASSWORD;	        conn_opts.ssl = &amp;sslopts;			        if ((rc = MQTTClient_connect(client, &amp;conn_opts)) != MQTTCLIENT_SUCCESS) {	            dlog_print(DLOG_DEBUG, LOG_TAG, "Failed to connect, return code %d\n", rc);	            exit(EXIT_FAILURE);	        }		    ...	    }				// within SSLSocket.c	int SSLSocket_error(char* aString, SSL* ssl, int sock, int rc)	{	    int error;		    FUNC_ENTRY;	    if (ssl)	        error = SSL_get_error(ssl, rc);	    else	        error = ERR_get_error();	    if (error == SSL_ERROR_WANT_READ || error == SSL_ERROR_WANT_WRITE)	    {	        Log(TRACE_MIN, -1, "SSLSocket error WANT_READ/WANT_WRITE");	    }	    else	    {	        static char buf[120];		        if (strcmp(aString, "shutdown") != 0)	            Log(TRACE_MIN, -1, "SSLSocket error %s(%d) in %s for socket %d rc %d errno %d %s\n", buf, error, aString, sock, rc, errno, strerror(errno));	         ERR_print_errors_fp(stderr);	        if (error == SSL_ERROR_SSL || error == SSL_ERROR_SYSCALL){	            dlog_print(DLOG_DEBUG, "sensor", "error val %d", error);	            error = SSL_FATAL;	        }	    }	    FUNC_EXIT_RC(error);	    return error;	}	</code></pre>		<p>The output of MQTTClient_connect(client, &amp;conn_opts)) is -3, which corresponds to SSL_FATAL. As I said earlier, digging deeper into the SSLSocket.c file shows that this return value was because there was something that caused the program to return a SSL_ERROR_SSL error, which isn't traceable to anything else. In a perfect world, the output would be 0 (meaning a success). Could there possibly be a misstep when implementing the library?</p>	"
56992482,100532401,56992482,3,0,Fri Jul 12 02:34:00 EDT 2019,429063,"Try connecting with something else first.  Also take a moment to understand that you are "using" the library, not "implementing" it - implementation was what the *author* of the library did when they created the functionality behind the APIs it provides."
