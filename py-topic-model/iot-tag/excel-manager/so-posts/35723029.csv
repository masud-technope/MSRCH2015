thread_ID, Id, ParentId, PostType, Score, CreationDate, OwnerID, Body
35723029,35723029,null,1,2,Tue Mar 01 12:31:00 EST 2016,3405865,"<p>I have been trying to connect with two different devices with two different BusAttachment objects but I'm getting BusAlreadyExistException?</p>		<p>I'm getting exception at this position </p>		<pre><code>aboutClient.startAboutClient(bus);	</code></pre>		<p>I have tried many methods but couldn't find solution. How can I resolve this issue.	Thanks in advance.</p>	"
35723029,35935171,35723029,2,0,Fri Mar 11 08:09:00 EST 2016,6047973,"<pre><code>I don't know your complete code,so I just give some examples as below,hope you can get something on it.		server:	int main(int argc, char** argv, char** envArg)	{	    signal(SIGINT, SigIntHandler);		    QStatus status = ER_OK;		    s_msgBus = new BusAttachment("myApp", true);		    InterfaceDescription* testIntf = NULL;	    s_msgBus-&gt;CreateInterface(INTERFACE_NAME, testIntf);		    testIntf-&gt;AddMethod("cat", "ss",  "s", "inStr1,inStr2,outStr", 0);		    testIntf-&gt;Activate();		s_msgBus-&gt;RegisterBusListener(s_busListener);		s_msgBus-&gt;Start();		    BasicSampleObject testObj;		    testObj.AddInterface(*testIntf);		    const MethodEntry methodEntries[] = {	            { exampleIntf-&gt;GetMember("cat"), static_cast&lt;MessageReceiver::MethodHandler&gt;(&amp;BasicSampleObject::Cat) }	        };		    testObj.AddMethodHandlers(methodEntries, sizeof(methodEntries) / sizeof(methodEntries[0]));		    s_msgBus-&gt;RegisterBusObject(testObj);		    /*	        link to router,if exist,connect to it and bundled router	        then recieve and send message	    */	    s_msbBus-&gt;Connect();		/*	    start AdvertiseName,three stepsï¼š	    1ã€?request well-known name	    2ã€?creat session	    3ã€?AdvertiseName	*/	    const uint32_t flags = DBUS_NAME_FLAG_REPLACE_EXISTING | DBUS_NAME_FLAG_DO_NOT_QUEUE;	    s_msgBus-&gt;RequestName(SERVICE_NAME, flags);		    const TransportMask SERVICE_TRANSPORT_TYPE = TRANSPORT_ANY;	    SessionOpts opts(SessionOpts::TRAFFIC_MESSAGES, false, SessionOpts::PROXIMITY_ANY, SERVICE_TRANSPORT_TYPE);	    SessionPort sp = SERVICE_PORT;		    QStatus status = s_msgBus-&gt;BindSessionPort(sp, opts, s_busListener);		    s_msgBus-&gt;AdvertiseName(SERVICE_NAME, mask);		    WaitForSigInt();		    delete s_msgBus;	    s_msgBus = NULL;		    printf("Basic service exiting with status 0x%04x (%s).\n", status, QCC_StatusText(status));		    return (int) status;	}		client:	int main(int argc, char** argv, char** envArg)	{	    signal(SIGINT, SigIntHandler);	QStatus status = ER_OK;	g_msgBus = new BusAttachment("myApp", true);	g_msgBus-&gt;CreateInterface(INTERFACE_NAME, testIntf);	testIntf-&gt;AddMethod("cat", "ss",  "s", "inStr1,inStr2,outStr", 0);	testIntf-&gt;Activate();		g_msgBus-&gt;Start();	g_msgBus-&gt;Connect();	static MyBusListener s_busListener;	g_msgBus-&gt;RegisterBusListener(s_busListener);	//same as the server		g_msgBus-&gt;FindAdvertisedName(SERVICE_NAME);		WaitForJoinSessionCompletion();		ProxyBusObject remoteObj(*g_msgBus, SERVICE_NAME, SERVICE_PATH, s_sessionId);	const InterfaceDescription* alljoynTestIntf = g_msgBus-&gt;GetInterface(INTERFACE_NAME);		assert(alljoynTestIntf);		remoteObj.AddInterface(*alljoynTestIntf);		Message reply(*g_msgBus);	MsgArg inputs[2];		inputs[0].Set("s", "Hello ");	inputs[1].Set("s", "World!");		QStatus status = remoteObj.MethodCall(SERVICE_NAME, "cat", inputs, 2, reply, 5000);		if (ER_OK == status) {	    printf("'%s.%s' (path='%s') returned '%s'.\n", SERVICE_NAME, "cat",	           SERVICE_PATH, reply-&gt;GetArg(0)-&gt;v_string.str);		delete g_msgBus;	g_msgBus = NULL;		printf("Basic client exiting with status 0x%04x (%s).\n", status, QCC_StatusText(status));		return (int) status;	}	result:	[server][1]	[client][1] 	</code></pre>	"
