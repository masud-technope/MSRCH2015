thread_ID, Id, ParentId, PostType, Score, CreationDate, OwnerID, Body
41050941,41050941,null,1,1,Thu Dec 08 23:56:00 EST 2016,1611358,"<p>I'm looking at how to design a data format to send sensor data (temperature,gps,accelerometer and others) from a device with microcontroller to a backend service through GSM. </p>		<p>I created a simple JSON HTTP API, but the payload is really heavy and I want something as light as possible to basically improve my device's battery life: save processing time on the device to create the data, reduce the amount of data submitted and the time needed to send those data, etc. </p>		<p>I would send text messages in binary format with MQTT, but how to format the text message? 	I could for example use a CSV format or use fixed amounts of bytes for each sensor.	I could only send sensor data that changed (like if GPS coordinates are the same, I don't send them again. for the date/time, I only send the seconds if rest hasn't moved since previous sensor data).</p>		<p>I was expecting to find a protocol that answers all those needs. <a href="http://www.postscapes.com/internet-of-things-protocols/" rel="nofollow noreferrer">BUT only standards I found are xml/json based</a>. </p>		<p>There is this <a href="http://www.multiwii.com/wiki/index.php?title=Multiwii_Serial_Protocol" rel="nofollow noreferrer">specific protocol used for drones to exchange commands</a>, that we could rework on but my needs are slightly different: I just want to send groups (10x / 100x) of sensor data (taken every few seconds).</p>		<p>Would you know anything that could answer this, so that we don't reinvent the wheel?</p>	"
41050941,69309417,41050941,3,0,Fri Dec 09 00:00:00 EST 2016,3761456,"If it comes down to it, can you not just send the raw data? Maybe with a sentinel value and a couple parity bits? How much data are these sensors generating, it sounds like only a few bytes."
41050941,69341842,41050941,3,1,Fri Dec 09 19:17:00 EST 2016,1611358,"@Monza see Alden's beautiful answer: you can divide by 5 the size of your initial JSON payload :) . I thought the same initially, while I'm a software engineer, and I was told I'm wrong by several hardware engineers ;) those things matter!"
41050941,69341895,41050941,3,0,Fri Dec 09 19:18:00 EST 2016,1611358,"@Iluvatar interesting, didn't know about sentinel values nor parity bits, if you add together all sensor data + date/time I have 40 to 50 chars"
41050941,69309821,41050941,3,0,Fri Dec 09 00:25:00 EST 2016,4443865,"JSON data isn't really THAT more inefficient is it - when compared to it's readability and utility.  Is this an unnecessary optimization? Just my 2c worth :)"
41050941,41064390,41050941,2,0,Fri Dec 09 16:03:00 EST 2016,1433712,"<p>Here are a couple of thoughts:</p>		<p>Skip the HTTP protocol. HTTP sends extra data in the header and since you know what data your device is sending it is unnecessary. Just connect to a TCP server and send your data.</p>		<p>Representing your data in ASCII is inefficient. For example, the number <code>4294967295</code> requires 10 bytes to represent but in binary it only requires 4 bytes.</p>		<p>Without compression, your raw data is the minimum limit on the number of bytes required to successfully send your message. Typically a highly efficient protocol is as simple as a few bits or bytes to describe what kind of data is being sent followed by the data in predefined locations.</p>		<p>What I would suggest, if you are certain that improving your efficiency outweighs the trouble, is define one or several packet formats that is known to your sender and receiver and transmit it over a TCP connection. Looking at the <a href="http://xillybus.com/tutorials/pci-express-tlp-pcie-primer-tutorial-guide-1" rel="nofollow noreferrer">transaction layer for protocols such as PCI Express</a> might help. They are more complected than you need but will give you the general idea, which is to keep it generally pretty simple.</p>		<p>As an example, the following json data consumes 270 bytes plus maybe 50 bytes for the HTTP header:</p>		<pre><code>{"sensor1":{"coordinates":[12345,12345],"time":"2016-12-9T08:50:11"}"sensor2":{"coordinates":[12345,12345],"time":"2016-12-9T08:50:11"}"sensor3":{"coordinates":[12345,12345],"time":"2016-12-9T08:50:11"}"sensor4":{"coordinates":[12345,12345],"time":"2016-12-9T08:50:11"}}	</code></pre>		<p>The same data could be represented with a data stream like so:</p>		<pre><code>number of sensors (1 byte)	sensor1 lat (4 bytes)	sensor1 lng (4 bytes)	sensor1 time (4 bytes)	sensor2 lat (4 bytes)	sensor2 lng (4 bytes)	sensor2 time (4 bytes)	</code></pre>		<p>for a total of 27 bytes, including the full time every transmission.</p>		<p>If you provide what language you are using you may get more help on the actual implementation.</p>	"
41050941,69342056,41064390,3,0,Fri Dec 09 19:24:00 EST 2016,1611358,"thanks @Alden for your answer!	I agree for HTTP, want to get out of it, but still want to use MQTT rather than raw TCP connection. Because in the end I want to use IOT hub solution which handles scaling/authentication/encryption so that I don't waste time on this.		C code on the micro controller, Java spring boot app on the backend side		I'll look at PCI Express and come back to you :)"
41050941,74307572,41064390,3,1,Wed Apr 26 09:04:00 EDT 2017,1611358,"thx for your answers guys!	we used a mix of the propositions from @Alden : define several packet formats for the communication between device and backend + compress data like he offered to do.	since I wanted sthing done super quickly + use standard protocol/framework to be future proof (and I didn't want to risk reinventing the wheel by opening a TCP connection), we put those binaries in the body of an HTTP request, and we'll put it later in the body of a MQTT message"
41050941,41070615,41050941,2,0,Fri Dec 09 23:52:00 EST 2016,469006,"<p>You could use Google's <a href="https://developers.google.com/protocol-buffers/" rel="nofollow noreferrer">Protocol Buffers</a>. This is based on predefined messages containing data fields being sent. The data transfer is binary with some compression. Also fields can be marked as optional, so you may need to send those which have new data since the last message.</p>		<p>One drawback is they there is no framing. You have to implement your own start-of and end-of-message indicators if you are using streaming such as TCP/IP.</p>		<p>The <a href="https://github.com/nanopb/nanopb" rel="nofollow noreferrer">nanopb</a> project can generate code for encoding and decoding messages that will run on microcontrollers.</p>	"
