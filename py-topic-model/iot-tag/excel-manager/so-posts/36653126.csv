thread_ID, Id, ParentId, PostType, Score, CreationDate, OwnerID, Body
36653126,36653126,null,1,13,Fri Apr 15 17:12:00 EDT 2016,3395760,"<p>I have to send UDP packets to a WiFi module (provided with own AP) with no internet connection but when I connect the mobile with the AP, Android redirects my packets on the mobile data interface because it has got internet connection.</p>		<p>I've used the code below to do my job but it seems not working on Android M.</p>		<pre><code>@TargetApi(Build.VERSION_CODES.LOLLIPOP)	private void setWifiInterfaceAsDefault() {	    ConnectivityManager connectivityManager = (ConnectivityManager) getSystemService(Context.CONNECTIVITY_SERVICE);		    NetworkRequest.Builder builder = new NetworkRequest.Builder();	    NetworkRequest networkRequest= builder.addCapability(NetworkCapabilities.NET_CAPABILITY_NOT_RESTRICTED)	            .addTransportType(NetworkCapabilities.TRANSPORT_WIFI)	            .build();		    connectivityManager.requestNetwork(networkRequest, new ConnectivityManager.NetworkCallback());	}	</code></pre>		<p>I've also added</p>		<pre><code>&lt;uses-permission android:name="android.permission.CHANGE_NETWORK_STATE" /&gt;	&lt;uses-permission android:name="android.permission.WRITE_SETTINGS" /&gt;	</code></pre>		<p>on my AndroidManifest.xml and I ensured myself that <code>Settings.System.canWrite(this)</code> returns <code>true</code> but still nothing.</p>		<p>Thanks in advance.</p>	"
36653126,72374521,36653126,3,0,Mon Mar 06 10:28:00 EST 2017,1685748,"@AleMuzzi I have a similar question would you mind giving more information on your generate_204 workaround as i can make changes to the device  http://stackoverflow.com/q/42492136/1685748"
36653126,72515278,36653126,3,0,Thu Mar 09 13:32:00 EST 2017,3395760,"@Lonergan6275 Sorry, I think I've not understood your question but if I have understood, I can tell you that OpenWRT provides itself a DNS server, that's why you have an hosts file containing the well known hosts (with static IP) so, hoping that google will not change the internet check system, adding those addresses will be enough"
36653126,72434647,36653126,3,0,Tue Mar 07 17:19:00 EST 2017,3395760,"@Lonergan6275 Different OS (it also depends on OS version) checks internet connections in different ways; Android asks some google servers a void file called "generate_204" to ensure that the current net has internet connection.	If you can provide that file to your device, it will show you that there is an internet connection.		Checked urls are:	- "connectivitycheck.gstatic.com"	- "clients3.google.com"		Anyway, you can see what effectively your device does tracking its packets with "tPacketCapture" app and WireShark"
36653126,72509079,36653126,3,0,Thu Mar 09 10:53:00 EST 2017,1685748,"@AleMuzzi Thank you very much I dont know a lot on the IOT Device side but will editing the hosts be sufficient as we would have push it in an update to many devices. or is the DNS Server a requirement?"
36653126,72464119,36653126,3,0,Wed Mar 08 11:13:00 EST 2017,1685748,"@AleMuzzi so how do i point `connectivitycheck.gstatic.com` - `clients3.google.com` to the web root of my iot device where i can place the `generate_204` file"
36653126,72479898,36653126,3,0,Wed Mar 08 17:17:00 EST 2017,3395760,"@Lonergan6275 generate_204 has to be put in the root of your http server in the IoT device and you have to have a dos server on the device that provides those urls, for example if you are using openwrt as IoT OS you will have a file named "hosts" under /etc, add the following lines: 10.1.1.1 connectivitycheck.gstatic.com	10.1.1.1 clients3.google.com.	Where 10.1.1.1 is your "127.0.0.1" IoT address"
36653126,72480052,36653126,3,0,Wed Mar 08 17:20:00 EST 2017,3395760,"I know it's really ugly written like this, sorry"
36653126,66454123,36653126,3,0,Mon Sep 19 11:39:00 EDT 2016,137893,"Thanks, but unfortunately that is not an option for me. IoT device is not in my control."
36653126,66312778,36653126,3,0,Wed Sep 14 18:50:00 EDT 2016,137893,"My friend did you figure out a solution? I have the exact requirement."
36653126,66449839,36653126,3,0,Mon Sep 19 09:44:00 EDT 2016,3395760,"I have done a workaround simulating a connection on the IoT device to let Android think that the IoT device had a connection. You can do that placing a void file called generate_204 on the server root and adding some urls to your server dns. I know it's a weird workaround but for me worked. Hope I've helped you."
36653126,66516875,36653126,3,0,Tue Sep 20 21:42:00 EDT 2016,3395760,"If you'll find a real solution, please let us know ✌"
36653126,42906401,36653126,2,9,Mon Mar 20 14:36:00 EDT 2017,6537014,"<p>Bind the network using ConnectivityManager.setProcessDefaultNetwork() prevents roaming and allows for full TCP access. Thus, within the onAvailable() callback you could bind the application process to that network rather than opening a connection to a particular URL.</p>		<pre><code>ConnectivityManager connection_manager = 	(ConnectivityManager) activity.getApplication().getSystemService(Context.CONNECTIVITY_SERVICE);		NetworkRequest.Builder request = new NetworkRequest.Builder();	request.addTransportType(NetworkCapabilities.TRANSPORT_WIFI);		connection_manager.registerNetworkCallback(request.build(), new NetworkCallback() {		    @Override	    public void onAvailable(Network network) {	        ConnectivityManager.setProcessDefaultNetwork(network);	    }	}	</code></pre>		<p><a href="https://stackoverflow.com/a/27958106">Original answer</a></p>	"
36653126,90333253,42906401,3,0,Sat Aug 04 12:34:00 EDT 2018,1906721,"thanks @Stanislav, great solutions. Its working for mashmallow and Naugat as well."
36653126,99745157,42906401,3,0,Thu Jun 13 15:09:00 EDT 2019,922929,"You really saved my day. thanks a lot. this works in Android P also. I will later try implement Ryan's code also if required."
36653126,51469732,36653126,2,9,Sun Jul 22 22:24:00 EDT 2018,904907,"<p><a href="https://stackoverflow.com/users/6537014/stanislav-serdyuk">Stanislav</a>'s answer is correct but incomplete because only works in Lollipop.</p>		<p>I've wrote a complete solution for Lollipop and Marshmallow onwards for you to route all network requests through WiFi when connected to a specific network of your choice.</p>		<hr>		<h1>Kotlin</h1>		<p>In your Activity,</p>		<pre><code>@RequiresApi(Build.VERSION_CODES.LOLLIPOP)	class RoutingActivity : Activity() {		    private var mConnectivityManager: ConnectivityManager? = null	    private var mNetworkCallback: ConnectivityManager.NetworkCallback? = null	    //...		    override fun onCreate(savedInstanceState: Bundle?) {	        //...	        routeNetworkRequestsThroughWifi("Access-Point-SSID-You-Want-To-Route-Your-Requests")	    }	</code></pre>		<h3>Route future network requests from application through WiFi (even if given WiFi network is without internet and mobile data has internet connection)</h3>		<pre><code>/**	 * This method sets a network callback that is listening for network changes and once is	 * connected to the desired WiFi network with the given SSID it will bind to that network.	 *	 * Note: requires android.permission.INTERNET and android.permission.CHANGE_NETWORK_STATE in	 * the manifest.	 *	 * @param ssid The name of the WiFi network you want to route your requests	 */	private fun routeNetworkRequestsThroughWifi(ssid: String) {	    mConnectivityManager = getSystemService(Context.CONNECTIVITY_SERVICE) as ConnectivityManager		    // ensure prior network callback is invalidated	    unregisterNetworkCallback(mNetworkCallback)		    // new NetworkRequest with WiFi transport type	    val request = NetworkRequest.Builder()	            .addTransportType(NetworkCapabilities.TRANSPORT_WIFI)	            .build()		    // network callback to listen for network changes	    mNetworkCallback = object : ConnectivityManager.NetworkCallback() {		        // on new network ready to use	        override fun onAvailable(network: Network) {		            if (getNetworkSsid(this@RoutingActivity).equals(ssid, ignoreCase = false)) {	                releaseNetworkRoute()	                createNetworkRoute(network)		            } else {	                releaseNetworkRoute()	            }	        }	    }	    mConnectivityManager?.requestNetwork(request, mNetworkCallback)	}	</code></pre>		<h3>Unregister network callback</h3>		<pre><code>private fun unregisterNetworkCallback(networkCallback: ConnectivityManager.NetworkCallback?) {	    if (networkCallback != null) {	        try {	            mConnectivityManager?.unregisterNetworkCallback(networkCallback)		        } catch (ignore: Exception) {	        } finally {	            mNetworkCallback = null	        }	    }	}	</code></pre>		<h3>Create network route</h3>		<pre><code>private fun createNetworkRoute(network: Network): Boolean? {	    var processBoundToNetwork: Boolean? = false	    when {	    // 23 = Marshmallow	        Build.VERSION.SDK_INT &gt;= 23 -&gt; {	            processBoundToNetwork = mConnectivityManager?.bindProcessToNetwork(network)	        }		    // 21..22 = Lollipop	        Build.VERSION.SDK_INT in 21..22 -&gt; {	            processBoundToNetwork = ConnectivityManager.setProcessDefaultNetwork(network)	        }	    }	    return processBoundToNetwork	}	</code></pre>		<h3> Release network route</h3>		<pre><code>private fun releaseNetworkRoute(): Boolean? {	    var processBoundToNetwork: Boolean? = false	    when {	    // 23 = Marshmallow	        Build.VERSION.SDK_INT &gt;= 23 -&gt; {	            processBoundToNetwork = mConnectivityManager?.bindProcessToNetwork(null)	        }		    // 21..22 = Lollipop	        Build.VERSION.SDK_INT in 21..22 -&gt; {	            processBoundToNetwork = ConnectivityManager.setProcessDefaultNetwork(null)	        }	    }	    return processBoundToNetwork	}	</code></pre>		<h3>Helper</h3>		<pre><code>private fun getNetworkSsid(context: Context?): String {	    // WiFiManager must use application context (not activity context) otherwise a memory leak can occur	    val mWifiManager = context?.applicationContext?.getSystemService(Context.WIFI_SERVICE) as WifiManager	    val wifiInfo: WifiInfo? = mWifiManager.connectionInfo	    if (wifiInfo?.supplicantState == SupplicantState.COMPLETED) {	        return wifiInfo.ssid.removeSurrounding("\"")	    }	    return ""	}	</code></pre>	"
36653126,89907974,51469732,3,1,Sun Jul 22 22:45:00 EDT 2018,904907,"More information about this can be found here: https://android-developers.googleblog.com/2016/07/connecting-your-app-to-wi-fi-device.html"
36653126,97386116,51469732,3,1,Mon Mar 25 01:29:00 EDT 2019,78356,"You should consider putting up your own blog post about this; this remains an under-documented topic with a steady stream of SO questions, and your writeup here and at https://stackoverflow.com/a/51470122/78356 provide a much more complete and useful picture than the googleblog post"
36653126,97464074,51469732,3,1,Wed Mar 27 06:06:00 EDT 2019,78356,"Thanks @ryan-amaral, that is indeed very kind.  Let me see what I can do!"
36653126,97454470,51469732,3,0,Tue Mar 26 20:07:00 EDT 2019,904907,"Much appreciated for your positive feedback @mikeh! Feel free to write an article yourself with this content and I kindly volunteer to review it before you publish it."
36653126,100025691,51469732,3,0,Mon Jun 24 09:13:00 EDT 2019,3906919,"mConnectivityManager?.bindProcessToNetwork(null)  - this line did it for me."
36653126,99737384,51469732,3,1,Thu Jun 13 11:50:00 EDT 2019,3969585,"WORKS :), THANKS YOU SAVE MY DAY"
