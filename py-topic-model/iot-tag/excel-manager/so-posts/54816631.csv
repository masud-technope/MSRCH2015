thread_ID, Id, ParentId, PostType, Score, CreationDate, OwnerID, Body
54816631,54816631,null,1,1,Thu Feb 21 21:37:00 EST 2019,3990158,"<p>I have a <code>Qt</code> application on an embedded Linux without <code>X</code>. I would like to see the screen remotely and I cannot use <code>VNC</code> or other solutions. Therefore,  I am implementing it myself. I need to send a framebuffer to a remote server when there is a change on the framebuffer. What I do is to continuously copying the framebuffer (<code>fb0.raw</code>) and check if it is different from the previously copied framebuffer(<code>fb0_old.raw</code>) and if they are different then I send the framebuffer. Here is the pseudo code of what I am doing:</p>		<pre><code>cp /dev/fb0 /fb0.raw	if (diff -q fb0_old.raw fb0.raw) != "":	   send(fb0.raw)	   mv fb0.raw fb0_old.raw	</code></pre>		<p>This code takes almost <code>0.5</code> seconds to execute on my embedded linux and if the network delay and time for other prosses added to this, then it becomes too slow. Is there a faster way to check if the framebuffer has changed without continuously copying it? 	It doesn't matter if it is in kernel or user space or if this is a pure <code>C</code> or <code>bash</code> or ..</p>	"
54816631,96426098,54816631,3,1,Fri Feb 22 11:04:00 EST 2019,524368,"diff is probably not the right tool for the task, since it tries to generate a "patch". If your goal is just sending the framebuffer, pipe it through some high efficiency video encoder; among the first steps is discarding all those parts in an image, that didn't change. Then just stream the resulting video to the remote machine."
54816631,96435201,54816631,3,0,Fri Feb 22 15:20:00 EST 2019,453616,"Remember to configure these codecs for low latency operation. It can have a huge effect."
54816631,96426256,54816631,3,0,Fri Feb 22 11:09:00 EST 2019,3990158,"@datenwolf thanks for the help. I have zero experience with high efficiency video encoders, could you please just name a few of them?"
54816631,96426359,54816631,3,1,Fri Feb 22 11:12:00 EST 2019,524368,"h264, VP9/WebP, etc. Just the standard stuff you'd normally use for regular video files. You can use regular ffmpeg as a frontend. Use the `image2` input format, configure size and pixel format to match the fbdev configuration, read from stdin, where you simply pipe in the contents of fb0 in a loop."
