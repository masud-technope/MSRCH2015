thread_ID, Id, ParentId, PostType, Score, CreationDate, OwnerID, Body
41852603,41852603,null,1,0,Wed Jan 25 13:16:00 EST 2017,7448326,"<p>I am trying to run the below code I am getting EOFException. The below is my output</p>		<pre><code>Connected to ssl://REMOVED.messaging.internetofthings.ibmcloud.com:8883		.deliveryComplete() entered	Data published on topic iot-2/type/loradevice/id/cdef1234/cmd/cid/fmt/json and the msg is{"count":0,"cmd":"reset","time":"2017-01-25 18:38:34"}	connection true		Connection lost (32109) - java.io.EOFException	at org.eclipse.paho.client.mqttv3.internal.CommsReceiver.run(CommsReceiver.java:146)	at java.lang.Thread.run(Thread.java:745)	Caused by: java.io.EOFException	at java.io.DataInputStream.readByte(DataInputStream.java:267)	at org.eclipse.paho.client.mqttv3.internal.wire.MqttInputStream.readMqttWireMessage(MqttInputStream.java:65)	at org.eclipse.paho.client.mqttv3.internal.CommsReceiver.run(CommsReceiver.java:107)	... 1 more	</code></pre>		<p>The code is below</p>		<pre><code>package com.ibm.bluemixmqtt;		import java.text.SimpleDateFormat;	import java.util.Date;	import java.util.Properties;	import java.util.regex.Matcher;	import java.util.regex.Pattern;		import org.apache.commons.json.JSONException;	import org.apache.commons.json.JSONObject;	import org.eclipse.paho.client.mqttv3.IMqttDeliveryToken;	import org.eclipse.paho.client.mqttv3.MqttCallback;	import org.eclipse.paho.client.mqttv3.MqttClient;	import org.eclipse.paho.client.mqttv3.MqttConnectOptions;	import org.eclipse.paho.client.mqttv3.MqttException;	import org.eclipse.paho.client.mqttv3.MqttMessage;	import org.eclipse.paho.client.mqttv3.MqttPersistenceException;		public class AppTest2	{		    private MqttHandler1 handler;		    /**	     * @param args	     */	    public static void main(String[] args)	    {	        new AppTest2().doApp();	    }		    /**	     * Run the app	     */	    public void doApp()	    {	        // Read properties from the conf file	        Properties props = MqttUtil.readProperties("Mydata\\app.conf");		        String org = "REMOVED";	        String id = "REMOVED";	        String authmethod = "REMOVED";	        String authtoken = "REMOVED";		        // isSSL property	        String sslStr = props.getProperty("isSSL");	        boolean isSSL = false;	        if (sslStr.equals("T")) {	            isSSL = true;	        }		        System.out.println("org: " + org);	        System.out.println("id: " + id);	        System.out.println("authmethod: " + authmethod);	        System.out.println("authtoken" + authtoken);	        System.out.println("isSSL: " + isSSL);		        // Format: a:&lt;orgid&gt;:&lt;app-id&gt;	        String clientId = "a:" + org + ":" + id;	        String serverHost = org + MqttUtil.SERVER_SUFFIX;		        handler = new MqttHandler1();	        handler.connect(serverHost, clientId, authmethod, authtoken, isSSL);	        publish();	    }		    public void publish(){	        JSONObject jsonObj = new JSONObject();	        String deviceid = "cdef1234";	        try {	            jsonObj.put("cmd", "reset");	            jsonObj.put("count", 0);	            jsonObj.put("time", new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(new Date()));	        } catch (JSONException e) {	            e.printStackTrace();	        }	        handler.publish(	                "iot-2/type/" + MqttUtil.DEFAULT_DEVICE_TYPE + "/id/" + deviceid + "/cmd/" + MqttUtil.DEFAULT_CMD_ID + "/fmt/json",	                jsonObj.toString(), false, 0);		    }	}		class MqttHandler1 implements MqttCallback	{	    private final static String DEFAULT_TCP_PORT = "1883";	    private final static String DEFAULT_SSL_PORT = "8883";		    private MqttClient client = null;		    public MqttHandler1()	    {		    }		    @Override	    public void connectionLost(Throwable throwable)	    {	        if (throwable != null) {	            System.out.println("Error3");	            throwable.printStackTrace();	        }	    }		    @Override	    public void deliveryComplete(IMqttDeliveryToken iMqttDeliveryToken)	    {	        System.out.println(".deliveryComplete() entered");	    }		    @Override	    public void messageArrived(String topic, MqttMessage mqttMessage) throws Exception	    {	        String payload = new String(mqttMessage.getPayload());	        System.out.println(".messageArrived - Message received on topic " + topic + ": message is " + payload);	    }		    public void connect(String serverHost, String clientId, String authmethod, String authtoken, boolean isSSL)	    {	        // check if client is already connected	        if (!isMqttConnected()) {	            String connectionUri = null;		            // tcp://&lt;org-id&gt;.messaging.internetofthings.ibmcloud.com:1883	            // ssl://&lt;org-id&gt;.messaging.internetofthings.ibmcloud.com:8883	            if (isSSL) {	                connectionUri = "ssl://" + serverHost + ":" + DEFAULT_SSL_PORT;	            } else {	                connectionUri = "tcp://" + serverHost + ":" + DEFAULT_TCP_PORT;	            }		            if (client != null) {	                try {	                    client.disconnect();	                } catch (MqttException e) {	                    e.printStackTrace();	                }	                client = null;	            }		            try {	                client = new MqttClient(connectionUri, clientId);	            } catch (MqttException e) {	                e.printStackTrace();	            }		            client.setCallback(this);		            // create MqttConnectOptions and set the clean session flag	            MqttConnectOptions options = new MqttConnectOptions();	            options.setCleanSession(true);		            options.setUserName(authmethod);	            options.setPassword(authtoken.toCharArray());	            options.setKeepAliveInterval(2000);		            // If SSL is used, do not forget to use TLSv1.2	            if (isSSL) {	                java.util.Properties sslClientProps = new java.util.Properties();	                sslClientProps.setProperty("com.ibm.ssl.protocol", "TLSv1.2");	                options.setSSLProperties(sslClientProps);	            }		            try {	                // connect	                client.connect(options);	                System.out.println("Connected to " + connectionUri);	            } catch (MqttException e) {	                e.printStackTrace();	            }		        }		    }		    public void disconnect()	    {		        // check if client is actually connected	        if (isMqttConnected()) {	            try {	                // disconnect	                client.disconnect();	            } catch (MqttException e) {	                e.printStackTrace();	            }	        }	    }		    public void subscribe(String topic, int qos)	    {		        // check if client is connected	        if (isMqttConnected()) {	            try {	                client.subscribe(topic, qos);	                System.out.println("Subscribed: " + topic);		            } catch (MqttException e) {	                e.printStackTrace();	            }	        } else {	            connectionLost(null);	        }	    }		    public void unsubscribe(String topic)	    {	        // check if client is connected	        if (isMqttConnected()) {	            try {		                client.unsubscribe(topic);	            } catch (MqttException e) {	                e.printStackTrace();	            }	        } else {	            connectionLost(null);	        }	    }	    public void publish(String topic, String message, boolean retained, int qos)	    {	        // check if client is connected	        if (isMqttConnected()) {	            // create a new MqttMessage from the message string	            MqttMessage mqttMsg = new MqttMessage(message.getBytes());	            // set retained flag	            mqttMsg.setRetained(retained);	            // set quality of service	            mqttMsg.setQos(qos);	            try {	                client.publish(topic, mqttMsg);	                System.out.println("Data published on topic " + topic + " and the msg is" + mqttMsg);	                System.out.println("connection "+client.isConnected());	            } catch (MqttPersistenceException e) {	                System.out.println("Error1");	                e.printStackTrace();	            } catch (MqttException e) {	                System.out.println("Error1");	                e.printStackTrace();	            }	        } else {	            connectionLost(null);	        }	    }		    private boolean isMqttConnected()	    {	        boolean connected = false;	        try {	            if ((client != null) &amp;&amp; (client.isConnected())) {	                connected = true;	            }	        } catch (Exception e) {	            // swallowing the exception as it means the client is not connected	        }	        return connected;	    }		}	</code></pre>		<p>Any one help me on this.</p>		<p>Thanks in adavance.</p>	"
41852603,70897268,41852603,3,0,Wed Jan 25 16:32:00 EST 2017,2117239,"I have edited your question to remove all of your authentication tokens. Given you have already published them to the world, I suggest you go create yourself some new tokens before someone accesses your IoT Platform organisation."
41852603,41854452,41852603,2,0,Wed Jan 25 14:45:00 EST 2017,6240537,"<p>the EOFException might indicates that the clientID is reused and the access is blocked... make sure that you only call once the connect method... possibly use only the SSL or non-SSL connection sequence </p>	"
