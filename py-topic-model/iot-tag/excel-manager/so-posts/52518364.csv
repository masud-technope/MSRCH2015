thread_ID, Id, ParentId, PostType, Score, CreationDate, OwnerID, Body
52518364,52518364,null,1,0,Wed Sep 26 13:00:00 EDT 2018,7915196,"<p>I have an IoT Project which is: </p>		<ul>	<li>2 bulbs, connect to 2 Raspberry Pi (python)</li>	<li>web app (Javascript) with 3 buttons: one to turn on/off bulb 1, one to turn on/off bulb 2, one to turn on/off both bulbs.</li>	</ul>		<p>I approached 2 different ways </p>		<h2>using AWSIoTMQTTClient:</h2>		<ol>	<li><p>Pi:</p>		<pre><code> class CallbackContainer(object):		    def __init__(self, client):	        self._client = client		    def messagePrint(self, client, userdata, message):	        print("Received a new message: ")	        print(message.payload)	        print("from topic: ")	        print(message.topic)	        print("--------------\n\n")			myAWSIoTMQTTClient = AWSIoTMQTTClient("myClientID")	myAWSIoTMQTTClient.configureEndpoint("xxxxx.iot.eu-west-1.amazonaws.com", 8883)	myAWSIoTMQTTClient.configureCredentials("./certs/rootCA.pem", "./certs/xxxxxxx-private.pem.key", "./certs/xxxxxxx-certificate.pem.crt")	myAWSIoTMQTTClient.configureConnectDisconnectTimeout(10)  # 10 sec	myAWSIoTMQTTClient.configureMQTTOperationTimeout(5)  # 5 sec	myCallbackContainer = CallbackContainer(myAWSIoTMQTTClient)		myAWSIoTMQTTClient.connect()		myAWSIoTMQTTClient.subscribe("topic_both", 0, myCallbackContainer.messagePrint)	myAWSIoTMQTTClient.subscribe("topic_bulb1", 0, myCallbackContainer.messagePrint)		while True:	   time.sleep(1)	</code></pre></li>	<li><p>Javascript:</p>		<pre><code>var params = {	    payload: JSON.stringify(body),	    topic: myTopic, //"topic_both" or "topic_bulb1"	    qos: 0 	};			var iotPromise = iotData.publish(params).promise();	</code></pre></li>	</ol>		<h2>using AWSIoTShadowClient:</h2>		<ol>	<li><p>Pi: </p>		<pre><code>def customShadowCallback_Delta(payload, responseStatus, token):		   print(responseStatus)	   payloadDict = json.loads(payload)	   print("++++++++DELTA++++++++++")	   print("property: " + str(payloadDict["state"]))	   print("+++++++++++++++++++++++\n\n")	   #Need to handle JSON to control bulbs		thingName = "control_bulb"		myAWSIoTMQTTShadowClient = AWSIoTMQTTShadowClient("myClientID")	myAWSIoTMQTTShadowClient.configureEndpoint("xxxxxx.iot.eu-west-1.amazonaws.com", 8883)	myAWSIoTMQTTShadowClient.configureCredentials("/certs/rootCA.pem", "/certs/xxxxx-private.pem.key", "/certs/xxxxx-certificate.pem.crt")	myAWSIoTMQTTShadowClient.configureConnectDisconnectTimeout(10)  # 10 sec	myAWSIoTMQTTShadowClient.configureMQTTOperationTimeout(5)  # 5 sec		myAWSIoTMQTTShadowClient.connect()			deviceShadowHandler = myAWSIoTMQTTShadowClient.createShadowHandlerWithName(thingName, True)	deviceShadowHandler.shadowRegisterDeltaCallback(customShadowCallback_Delta)			while True:	   time.sleep(1)	</code></pre></li>	<li><p>JavaScript:</p>		<pre><code>var params = {	   payload: '{"state":{"desired":' + JSON.stringify(body) + '}}',	   thingName: 'control_bulb'	};			iotData.updateThingShadow(params, function(err, data) {	}	</code></pre></li>	</ol>		<p>Both approaches manage to achieve the purpose of the project. However, my questions : </p>		<ul>	<li>What different between AWSIoTMQTTClient vs AWSIoTShadowClient in terms of performance, security, maintenance?</li>	<li>In which use-case, is AWSIoTShadowClient or AWSIoTMQTTClient used?</li>	</ul>		<p>Thanks</p>	"
52518364,52913854,52518364,2,2,Sun Oct 21 09:31:00 EDT 2018,2531132,"<p>The two different clients represent two different (albeit superficially similar) features of AWS IoT: </p>		<ul>	<li><code>AWSIoTMQTTClient</code> provides a general interface to AWS IoT's MQTT broker. All it does is allow you to send and receive messages across topics. In fact, if you really wanted to you could use any MQTT client for this (for example Paho MQTT), but I would stick to AWS' as it is ready-configured for their broker.</li>	<li><code>AWSIoTShadowClient</code> is an interface specifically for the AWS IoT Device Shadow. The device shadow is an AWS-managed, per-decice, two-way synchronized 'state'. It just so happens that <em>one</em> way of interacting with the shadow is MQTT. But the aim isn't just to send/receive messages, it's to provide a mechanism for devices to persist and take their state from the cloud. <a href="https://docs.aws.amazon.com/iot/latest/developerguide/iot-device-shadows.html" rel="nofollow noreferrer">(more specifics here)</a></li>	</ul>		<p>So to address your question:</p>		<ul>	<li><p><strong>Performance</strong>: both use the same underlying protocol and so have similar performance. At a push <code>AWSIoTMQTTClient</code> could perform better if you specialised it to your own usage, rather than following the Device Shadow pattern; but I would expect any gains to be negligible.</p></li>	<li><p><strong>Security</strong>: once again both are secured in exactly the same way using AWS IoT's client/certificate security model. <code>AWSIoTShadowClient</code> is likely more secure by default as it is already configured to ensure that only a device can set it's reported state.</p></li>	<li><p><strong>Maintenance</strong>: This depends a bit. If your use case (discussed next) is to have device report its state, and have that state inspectable and updatable from the cloud, then the <code>AWSIoTShadowClient</code> is much more maintainable; simply because that is what it's designed and tested to do- you'll have to write and maintain less of your own code!</p></li>	</ul>		<p>Picking an approach:</p>		<ul>	<li><p><strong>Device Shadow</strong>: If you don't have a reason no to, use the shadow. It's a managed and well tested pattern (that includes edge cases, such as the blub being offline when you request it to change) for having your devices send send/receive/synchronize state from the cloud. It's built into AWS so you can easily view/change this state in the console. It's also got built-in persistence, so you can always inspect that latest state even if you aren't constantly listening for changes on the broker.</p></li>	<li><p><strong>Your own MQTT topics</strong>: There's a few reasons not to use the shadow. The shadow requires you to send JSON payloads, and in highly battery/network constrained situations you might want to use your own binary protocol to save bytes. Similarly it's about double the cost (although still really cheap). Finally if you readings are fast moving, write-only, telemetries that you do not need to persist and can subscribe to when you're interested, you might skip the shadow because you don't need any of its features.</p></li>	</ul>		<p>So in your case, I would say you want to use the shadow.</p>	"
52518364,92764457,52913854,3,0,Mon Oct 22 10:50:00 EDT 2018,7915196,"Thanks for full response ! Very Helpful"
52518364,102376573,52913854,3,0,Wed Sep 18 01:29:00 EDT 2019,8011128,"I have been looking for this explanation for three days. Thank you."
