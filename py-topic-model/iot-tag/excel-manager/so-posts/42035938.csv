thread_ID, Id, ParentId, PostType, Score, CreationDate, OwnerID, Body
42035938,42035938,null,1,0,Sat Feb 04 02:47:00 EST 2017,1691782,"<p>I have been having a horrible problem with trying to get this socket on the raspberry pi to correctly communicate to the PC socket. It is a TCP client-to-server setup. Both are running .net C# applications to do the communication. The main issue is not the connection, but when I send info from the raspberry pi to the computer, the computer only gets the info when I shutdown the raspberry... I believe it has to do with caching, but how would I fix this? Just a fair warning I am not well verse with sockets.</p>		<p>the Raspberry Pi Client Code:</p>		<pre><code>    using System;	    using System.Collections.Generic;	    using System.Linq;	    using System.Net;	    using System.Text;	    using System.Threading.Tasks;	    using System.Net.Sockets;	    using Windows.UI.ViewManagement;	    using System.Net.Sockets;	    using Windows.Web.Http;	    using Windows.Devices.Gpio;	    using Windows.Networking;	    using Windows.Networking.Sockets;	    using Windows.Storage.Streams;	    using System.Threading;	    using System.Runtime.InteropServices;		namespace raspberrypipad	{	class TCPclient_Client	{		    private string _ip;	    private  int _port;	    private Socket _socket;	    private DataWriter _writer;	    private DataReader _reader;		    public delegate void Error(string message);	    public event Error OnError;		    public delegate void DataRecived(string data);	    public event DataRecived OnDataRecived;		    public string Ip	    {	        get { return _ip; }	        set { _ip = value; }	    }		    public int Port	    {	        get { return _port; }	        set { _port = value; }	    }		    private static ManualResetEvent _clientDone = new ManualResetEvent(false);	    const int TIMEOUT_MILLISECONDS = 1000;	    public async void Connect(string devicename, string pin_number, string get_portNumber, string current_ip)	    {	        try	        {	            if (Port == 0)	            {	                _port = 4444;	            }		            string result = string.Empty;		            DnsEndPoint hostEntry = new DnsEndPoint(Ip, Port);	            var hostName = new HostName(Ip);	            _socket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);	            SocketAsyncEventArgs socketEventArg = new SocketAsyncEventArgs();	            socketEventArg.RemoteEndPoint = hostEntry;		            // Inline event handler for the Completed event.	            // Note: This event handler was implemented inline in order to make this method self-contained.	            socketEventArg.Completed += new EventHandler&lt;SocketAsyncEventArgs&gt;(delegate (object s, SocketAsyncEventArgs e)	            {	                // Retrieve the result of this request	                result = e.SocketError.ToString();		                // Signal that the request is complete, unblocking the UI thread	                _clientDone.Set();	            });		            _clientDone.Reset();		            // Make an asynchronous Connect request over the socket	            _socket.ConnectAsync(socketEventArg);	            _socket.AcceptAsync(socketEventArg);	            // Block the UI thread for a maximum of TIMEOUT_MILLISECONDS milliseconds.	            // If no response comes back within this time then proceed	            _clientDone.WaitOne(TIMEOUT_MILLISECONDS);	            _socket.NoDelay = true;			        }	        catch (Exception ex)	        {	            //ignore	        }	    }				    public string Send(string data)	    {			        string response = "Operation Timeout";		        // We are re-using the _socket object initialized in the Connect method	        if (_socket != null)	        {		            // Create SocketAsyncEventArgs context object	            SocketAsyncEventArgs socketEventArg = new SocketAsyncEventArgs();		            // Set properties on context object	            socketEventArg.RemoteEndPoint = _socket.RemoteEndPoint;	            socketEventArg.UserToken = null;		            // Inline event handler for the Completed event.	            // Note: This event handler was implemented inline in order 	            // to make this method self-contained.	            socketEventArg.Completed += new EventHandler&lt;SocketAsyncEventArgs&gt;(delegate (object s, SocketAsyncEventArgs e)	            {	                response = e.SocketError.ToString();	                e.Dispose();	                // Unblock the UI thread	                _clientDone.Set();	            });		            // Add the data to be sent into the buffer	            byte[] payload = Encoding.UTF8.GetBytes(data);	            socketEventArg.SetBuffer(payload, 0, payload.Length);			            // Sets the state of the event to nonsignaled, causing threads to block	            _clientDone.Reset();		            // Make an asynchronous Send request over the socket	            _socket.SendBufferSize = payload.Length;	            _socket.SendToAsync(socketEventArg);		            // _socket.Shutdown(SocketShutdown.Send);		                            // Block the UI thread for a maximum of TIMEOUT_MILLISECONDS milliseconds.	            // If no response comes back within this time then proceed	            _clientDone.WaitOne(TIMEOUT_MILLISECONDS);	        }	        else	        {	            response = "Socket is not initialized";	        }		        return response;	    }		    public void close()	    {	        _socket.Dispose();	    }	}	}	</code></pre>		<p>The server code for the computer is a little confusing, I know it works because other programs could send data to it in other languages... here is the code:</p>		<pre><code>        public TcpServerCode(int port)	    {	        _server = new TcpListener(IPAddress.Any, port);	        _server.Start();		        _isRunning = true;		        if (!Directory.Exists(Environment.CurrentDirectory + "\\serverCOM"))	            Directory.CreateDirectory(Environment.CurrentDirectory + "\\serverCOM");			        var th = new Thread(LoopClients);	        th.Start();	    }		    public void LoopClients()	    {	        while (_isRunning)	            try	            {	                // wait for client connection	                var newClient = _server.AcceptTcpClient();			                // client found.	                // create a thread to handle communication	                var t = new Thread(HandleClient);	                var ch = new clientHolder();	                ch.generateRandomName();	                ch._tcp = newClient;	                clientHolderList.Add(ch);	                t.Start(ch);	            }	            catch (Exception i)	            {	                Log.handleException(i);	            }	    }		    public void HandleClient(object obj)	    {	        // retrieve client from parameter passed to thread	        var client = (clientHolder) obj;		        // sets two streams	        //StreamWriter sWriter = new StreamWriter(client._tcp.GetStream(), Encoding.ASCII);	        var ns = client._tcp.GetStream();	        client._tcp.GetStream().ReadTimeout = 100;	        var sReader = new StreamReader(client._tcp.GetStream(), Encoding.ASCII);		        // you could use the NetworkStream to read and write, 	        // but there is no forcing flush, even when requested		        var bClientConnected = true;	        string sData = null;		        Task getter = null;	        Task sender = null;	        while (bClientConnected)	            if (getter != null)	            {	                if (getter.IsCompleted)	                    getter = _get(sReader, client.clientName);	            }	            else	            {	                getter = _get(sReader, client.clientName);	            }	    }	    private static async Task _get(StreamReader reader, string clientName)	    {	        string sData = null;	        sData = await reader.ReadLineAsync();	        reader.DiscardBufferedData();			        Console.WriteLine(sData);	        // shows content on the console.	        if (sData != null)	            try	            {	                if (File.Exists(Environment.CurrentDirectory + "\\serverCOM\\" + clientName + "_get.txt"))	                    File.Delete(Environment.CurrentDirectory + "\\serverCOM\\" + clientName + "_get.txt");	                File.WriteAllText(Environment.CurrentDirectory + "\\serverCOM\\" + clientName + "_get.txt", sData);	            }	            catch (Exception i)	            {	                Log.handleException(i);	            }	    }	</code></pre>		<p>I am assuming it is something simple to change on one of the programs, thank you in advance!</p>	"
42035938,71265020,42035938,3,0,Sat Feb 04 21:47:00 EST 2017,2852624,"That's a bit too much to analyze for me in detail. But a general tip: Prefer the `.SendAsync` & `.ReceiveAsync` methods of `Socket` (or `.WriteAsync` and `.ReadAsync` of `NetworkStream`) of the `SocketAsyncEventArgs` based methods. The new APIs should be easier to use."
42035938,71383923,42035938,3,0,Wed Feb 08 07:52:00 EST 2017,6601582,"Have you check the [StreamSocket](https://github.com/Microsoft/Windows-universal-samples/tree/master/Samples/StreamSocket) sample ?"
