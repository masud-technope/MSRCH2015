thread_ID, Id, ParentId, PostType, Score, CreationDate, OwnerID, Body
42815835,42815835,null,1,1,Wed Mar 15 16:43:00 EDT 2017,7716369,"<p>I am working on a project in which I am using Heartbeat Temperature and ECG Sensor to get the patient data and using Raspberry Pi as Controller; I want to show the values from the sensors to be shown on a web page in real time, values will be in numeric form and an ECG graph. Please suggest a tutorial or method that can help in this regard. </p>	"
42815835,42817627,42815835,2,3,Wed Mar 15 18:15:00 EDT 2017,1364242,"<p>Take a look at Django Channels (aka <a href="http://channels.readthedocs.io/en/stable/deploying.html" rel="nofollow noreferrer">Daphne</a>).</p>		<p>This uses Daphne as a Web Socket Server to handle <a href="https://en.wikipedia.org/wiki/WebSocket" rel="nofollow noreferrer">WebSocket</a> requests but within the Django Python API.  You get all the benefits, database and templating that Django brings and a simple WebSocket implementation in Python.  A few lines of Javascript and an HTML template finishes the job on the client.	Daphne can also work as a webserver rather than using, e.g. Nginx.  NOTE: Nginx is recommended as this can proxy websocket connections. Neither Apache or Nginx can handle websocket connections themselves (hence Daphne).</p>		<p>In effect you write a simple web page that connects to Daphne using Javascript and transfers data to and from some source to the client's web page with minimal latency and no need to refresh the browser.	It supports multiple connections from many clients and distribution of messages to multiple clients.</p>		<p>Your worker process (running inside Daphne) handle communication with your Raspberry Pi hardware, external API, or shell function.</p>		<p>On the client you can use a Javascript gaming engine such as <a href="https://phaser.io/" rel="nofollow noreferrer">Phaser</a> to draw the graphics in response to data from the websocket, or you can use HTML5 canvas objects to do the same manually.  You could also use a graphing engine such as <a href="https://d3js.org/" rel="nofollow noreferrer">d3.js</a>.</p>		<p>See <a href="https://channels.readthedocs.io/en/stable/" rel="nofollow noreferrer">Django Channels</a></p>		<p>Minimal worked example (untested):</p>		<pre><code>mkdir django	cd django	django-admin startproject wsproj	cd wsproj	django-admin startapp wsapp	</code></pre>		<p><strong><em>wsproj/wsproj/asgi.py</em></strong></p>		<pre><code>import os	import re	from channels.asgi import get_channel_layer		os.environ.setdefault("DJANGO_SETTINGS_MODULE", "wsproj.settings")		channel_layer = get_channel_layer()		channel_capacity={	    "http.request": 200,	    "http.response!*": 10,	    re.compile(r"^websocket.send\!.+"): 20,	}	</code></pre>		<p><strong><em>wsproj/wsproj/routing.py</em></strong></p>		<pre><code>from channels.routing import route	from pgwss.consumers import websocket_receive, websocket_connect, websocket_disconnect		channel_routing = [	    route("websocket.receive", websocket_receive, path=r"^/ws"),	    route("websocket.connect", websocket_connect, path=r"^/ws"),	    route("websocket.disconnect", websocket_disconnect, path=r"^/ws"),	]	</code></pre>		<p><strong><em>wsproj/wsproj/setting.py</em></strong></p>		<pre><code>INSTALLED_APPS = [	    'django.contrib.admin',	    'django.contrib.auth',	    'django.contrib.contenttypes',	    'django.contrib.sessions',	    'django.contrib.messages',	    'wsapp',	    'django.contrib.staticfiles',	    'channels',	]		CHANNEL_LAYERS = {	    "default": {	        "BACKEND": "asgi_ipc.IPCChannelLayer",	        "ROUTING": "pgserver.routing.channel_routing",	    },	}	</code></pre>		<p><strong><em>wsproj/wsapp/consumers.py</em></strong></p>		<pre><code>from channels import Group		def websocket_receive(message):	    text = message.content.get('text')	    print "Client sent %s" % text	    temperature = getTemperature()		    message.reply_channel.send({"data": "%f" % temperature})		def websocket_disconnect(message):	    Group("ws").discard(message.reply_channel)		def websocket_connect(message):	    message.reply_channel.send({"accept": True})	    Group("ws").add(message.reply_channel)		    #Rather than responding to polls from the client in the	    #Receive function (pull). You might create a thread	    #here to handle messages to the client (push)	</code></pre>		<p><strong><em>wsproj/wsapp/views.py</em></strong></p>		<pre><code>from django.template.loader import render_to_string	from django.http import HttpResponse		def counterview(request):	    html = render_to_string('ws.html')		    response = HttpResponse(html)	    return response	</code></pre>		<p><strong><em>wsproj/wsapp/templates/ws.html</em></strong></p>		<pre><code>&lt;!DOCTYPE html&gt;	{% load static %}	&lt;html&gt;	    &lt;body&gt;	        &lt;div&gt;	            &lt;span id="temperature"&gt;&lt;/span&gt;	        &lt;/div&gt;	        &lt;script type="text/javascript"&gt;	            csocket = new WebSocket("ws://127.0.0.1/ws");	            csocket.onmessage = function(e)	            {	                var myjson = JSON.parse(e.data);	                var temperature = myjson.temperature;	                document.getElementById('temperature').innerHTML = temperature;		            }		            var i = 0;	            function msg() {	                //Keep sending a poll	                csocket.send(i++);	                timer = setTimeout(msg, 100);	            }		            csocket.onopen = function() {	                msg();	            }		        &lt;/script&gt;	    &lt;/body&gt;	&lt;/html&gt;	</code></pre>	"
