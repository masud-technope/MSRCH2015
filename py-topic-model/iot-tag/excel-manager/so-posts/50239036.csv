thread_ID, Id, ParentId, PostType, Score, CreationDate, OwnerID, Body
50239036,50239036,null,1,1,Tue May 08 17:15:00 EDT 2018,1116536,"<p>I'm interested in using AKKA for an IoT Device scenario but I'm worried about complicating an individual actor.  In most industries, a device is not as simple as a 'temperature sensor' you see in most tutorials.  A device represents something more complex that can take on the following characteristics:</p>		<ul>	<li>Many sensors can be represented (temperatures, electrical/fluid flows, power output, on/off values.....</li>	<li>Each of the values above can be queried for current value, and more likely historical values (trends, histograms....)</li>	<li>Alerting rules can be set up for any one of the sensor values</li>	<li>Each device has a fairly complex configuration that must be managed (what sensors, what unit of measure)</li>	<li>Many different message types can be sent (sensor reading request, alerts, configuration updates....)</li>	</ul>		<p>So my general question is does anyone have good advice on what the level of complexity an actor should take on?  </p>		<p>Thanks	Steve</p>	"
50239036,87533864,50239036,3,0,Wed May 09 16:24:00 EDT 2018,6616529,"i think it's a good idea let sensors be actors in this case, use actor class to abstract the different sensors. read some materials about domain model design based on actor system"
50239036,97218570,50239036,3,0,Tue Mar 19 14:00:00 EDT 2019,506313,"You may want to model things based on WHERE the sensors are, rather than the sensors themselves. That way, if a sensor fails and is replaced, then the data (and state) is associated with the location rather than the device. Is it more important that freezer case #217 is running warm, or that sensors 0xADEFA and 0xAFEDA are running warm?"
50239036,50302439,50239036,2,0,Sat May 12 02:55:00 EDT 2018,6316508,"<p>Below are a few bullet points one might want to keep in mind when determining what level of complexity an actor should take on:</p>		<ul>	<li><p>Akka actors are lightweight and loosely-coupled by design, thus scale well in a distributed environment. On the other hand, each actor can be tasked to handle fairly complex business logic using Akka's functionality-rich API.  This results in great flexibility in determining how much workload an actor should bear.</p></li>	<li><p>In general, <code>quantity of IoT devices</code> and <code>operational complexity in each device</code> are the two key factors in the design of the device actor.  If total device quantity is large, one should consider having some group-device actors each of which handles a set of devices using, for instance, a private key-value collection.  On the other hand, if each IoT device involves fairly complex computation or state mutation logic, it might be better to make each actor represent an individual device.  It's worth noting that the two strategies aren't mutually exclusive.</p></li>	<li><p>For historical data, I would recommend having actors periodically fed to a database (e.g. Cassandra, PostgreSQL) for OLAP queries.  Actors should be left to answer only simple queries.</p></li>	<li><p>Akka actors have a well-defined <a href="https://doc.akka.io/docs/akka/current/actors.html#actor-lifecycle" rel="nofollow noreferrer">lifecycle</a> with hooks like <code>preStart()</code>, <code>postRestart()</code>, <code>postStop()</code> for programmatic logic control.  <a href="https://doc.akka.io/docs/akka/current/fault-tolerance.html#creating-a-supervisor-strategy" rel="nofollow noreferrer">Supervisor strategies</a> can be created to manage actors in accordance with specific business rules (send alerts, restart actors, etc).</p></li>	<li><p>On customizing attributes (e.g. unit of measure) specific to the type of devices, one could model a device type along with its associated sensor attributes, say, as a <code>case class</code> and make it a parameter of the device actor.</p></li>	<li><p>Capability of handling different message types via non-blocking message passing is one of the biggest strengths of Akka actors. The <code>receive</code> partial function in an actor effectively handles various message types via pattern matching.  When representing a device with complex state mutation logic, its operational state can be safely hotswapped via <a href="https://doc.akka.io/docs/akka/current/actors.html#become-unbecome" rel="nofollow noreferrer">context.become</a>.</p></li>	</ul>		<p>This <a href="https://blog.genuine.com/2017/07/scala-iot-systems-with-akka-actors-ii/" rel="nofollow noreferrer">blog post</a> about simulating IoT devices as individual actors might be of interest.</p>	"
