thread_ID, Id, ParentId, PostType, Score, CreationDate, OwnerID, Body
48082462,48082462,null,1,3,Wed Jan 03 17:42:00 EST 2018,817044,"<p>I surely must have missed something from my reading of the LoRaWAN specifications, because this seems too bad to be true. Please tell me I'm delirious :) </p>		<p>The following seems to happen in my testbed when I have many OTAA nodes and I can't figure out what would prevent it:</p>		<ol>	<li><p>multiple nodes in my network issues JOIN REQUEST at the same time (this can happen by chance or if they are powered on simultaneously)</p></li>	<li><p>gateway receives (at least) one of them successfully and responds with a JOIN ACCEPT assigning a DevAddr, thinking one node did a join req</p></li>	<li><p><em>all the nodes</em> that did the JOIN REQUEST will receive the ACCEPT and think the JOIN ACCEPT was directed at them, and gladly sets the same received DevAddr</p></li>	</ol>		<p>From here on, we have several nodes that all think they joined successfully and all think they are unique but have the same DevAddr. Needless to say, the system gets severely messed up.</p>		<p>Reading the LoRaWAN specification, the JOIN REQUEST has a node unique DevEUI, a network unique AppEUI, and a random DevNonce (to prevent replay attacks). The MIC is calculated from these and the secret network unique AppKey stored in the node.</p>		<p>The JOIN ACCEPT has, as far as I can see, no data in it which is derived from the JOIN REQUEST, and therefore it can't be directed to a specific node in the case that many nodes are currently listening to an ACCEPT.</p>		<p>It has: AppNonce NetID DevAddr DLSettings RxDelay CFList, and is encrypted with the AppKey which is network unique and not node unique. The MIC only involves these values and so doesn't help either.</p>		<p>I would have expected that the JOIN ACCEPT at the minimum includes the DevEUI requesting the join as a part of the MIC, and also that it would include the DevNonce. It seems it includes neither.</p>		<p>What gives? Is OTAA broken or not? :)</p>	"
48082462,83161886,48082462,3,0,Thu Jan 04 10:55:00 EST 2018,817044,"Preliminary analysis: seems it really is a weakness. The node has to use an additional higher level handshake to assure it really is connected, or you need to use individual AppKeys for each device (kind of defeating part of the OTAA reason, I guess)."
48082462,51129864,48082462,2,0,Mon Jul 02 05:59:00 EDT 2018,1778551,"<p>One qualifier is the timing requirements for Join Request (JR) and Join Accept (JA).  The specification is that a device can only use a JA received "precisely" 5 or 6 (2nd window) seconds after it sent the JR.</p>		<p>I'd hope there are better fail-safes then this timing but the intention might be to prevent the wrong tags from taking a JA.</p>	"
48082462,51499170,48082462,2,4,Tue Jul 24 12:54:00 EDT 2018,10128005,"<p>The MIC will be different for each device because it's base on the secret (and supposedly unique) master key (AppKey) shared between the device and the network.</p>		<p>The first thing a device do is checking the MIC, if it's not what's expected it will drop the message.</p>		<p>So what you said below is not exactly right :</p>		<blockquote>	  <p>The JOIN ACCEPT has, as far as I can see, no data in it which is derived from the JOIN > REQUEST, and therefore it can't be directed to a specific node in the case that many > > nodes are currently listening to an ACCEPT.</p>	  	  <p>It has: AppNonce NetID DevAddr DLSettings RxDelay CFList, and is	  encrypted with the AppKey which is network unique and not node unique.	  The MIC only involves these values and so doesn't help either</p>	</blockquote>		<p>Of course if you set the same AppKey on every of your device, you will	get what you described :)</p>	"
48082462,90024728,51499170,3,0,Wed Jul 25 21:41:00 EDT 2018,817044,"Yeah well like I wrote in the comment above to my question, a unique AppKey per device is contrary to the OTAA policy (the point of it is that the server doesn't need predetermined keys to all the devices).."
48082462,90070693,51499170,3,1,Fri Jul 27 06:20:00 EDT 2018,10128005,"It's clearly written in the LoRaWAN Specification that the AppKey should be unique (and it's a good practice anyway). 		_The AppKey is an AES-128 root key specific to the end-device. Whenever an end-device joins a network via over-the-air activation, the AppKey is used to derive the session keys NwkSKey and AppSKey specific for that end-device to encrypt and verify network communication and application data._		_Since all end-devices end up with unrelated application keys specific for each end-device, extracting the AppKey from an end-device only compromises this one end-device._"
48082462,95022380,51499170,3,0,Tue Jan 08 15:35:00 EST 2019,1098603,"@PierreDUFOUR so the `AppKey` should be unique for each node (as the `DevEUI`), but each node should use the same `AppEUI` (for a specific application)?"
48082462,54152293,48082462,2,1,Fri Jan 11 18:42:00 EST 2019,84237,"<p>Apart from the different AppKey as mentioned in Pierre's answer (strongly recommended), the node also includes a DevNonce in its Join Request. This DevNonce is used to derive the NwkSKey and AppSKey session keys from the Join Accept response.</p>		<p>In LoRaWAN 1.0.x, this DevNonce should be random. So even when using the same AppKey for all devices, chances should be low that they would also have generated the same DevNonce. So even if the MIC somehow validated, then the derived keys will not match the keys known to the server, basically rendering the device useless without it knowing it.</p>		<p>In LoRaWAN 1.1 I <em>think</em> that the DevNonce is an increasing number, but in 1.1 OTAA has changed so I don't know how that affects the results.</p>		<p>See <a href="https://runkit.com/avbentem/deciphering-a-lorawan-otaa-join-accept" rel="nofollow noreferrer">https://runkit.com/avbentem/deciphering-a-lorawan-otaa-join-accept</a></p>		<blockquote>	  <p>this can happen by chance or if they are powered on simultaneously</p>	</blockquote>		<p>As for switching on simultaneously, <a href="https://lora-alliance.org/sites/default/files/2018-07/lorawan1.0.3.pdf#page=9" rel="nofollow noreferrer">the 1.0.x specifications state</a>:</p>		<blockquote>	  <p>The transmission slot scheduled by the end-device is based on its own communication needs with a small variation based on a random time basis</p>	</blockquote>		<p>Still then, such small variation probably won't avoid nodes hearing each others Join Accept messages in this scenario, as the downlink receive window will need to be slightly lenient too.</p>	"
