thread_ID, Id, ParentId, PostType, Score, CreationDate, OwnerID, Body
50826174,50826174,null,1,0,Tue Jun 12 21:36:00 EDT 2018,6036437,"<p>So I've been trying to make a music visualizer that actually works in real-time. I've struggled a lot to get it to work, but then, yesterday, out of nowhere, it started working when I added a small delay after sending packets. I took it off and <em>voila</em>, it was working in real-time. </p>		<p>So I brought them home later to find them still not working on my home network, which I thought was weird. Then I bring them back to school today to find that they are not even working at school anymore! What gives? I'm so stumped on why these things work like a charm out of nowhere, and then stop working again out of nowhere.</p>		<p>I try adding a delay, and it works, but the delay is so bad that it's hard to tell that it's even reacting to the microphone at all.</p>		<p>I've my GitHub here: <a href="https://github.com/HoldenGs/LIFX_controller" rel="nofollow noreferrer">https://github.com/HoldenGs/LIFX_controller</a></p>		<p>and also here's the relevant code:</p>		<pre><code>#!/usr/bin/env python3		import time	import socket	import argparse	import random	import queue	import sys	from tools import get_colour_zones_packet, APPLY		RETRIES = 1	UDP_PORT = 56700	SEQ_NUM = random.randint(0, 255)			def int_or_str(text):	    """Helper function for argument parsing."""	    try:	        return int(text)	    except ValueError:	        return text			parser = argparse.ArgumentParser(description=__doc__)	parser.add_argument(	    '-l', '--list-devices', action='store_true',	    help='show list of audio devices and exit')	parser.add_argument(	    '-d', '--device', type=int_or_str,	    help='input device (numeric ID or substring)')	parser.add_argument(	    '-w', '--window', type=float, default=200, metavar='DURATION',	    help='visible time slot (default: %(default)s ms)')	parser.add_argument(	    '-i', '--interval', type=float, default=30,	    help='minimum time between plot updates (default: %(default)s ms)')	parser.add_argument(	    '-b', '--blocksize', type=int, help='block size (in samples)')	parser.add_argument(	    '-r', '--samplerate', type=float, help='sampling rate of audio device')	parser.add_argument(	    '-n', '--downsample', type=int, default=10, metavar='N',	    help='display every Nth sample (default: %(default)s)')	parser.add_argument(	    'channels', type=int, default=[1], nargs='*', metavar='CHANNEL',	    help='input channels to plot (default: the first)')	args = parser.parse_args()	if any(c &lt; 1 for c in args.channels):	    parser.error('argument CHANNEL: must be &gt;= 1')		mapping = [c - 1 for c in args.channels]  # Channel numbers start with 1	q = queue.Queue(64)					def audio_callback(indata, frames, time, status):	    """This is called (from a separate thread) for each audio block."""	    if status:	        print(status, file=sys.stderr)	    # Fancy indexing with mapping creates a (necessary!) copy:	    q.put(indata[::args.downsample, mapping])			def update_lights(hue):	    """This is called by matplotlib for each plot update.	    Typically, audio callbacks happen more frequently than plot updates,	    therefore the queue tends to contain multiple blocks of audio data.	    """	    while True:	        try:	            data = q.get_nowait()	        except queue.Empty:	            break	        max_amp = max(data)[0] * 500	        if max_amp &gt; 100:	            max_amp = 100	        if max_amp &lt; 1:	            max_amp = 1	        print("amp: {}                 ".format(int(max_amp)), end="\r")	        bulb_ip = "192.168.1.5"	        start_index = 0	        end_index = 11	        sat = 0	        kel = 3500	        packet = get_colour_zones_packet(start_index, end_index,	                                        hue, sat, int(max_amp), kel, APPLY, SEQ_NUM)	        sock.sendto(packet, (bulb_ip, UDP_PORT))						if len(sys.argv) &gt; 0:	    import numpy as np	    import sounddevice as sd	    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)		    if args.list_devices:	        print(sd.query_devices())	        parser.exit(0)	    if args.samplerate is None:	        device_info = sd.query_devices(args.device, 'input')	        args.samplerate = device_info['default_samplerate']		    print("Starting...")	    # start stream	    stream = sd.InputStream(	        device=args.device, channels=max(args.channels),	        samplerate=args.samplerate, callback=audio_callback)	    try:	        with stream:	            hue = 0	            add = 1	            while True:	                # if add:	                #     hue += 0.00005	                #     if hue &gt;= 255:	                #         add = 0	                #         hue = 255	                # else:	                #     hue -= 0.00005	                #     if hue &lt;= 0:	                #         add = 1	                #         hue = 0	                update_lights(int(hue))	    except KeyboardInterrupt as e:	        parser.exit(type(e).__name__ + ': ' + str(e))	else:	    print("No lights with MultiZone capability detected.")	</code></pre>		<p>I'm a bit lost on how to handle this elusive problem. Any tips are much appreciated!</p>	"
50826174,50844372,50826174,2,0,Wed Jun 13 18:55:00 EDT 2018,6036437,"<p>So to answer my own question, it seems like there's no reliable way to control these lights without some rate-limiting, so at this point I just have a small 0.025 second delay after sending packets, which causes some audio input to not show up in the lights, but it still works as a rudimentary solution. If you'd like to check out the project, it's right here: <a href="https://github.com/HoldenGs/LIFX_controller" rel="nofollow noreferrer">https://github.com/HoldenGs/LIFX_controller</a></p>	"
