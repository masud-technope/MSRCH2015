thread_ID, Id, ParentId, PostType, Score, CreationDate, OwnerID, Body
55765324,55765324,null,1,0,Fri Apr 19 17:08:00 EDT 2019,6121834,"<p>I'm trying to compile and test the azure-iot-sdk-c on a raspberry pi. How do I compile it on the raspberry pi and then run the E2E tests provided in the SDK?</p>	"
55765324,98210873,55765324,3,0,Fri Apr 19 22:08:00 EDT 2019,5420074,"from their read me: "tools that are currently used in testing the client libraries: Mocking Framework (micromock), Generic Test Runner (CTest), Unit Test Project Template, etc."  https://github.com/Azure/azure-iot-sdk-c#testtools  https://github.com/bvdberg/ctest"
55765324,56056640,55765324,2,0,Thu May 09 09:43:00 EDT 2019,6049604,"<p>In order to achieve this, there are a couple approaches you could take. You could download a cross-compiler for the Pi and keep the source code only on your development machine. Then when you wanted to run code/tests on the Pi, you would use the cross-compiler to produce an output that could run on the Pi, transfer the executables to the Pi, and return the results back to the development machine. This approach would probably be quite fast, and if your project contains many files, it might be a good way to go about it. Setting up a cross-compiler isnâ€™t the simplest thing to do, but there are many documented cases online of people who have already done it.</p>		<p>The other approach would be to develop the source code on your development machine but build the code for the Pi on the Pi itself. This removes the need to set up a cross-compiler and it makes getting the test results back to your development machine very simple.</p>		<p>You can use your text editor to develop the code on development machine. Then rsync to transfer your source files to the Raspberry Pi. Finally, You can install Ruby and Ceedling (a C unit testing tool) on your development machine and on the Pi to assist in running tests. Hereâ€™s how to make it all happen.</p>		<ul>	<li>Set Up SSH Keys</li>	</ul>		<p>This step is important because it allows you to transfer files from your development machine to the Pi and execute commands remotely without having to type in a username and password every time. First, make sure you have an SSH key generated on your development machine. If you donâ€™t, or if youâ€™re not sure, check out this excellent <a href="https://help.github.com/articles/generating-ssh-keys" rel="nofollow noreferrer">GitHub article that explains how to generate one</a>.</p>		<p>ow if you open up your ~/.ssh (or your/user/directory/.ssh on Windows) directory on your development machine, you should have a file called rd_isa.pub. This is the â€œpublicâ€? piece of your SSH key. You need to transfer this file to the Raspberry Pi so that it can recognize you as an approved user. Do that with the following command:</p>		<p>scp ~/.ssh/id_rsa.pub user@remote.host:pubkey.txt</p>		<p>Make sure to replace â€˜userâ€™ with a username on the Raspberry Pi and â€˜remote.hostâ€™ with the IP address of the Pi.</p>		<p>Once youâ€™ve done that, you need to append the key to the â€œauthorized_keysâ€? file on the Pi. To do so you will need to SSH into the Pi and manually edit/create the file. That can be done as follows:</p>		<pre><code>scp ~/.ssh/id_rsa.pub user@remote.host:pubkey.txt		ssh user@remote.host		mkdir ~/.ssh		cat pubkey.txt &gt;&gt; ~/.ssh/authorized_keys		rm ~/pubkey.txt	</code></pre>		<ul>	<li>Install â€˜rsyncâ€™</li>	</ul>		<p>The next step is to install rsync, a utility that allows you synchronize directories between two computers. When we make changes on our local machine, rsync will transfer those changes to the Pi for testing. rsync is smart enough to only transfer files that have been updated since the last transfer, which will speed up the process. For rsync to work, it must be installed on both your development machine and the Raspberry Pi. To install it on the Pi execute the following command.</p>		<pre><code>sudo apt-get install rsync	</code></pre>		<p>The process for installing rsync on your development machine will vary greatly depending on which OS you are running. On the Mac, itâ€™s already installed. Some Linux distros come with it as well. Windows, on the other hand, is a little behind the game. Search Google for â€œInstalling rsync on Windowsâ€? for instructions on getting it setup.</p>		<ul>	<li>Install Ruby</li>	</ul>		<p>Ruby is another component that needs to be installed on by the development machine and the target. Ruby is a scripting language that Ceedling uses to automate unit test execution. Again, refer to the all-wise Google for instructions on installing the latest version on your dev machine. To install Ruby on the Raspberry Pi use the following command:</p>		<pre><code>sudo apt-get install ruby	</code></pre>		<ul>	<li>Install Rake</li>	</ul>		<p>Rake is a Ruby gem (package) that provides build automation support similar to â€˜makeâ€™. Once you have Ruby installed, Rake is as simple to install as typing the following:</p>		<pre><code>sudo gem install rake	</code></pre>		<ul>	<li>Setup a Ceedling Project</li>	</ul>		<p>Finally We can already write code locally and execute tests on our development machine using the command â€œrake test:allâ€?.  </p>		<p>The final thing we need to do is set up a custom rake task that will run tests on the Pi without having to manually SSH into it. Look in the root directory of your Ceedling project and you will see a file named Rakefile.rb. This is where we will put our custom rake task. Add the following to the bottom of the file:</p>		<pre><code>desc "Run rake test:all on RPi with latest changes"		desc "Update the RPi with the latest changes on dev machine."	task :update_pi_source do		  #send the latest changes to the pi	  puts cmd = "rsync -r -v . #{REMOTE_RPI_USER}@#{REMOTE_RPI_IP_ADDR}:#{REMOTE_RPI_PROJ_ROOT} --exclude=#{PROJECT_BUILD_ROOT}"	  system(cmd)	end		desc "Run rake test:all in the project directory on the pi"	task :run_all_tests_pi do		  #execute tests on the pi	  puts cmd = "ssh #{REMOTE_RPI_USER}@#{REMOTE_RPI_IP_ADDR} "cd #{REMOTE_RPI_PROJ_ROOT} &amp;amp;&amp;amp; rake test:all""	  system(cmd)	end		task :pi_test_all &gt; [:update_pi_source, :run_all_tests_pi] do	end	</code></pre>		<p>This actually defines three rake tasks. The first one, update_pi_src, is the task that uses rsync to update the source code on the Pi. The second one, run_all_tests_pi, uses SSH to execute the necessary command to compile the code and run the tests on the Pi. The third task, pi_test_all, is just a wrapper that combines the first two.</p>		<p>Hope it helps.</p>	"
