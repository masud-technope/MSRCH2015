thread_ID, Id, ParentId, PostType, Score, CreationDate, OwnerID, Body
52394503,52394503,null,1,0,Tue Sep 18 20:58:00 EDT 2018,1088899,"<p>I have followed all the instruction for setting up a "Downstream Device" to send messages through IoT Edge running in Transparent Gateway.  I believe my routing rules are correct, but my Function module is not receiving any of the Messages through the message flow.</p>		<p>These are the instruction I've followed:	<a href="https://docs.microsoft.com/en-us/azure/iot-edge/how-to-create-transparent-gateway-linux" rel="nofollow noreferrer">https://docs.microsoft.com/en-us/azure/iot-edge/how-to-create-transparent-gateway-linux</a></p>		<p>I am using 2 Linxu VMs (ubuntu 16.04.5).  </p>		<ol>	<li>IoT Edge Transparent Gateway VM is configured with all the certs properly setup, configured and verified.  I've been able to using the openssl tool from the </li>	</ol>		<p>openssl s_client -connect {my-gateway-machine-name-dns-name}.centralus.cloudapp.azure.com:8883 -CAfile /certs/certs/azure-iot-test-only.root.ca.cert.pem -showcerts</p>		<ol start="2">	<li><p>Downstream device running on Linux VM with Certs installed and verified.  My connection string is as follows:</p>		<p>HostName={IoTHubName}.azure-devices.net;DeviceId=TC51_EdgeDownStreamDevice01;SharedAccessKey={My-Shared-Access-Key}=GatewayHostName={my-gateway-machine-name-dns-name}.centralus.cloudapp.azure.com</p></li>	</ol>		<p>a. I have verified I get a successful verification of the SSL cert using the openssl tool.	b. I'm using the the following in my downstream device for my connection using the NodeJS SDK</p>		<p>var client = DeviceClient.fromConnectionString(connectionString, Mqtt);	c.  I can see the messages showing up at the Azure IoT Hub in the Cloud, but I can't get my module running on the IoT Edge Transparent Gateway to be hit.</p>		<ol start="3">	<li>Here are my routing rules configured for the edgeHub as specified in "Routing messages from downstream devices" in the sample doc page.</li>	</ol>		<p>This is what the example docs show:	{ "routes":{ "sensorToAIInsightsInput1":"FROM /messages/* WHERE NOT IS_DEFINED($connectionModuleId) INTO BrokeredEndpoint(\"/modules/ai_insights/inputs/input1\")", "AIInsightsToIoTHub":"FROM /messages/modules/ai_insights/outputs/output1 INTO $upstream" } }</p>		<p>This is what my routing configuration is set to:	        "routes": {	          "downstreamBatterySensorToBatteryDataFunctionInput1": "FROM /* WHERE NOT IS_DEFINED($connectionModuleId) INTO BrokeredEndpoint(\"/modules/BatteryDataFunctionModule/inputs/input1\")",	          "BatteryDataFunctionModuleToIoTHub": "FROM /messages/modules/BatteryDataFunctionModule/outputs/* INTO $upstream"	        }</p>		<p>** Note that I've used by "FROM /* WHERE NOT IS_DEFINED"  and "FROM /messages/* WHERE NOT IS_DEFINED"</p>		<ol start="4">	<li>My module on the IoT Edge is setup as a Function.  When I use the out of the box example where the simulator device is another module running on the IoT Edge, then my function is hit correctly.  Its only when I'm trying to use a "Downstream Device" that the module is not being triggered.</li>	</ol>		<p>I have enabled "Debug Logging for the IoT Edge Service" running on my Transparent Gateway.  </p>		<pre><code>This is the basic Run method for the Function module:		#r "Microsoft.Azure.Devices.Client"	#r "Newtonsoft.Json"		using System.IO;	using Microsoft.Azure.Devices.Client;	using Newtonsoft.Json;	using Newtonsoft.Json.Linq;		// Filter messages based on the temperature value in the body of the     message and the temperature threshold value.	public static async Task Run(Message messageReceived, IAsyncCollector&lt;Message&gt; output, TraceWriter log)	{	</code></pre>		<p>How can I figure out how to get my Module running in IoT Edge to be hit/triggered from a Downstream device?</p>	"
52394503,52396267,52394503,2,1,Wed Sep 19 00:24:00 EDT 2018,9090979,"<p>So, you say you are seeing messages show up in IoT Hub, but not in Edge...  A couple of things:</p>		<p>you posted this as your connection string in your node app:	HostName={IoTHubName}.azure-devices.net;DeviceId=TC51_EdgeDownStreamDevice01;SharedAccessKey={My-Shared-Access-Key}=GatewayHostName={my-gateway-machine-name-dns-name}.centralus.cloudapp.azure.com</p>		<p>Did you copy/paste this exactly?  the reason I ask is that, between the shared access key and the word "GatewayHostName", you have an equals sign and not a semi-colon..</p>		<p>it should be:	HostName={IoTHubName}.azure-devices.net;DeviceId=TC51_EdgeDownStreamDevice01;SharedAccessKey={My-Shared-Access-Key};GatewayHostName={my-gateway-machine-name-dns-name}.centralus.cloudapp.azure.com</p>		<p>(note the ';' before GatewayHostNameâ€¦   if you really did have an equals sign there instead of a semicolon, there's no telling what kind of chaos that would cause :-)</p>		<p>Secondly, in your route, you call your module BatteryDataFunctionModule..  just want to make sure that module name is exact, including being case-sensitive. You probably know that, but don't want to assume..</p>		<p>Finally, if the two things above check out, can you add an addition debugging route that sends the 'incoming data' to IoTHub as well..<br>	"FROM /* WHERE NOT IS_DEFINED($connectionModuleId) INTO $upstream"</p>		<p>so we can make sure the messages are actually making it <em>through</em> iot edge.</p>	"
52394503,91773063,52396267,3,0,Wed Sep 19 21:51:00 EDT 2018,1088899,"@steve-busby-msft,  I was in fact missing the ";" semi-colon.  I've made that change, but I still do not see messages getting hit by my routing rules.  I've added the additional routing that you mentioned as well, and this is not intercepting my message and sending them up to the IoT Hub."
52394503,91773216,52396267,3,0,Wed Sep 19 21:59:00 EDT 2018,1088899,"@steve-busby-msft.  Also, when I run a module on my IoTEdge device (as the one that comes with all the samples) using the default route rules, them my Function module gets hit everytime with no issues.            "tempSensor": {	            "version": "1.0",	            "type": "docker",	            "status": "running",	            "restartPolicy": "always",	            "settings": {	              "image": "mcr.microsoft.com/azureiotedge-simulated-temperature-sensor:1.0",	              "createOptions": ""	            }	          },"
52394503,91773233,52396267,3,0,Wed Sep 19 22:00:00 EDT 2018,1088899,""routes": { "sensorToBatteryDataFunctionModule": "FROM /messages/modules/tempSensor/outputs/temperatureOutput INTO BrokeredEndpoint(\"/modules/BatteryDataFunctionModule/inputs/input1\")",	  "debuggingRoute": "FROM /* WHERE NOT IS_DEFINED($connectionModuleId) INTO $upstream",	    "downstreamBatterySensorToBatteryDataFunctionInput1": "FROM /* WHERE NOT IS_DEFINED($connectionModuleId) INTO BrokeredEndpoint(\"/modules/BatteryDataFunctionModule/inputs/input1\")",	          "BatteryDataFunctionModuleToIoTHub": "FROM /messages/modules/BatteryDataFunctionModule/outputs/* INTO $upstream"	        }"
52394503,91836992,52396267,3,0,Fri Sep 21 15:41:00 EDT 2018,1088899,"Hi Steve. That's a fantastic hands-on-lab you've created! I wish I had found that earlier :-) I suggest referencing those docs fro the Transparent Gateway.    I ended up creating a .NET Core Downstream/Leaf Device instead of NodeJS using the basic examples of Application level CA field being loaded into the app and all my messages flow correctly to IoT Edge, hit all the Routing rules. My thinking is there must be an issue in the NodeJS SDK."
52394503,91799464,52396267,3,0,Thu Sep 20 15:00:00 EDT 2018,1088899,"I've made all the changes and I can't get the messages to pass through the IoT Edge device.  What other things can I try?  If I remove the "GatewayHostName" from my downstream device connection string, then my messages hit the IoT Hub without issue, but I believe this is by-passing the IoTEdge completely."
52394503,91813092,52396267,3,0,Thu Sep 20 23:55:00 EDT 2018,9090979,"Hey Chris...  one other thing to try...  when I'm routing from leaf devices into modules, I use "FROM /messages/* WHERE NOT IS_DEFINED($connectionModuleId) INTO..." as the first part of the route spec.  Note the /messages/* vs. just /*"
52394503,91813110,52396267,3,0,Thu Sep 20 23:56:00 EDT 2018,9090979,"An example of the previous  (and a good example for Edge in general) can be found at a set of hands-on labs I maintain here ->  https://github.com/AzureIoTGBB/azure-iot-edge-hol-linux   (the bottom of module 3 is where I first introduce that route)"
52394503,91920739,52396267,3,0,Tue Sep 25 03:00:00 EDT 2018,9090979,"glad you found the labs useful...  I have a windows version I need to update for GA bits, and I'm working on a raspberry pi version...   I meant to reply this weekend that Node specifically does not respect and won't read certs from the cert store and that you have to explicitly give it the path, but it looks like from below you figured that out yourself.  Nice job."
52394503,91737643,52396267,3,1,Wed Sep 19 00:51:00 EDT 2018,9090979,"BTW - I meant to add to my response above, that, since you say you are seeing the data showing up in IoT Hub, but not in IoT Edge, and judging by you not having a route that should route your device data directly to IoTHub (only to your module)  that having the equals sign in the connection string is causing it to be parsed incorrectly..  so my guess is that, because of that, the GatewayHostName param is being ignored and that the node client is just, by default, talking directly to IoT Hub and not even trying to get to IoT Edge."
52394503,52479984,52394503,2,0,Mon Sep 24 12:55:00 EDT 2018,1088899,"<p>There are 2 problems that needed to be addressed to get the Downstream Device to communication</p>		<ol>	<li>Thanks to @Steve-Busby-Msft I needed to have a semi-colon (;) at the end of the SharedAccessKey and before the GatewayHostName</li>	</ol>		<p>you posted this as your connection string in your node app: HostName={IoTHubName}.azure-devices.net;DeviceId=TC51_EdgeDownStreamDevice01;SharedAccessKey={My-Shared-Access-Key}=GatewayHostName={my-gateway-machine-name-dns-name}.centralus.cloudapp.azure.com</p>		<ol start="2">	<li>The NodeJS application Downstream Device also has to load up the cert correctly at the 'Application level'.</li>	</ol>		<p>Notice the section of code for </p>		<blockquote>	  <p>var edge_ca_cert_path = '[Path to Edge CA certificate]';</p>	</blockquote>		<p><a href="https://github.com/Azure/azure-iot-sdk-node/blob/master/device/samples/edge_downstream_device.js" rel="nofollow noreferrer">Node JS Downstream Application</a></p>		<pre><code>'use strict';		var fs = require('fs');	var Protocol = require('azure-iot-device-mqtt').Mqtt;	// Uncomment one of these transports and then change it in fromConnectionString to test other transports	// var Protocol = require('azure-iot-device-http').Http;	// var Protocol = require('azure-iot-device-amqp').Amqp;	var Client = require('azure-iot-device').Client;	var Message = require('azure-iot-device').Message;		// 1) Obtain the connection string for your downstream device and to it	//    append this string GatewayHostName=&lt;edge device hostname&gt;;	// 2) The edge device hostname is the hostname set in the config.yaml of the Edge device	//    to which this sample will connect to.	//	// The resulting string should look like the following	//  "HostName=&lt;iothub_host_name&gt;;DeviceId=&lt;device_id&gt;;SharedAccessKey=&lt;device_key&gt;;GatewayHostName=&lt;edge device hostname&gt;"	var connectionString = '[Downstream device IoT Edge connection string]';		// Path to the Edge "owner" root CA certificate	var edge_ca_cert_path = '[Path to Edge CA certificate]';		// fromConnectionString must specify a transport constructor, coming from any transport package.	var client = Client.fromConnectionString(connectionString, Protocol);		var connectCallback = function (err) {	  if (err) {	    console.error('Could not connect: ' + err.message);	  } else {	    console.log('Client connected');	    client.on('message', function (msg) {	      console.log('Id: ' + msg.messageId + ' Body: ' + msg.data);	      // When using MQTT the following line is a no-op.	      client.complete(msg, printResultFor('completed'));	      // The AMQP and HTTP transports also have the notion of completing, rejecting or abandoning the message.	      // When completing a message, the service that sent the C2D message is notified that the message has been processed.	      // When rejecting a message, the service that sent the C2D message is notified that the message won't be processed by the device. the method to use is client.reject(msg, callback).	      // When abandoning the message, IoT Hub will immediately try to resend it. The method to use is client.abandon(msg, callback).	      // MQTT is simpler: it accepts the message by default, and doesn't support rejecting or abandoning a message.	    });		    // Create a message and send it to the IoT Hub every second	    var sendInterval = setInterval(function () {	      var windSpeed = 10 + (Math.random() * 4); // range: [10, 14]	      var temperature = 20 + (Math.random() * 10); // range: [20, 30]	      var humidity = 60 + (Math.random() * 20); // range: [60, 80]	      var data = JSON.stringify({ deviceId: 'myFirstDownstreamDevice', windSpeed: windSpeed, temperature: temperature, humidity: humidity });	      var message = new Message(data);	      message.properties.add('temperatureAlert', (temperature &gt; 28) ? 'true' : 'false');	      console.log('Sending message: ' + message.getData());	      client.sendEvent(message, printResultFor('send'));	    }, 2000);		    client.on('error', function (err) {	      console.error(err.message);	    });		    client.on('disconnect', function () {	      clearInterval(sendInterval);	      client.removeAllListeners();	      client.open(connectCallback);	    });	  }	};		// Provide the Azure IoT device client via setOptions with the X509	// Edge root CA certificate that was used to setup the Edge runtime	var options = {	  ca : fs.readFileSync(edge_ca_cert_path, 'utf-8'),	};		client.setOptions(options, function(err) {	  if (err) {	    console.log('SetOptions Error: ' + err);	  } else {	    client.open(connectCallback);	  }	});	</code></pre>	"
