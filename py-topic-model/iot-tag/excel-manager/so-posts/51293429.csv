thread_ID, Id, ParentId, PostType, Score, CreationDate, OwnerID, Body
51293429,51293429,null,1,3,Wed Jul 11 20:03:00 EDT 2018,4668201,"<p><strong>[Context]</strong><br>	I am currently working on a probe balloon. My communication is restricted to messages of the 12 bytes in which I have to transmit several pieces of information. (Altitude, max temperature, longitude, latitude, average acceleration).<br>	The probe is based on a raspberry pi 2 b.</p>		<p><strong>[Question]</strong><br>	I am currently building my datagram and want to store my latitude and longitude as a 32-bit double (lossy). Storage can be done with floating point or fixed point	Are there tools to do this kind of conversion? How else can I do that? (in particular on the rounded party)<br>	I initially planned to work in Java but I can migrate to python.</p>		<p>Thank you in advance</p>	"
51293429,89564912,51293429,3,2,Wed Jul 11 20:26:00 EDT 2018,3474,"What data does your location API provide to your program? Does it use integers or floating point? What coordinate system? What datum? Your question is fairly abstract, so the most specific advice I can give is to take the modulus of your location; you don't need to sacrifice precision, because for a continuously changing location starting from a known point, you should be able to guess the higher-order components."
51293429,89565007,51293429,3,1,Wed Jul 11 20:31:00 EDT 2018,7932271,"Do you have any minimum requirements for accuracy or maximum constraints for range?  Obviously it's a trade-off; if you need to be able to encode any lat/long worldwide your best accuracy will be 65536/180 (approx. 35km) for latitude and 65536/360 for longitude (approx 70km)."
51293429,89565119,51293429,3,2,Wed Jul 11 20:36:00 EDT 2018,3474,"I should also mention that transmitting only the delta between positions would offer a lot of "compression", but I assume that your simple transmission protocol isn't reliable in the sense that lost packets will be resent, so over time as more packets are lost, the uncertainty in the balloon's position will grow. So I suggest transmitting the absolute position. Although, I guess a hybrid approach where you send the absolute position on a low frequency and the delta on a high frequency could be good."
51293429,89565514,51293429,3,3,Wed Jul 11 20:53:00 EDT 2018,5899776,"How can you have a 32 bit double? Double means double precision compared to a single precision float. Doubles are 64 bits, singles or floats are 32 bit."
51293429,89565526,51293429,3,0,Wed Jul 11 20:53:00 EDT 2018,3474,"Also, I should ask: do all your packets have to be the same? Why not send multiple packets to carry all the information you want?"
51293429,89588161,51293429,3,0,Thu Jul 12 12:34:00 EDT 2018,4668201,"My API (GPS sensor: https://yadom.eu/downloadable/download/sample/sample_id/17/) gives me several informations including altitude, longitude and latitude. The altitude is given in meters. Latitude and longitudes in degrees.  	My communication protocol (Sigfox) limits me to 140 messages of 12 bytes each For a flight that will last between 3 and 4 hours.  	To keep a fluid flow of information I wish to make all the information hold in 1 message even if it means losing measurements in precision."
51293429,89588167,51293429,3,0,Thu Jul 12 12:34:00 EDT 2018,4668201,"I cannot guarantee the reliability of the Sigfox network. Lost messages are not returned. So I prefer to speak in absolute positioning. Given the altitude, the mass and the exposure to the winds, my balloon will fly less than 200Km. It is therefore perfectly possible to reduce and refocus the area to cover to increase accuracy (this is already what I do for altitude and temperature).  	Van dench has indeed put his finger on an important element. I had forgotten the existence of the Float type which corresponds well to my needs. And Float <-> double conversion is simple."
51293429,51294028,51293429,2,1,Wed Jul 11 20:54:00 EDT 2018,3690024,"<p>If you want to translate a <code>double</code> to 64-bits, you can use <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/Double.html#doubleToLongBits-double-" rel="nofollow noreferrer"><code>long Double.doubleToLongBits(double value)</code></a>, and <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/Double.html#longBitsToDouble-long-" rel="nofollow noreferrer"><code>double Double.longBitsToDouble(long bits)</code></a> to convert it back.</p>		<p>If you want to convert 32-bit values to <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/Float.html" rel="nofollow noreferrer"><code>Float</code></a> values and back, the corresponding functions are <code>floatToIntBits(...)</code> and <code>intBitsToFloat(...)</code>.</p>		<p>For <code>double</code> to 32 bits, I'd use a 2-step conversion, converting to <code>float</code> first:</p>		<pre><code>double val = ...;	int bits = Float.floatToIntBits( (float) val );	</code></pre>		<p>And back:</p>		<pre><code>int bits = ...;	double val = (double) Float.intBitsToFloat(bits);	</code></pre>		<hr>		<p>Packing and unpacking directly to a buffer:</p>		<pre><code>ByteArrayOutputStream baos = new ByteArrayOutputStream(20);	DataOutputStream dos = new DataOutputStream( ... );	dos.writeFloat( altitude );	dos.writeFloat( max_temperature );	dos.writeFloat( longitude );	dos.writeFloat( latitude );	dos.writeFloat( average_acceleration);	byte[] data = baos.toByteArray();	</code></pre>		<p>Of course, this creates a 20 byte buffer (5 x 32 bit floats), not a 12 byte buffer, so you'll need to figure out which values you want as 32 bits, and which you can cram into smaller space.</p>		<p>Unpacking, use a <code>DataInputStream</code> and <code>readFloat()</code>.</p>		<pre><code>ByteArrayInputStream bais = ...	DataInputStream dis = new DataInputStream(bais);	altitude = dis.readFloat();	max_temperature = dis.readFloat();	...etc...	</code></pre>	"
51293429,51294034,51293429,2,2,Wed Jul 11 20:55:00 EDT 2018,57695,"<p>Instead of using a <code>float</code> which is not really designed for a lat/long I suggest using a fraction.  If you multiply by <code>Integer.MAX_VALUE/90</code> for latitude and <code>Integer.MAX_VALUE/180.0</code> for longitude you will get a value which uses a 32-bit value more efficiently.</p>		<pre><code>float lat = 90f;	System.out.println("precision using float: " + (lat - Math.nextDown(lat)) + " degrees");	double ratio = Integer.MAX_VALUE / 90.0;	int val2 = (int) Math.round(90 * ratio);	System.out.println("precision using int: " + 1 / ratio + " degrees");	</code></pre>		<p>prints</p>		<pre><code>precision using float: 7.6293945E-6 degrees	precision using int: 4.190951587721217E-8 degrees	</code></pre>		<p>in short, an <code>int</code> can have more than 100x the precision as it has 32-bits of precision whereas a <code>float</code> has a 23-bit mantissa.</p>		<p>For longitude, this error represents 1.7m for float and 0.94 cm using an <code>int</code> this way. </p>		<p>NOTE: If a 2m error is ok (more accurate than a mobile phone GPS) you might decide that <code>float</code> is simpler to work with.</p>	"
51293429,89565996,51294034,3,1,Wed Jul 11 21:14:00 EDT 2018,3690024,"`MAX_VALUE/90.0` is fine for latitude, but longitudes go from -180 to +180, so you should used `MAX_VALUE/180.0` for longitude.  You can use it for latitude as well, for consistency, at the loss of 1 bit of precision."
51293429,89574840,51294034,3,0,Thu Jul 12 06:51:00 EDT 2018,57695,"@AJNeufeld Good point. Needs a different ratio for longitude."
