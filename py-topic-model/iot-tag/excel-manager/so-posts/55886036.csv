thread_ID, Id, ParentId, PostType, Score, CreationDate, OwnerID, Body
55886036,55886036,null,1,0,Sun Apr 28 00:34:00 EDT 2019,6146758,"<p>I'm creating a UWP program for Raspberry Pi. One of the functions of the program is to send and receive some data from an Arduino.</p>		<p>The problem is when I try sending data to the Arduino rapidly and many times, I end up with <code>System.Runtime.InteropServices.COMException The operation identifier is not valid.</code> originating from <code>DataWriter.DetachStream()</code>.</p>		<p>Sending the data rapidly works just fine, up until a certain amount it seems, where I get the exception thrown.	With "rapid", I mean using an auto clicker to click a button to send data each millisecond.</p>		<p>I've not tried sending data slowly many times in a row to reproduce the issue, as this would probably take a long time (seeing it takes about 10-20 seconds with 1ms delay between transmissions.</p>		<p>I've been searching for a solution to this problem for way too many hours, but I can't seem to find any related questions/solutions.</p>		<pre class="lang-c# prettyprint-override"><code>public sealed partial class LightControl : Page	{	    int Alpha;	    int Red;	    int Green;	    int Blue;		    // This is the handler for the button to send data	    private void LightButton_Click(object sender, RoutedEventArgs e)	    {	        if (!(sender is Button button) || button.Tag == null) return;		        string tag = button.Tag.ToString();		        Alpha = int.Parse(tag.Substring(0, 2), System.Globalization.NumberStyles.HexNumber);	        Red = int.Parse(tag.Substring(2, 2), System.Globalization.NumberStyles.HexNumber);	        Green = int.Parse(tag.Substring(4, 2), System.Globalization.NumberStyles.HexNumber);	        Blue = int.Parse(tag.Substring(6, 2), System.Globalization.NumberStyles.HexNumber);		        SendLightData();	    }		    public async void SendLightData()	    {	        await ArduinoHandler.Current.WriteAsync(ArduinoHandler.DataEnum.LightArduino,	            ArduinoHandler.DataEnum.Light, Convert.ToByte(LightConstants.LightCommand.LightCommand),	            Convert.ToByte(Red), Convert.ToByte(Green), Convert.ToByte(Blue), Convert.ToByte(Alpha),	            WriteCancellationTokenSource.Token);	    }	}	</code></pre>		<pre class="lang-c# prettyprint-override"><code>public class ArduinoHandler	{	    // Code for singleton behaviour. Included for completeness	    #region Singleton behaviour	    private static ArduinoHandler arduinoHandler;		    private static Object singletonCreationLock = new Object();		    public static ArduinoHandler Current	    {	        get	        {	            if (arduinoHandler == null)	            {	                lock (singletonCreationLock)	                {	                    if (arduinoHandler == null)	                    {	                        CreateNewArduinoHandler();	                    }	                }	            }	            return arduinoHandler;	        }	    }		    public static void CreateNewArduinoHandler()	    {	        arduinoHandler = new ArduinoHandler();	    }	    #endregion		    private DataWriter dataWriter;	    private Object WriteCancelLock = new Object();		    public async Task WriteAsync(DataEnum receiver, DataEnum sender,	        byte commandByte1, byte dataByte1, byte dataByte2, byte dataByte3,	        byte dataByte4, CancellationToken cancellationToken)	    {	        try	        {	            dataWriter = new DataWriter(arduinos[receiver].OutputStream);	            byte[] buffer;	            Task&lt;uint&gt; storeAsyncTask;	            lock (WriteCancelLock)	            {	                buffer = new byte[8];	                buffer[0] = Convert.ToByte(receiver);	                buffer[1] = Convert.ToByte(sender);	                buffer[2] = commandByte1;	                buffer[3] = dataByte1;	                buffer[4] = dataByte2;	                buffer[5] = dataByte3;	                buffer[6] = dataByte4;	                buffer[7] = Convert.ToByte('\n');		                cancellationToken.ThrowIfCancellationRequested();	                dataWriter.WriteBytes(buffer);	                storeAsyncTask = dataWriter.StoreAsync().AsTask(cancellationToken);	            }	            uint bytesWritten = await storeAsyncTask;	            Debug.Write("\nSent: " + BitConverter.ToString(buffer) + "\n");                    	        }	        catch (Exception e)	        {	            Debug.Write(e.Message);	        }	        finally	        {	            dataWriter.DetachStream();  // &lt;--- I've located the exception to originate from here, using the debugger in Visual Studio	            dataWriter.Dispose();	        }	    }		    public enum DataEnum	    {	        Light = 0x01,	        Piston = 0x02,	        PC = 0x03,	        LightArduino = 0x04	    }	}	</code></pre>		<p>I would expect the Raspberry Pi to send the data to the Arduino, but after a while with rapid data transmission, the exception is thrown.</p>		<h2>Update</h2>		<p>I tried using a local variable for the dataWriter as suggested below, but this causes strange behavior after a while with rapid data transmission. Just as if it slows down. It is worth noting that I don't get an exception anymore.</p>		<p>Quite hard trying to explain how it behaves, but the Debug.Write logs the message I'm sending (which works fine). However, after a while, it seems to "slow down", and even after I stop clicking, the data is being sent once every second or so. It works completely fine up until this point. So I'm wondering if there is a limit of some sort I'm hitting?</p>		<h2>Update 2</h2>		<p>I seem to have found a rather "hacky" and weird solution to the problem.	If I use Serial.write() on the Arduino to send the data back to the Raspberry Pi, it seems to have fixed the issue somehow.</p>		<p>If anyone knows how this worked, I'd be very interested to know :)</p>		<pre class="lang-c prettyprint-override"><code>const int payloadSize = 8;	byte payload[payloadSize]		int numBytes;		// Called each time serial data is available	void serialEvent()	{	  numBytes = Serial.available();	  if (numBytes == payloadSize)	  {	    for (int i = 0; i &lt; payloadSize; i++)	    {	      payload[i] = Serial.read();	      Serial.write(payload[i]); // &lt;--- This line fixed the issue for whatever reason	    }	  }		  checkData(); // Function to do something with the data		  for (int i = 0; i &lt; payloadSize; i++)	  {	    payload[i] = None;	  }	  numBytes = 0;	}	</code></pre>	"
55886036,98463982,55886036,3,0,Mon Apr 29 13:15:00 EDT 2019,6146758,"I'm not sure if I understand this comment, some clarification would be nice."
55886036,98448508,55886036,3,0,Mon Apr 29 01:59:00 EDT 2019,6601582,"If you use `Serial.write()` fixed the issue while what's you used reproduced the issue?"
55886036,55888964,55886036,2,3,Sun Apr 28 09:41:00 EDT 2019,732221,"<p>Your problem originates from the fact that you are using a fire-and-forget approach of working with <code>async</code> method. When you call <code>SendLightData()</code> in quick succession, it doesn't wait for the previous <code>WriteAsync</code> operation to complete. </p>		<p>Once the execution reaches the first actual <code>await</code> expression - which is the <code>await storeAsyncTask</code> line, the UI thread is freed up to handle another button click.</p>		<p>This new button click can start executing and overwrite the <code>dataWriter</code> field in the same instance of <code>ArduinoHandler</code>. When the first <code>storeAsyncTask</code> finishes executing, it will actually datach the <code>dataWriter</code> of the second call, not its own. This can lead to multiple different sorts of issues and race conditions.</p>		<p>So you must make sure that it is not possible to click the button <em>before</em> the previous operation actually executes. You could use a boolean flag for that as a simple solution.</p>		<pre><code>private bool _isWorking = false;	public async void SendLightData()	{	    if (!_isWorking)	    {	        try	        {	           _isWorking = true;	           await ArduinoHandler.Current.WriteAsync(ArduinoHandler.DataEnum.LightArduino,	    ArduinoHandler.DataEnum.Light, Convert.ToByte(LightConstants.LightCommand.LightCommand),	    Convert.ToByte(Red), Convert.ToByte(Green), Convert.ToByte(Blue), Convert.ToByte(Alpha),	    WriteCancellationTokenSource.Token);	        }	        finally	        {	           _isWorking = false;	        }	}	</code></pre>		<p>This will ensure that two operations never execute simultaneously.</p>		<p>Other solution could be to not store the data writer as a field and just have it as a <strong>local variable</strong>. When you avoid all shared state between the calls, you can safely know that there will be no race condition stemming from overwriting.</p>	"
55886036,98460462,55888964,3,0,Mon Apr 29 11:28:00 EDT 2019,732221,"I am not sure why the final solution helped, but to the first question - it is quite possible that if you performed many sends in quick succession, some kind of throttling took place and the new attempts had to wait to get "handle" for the connection."
55886036,98460493,55888964,3,0,Mon Apr 29 11:29:00 EDT 2019,732221,"The `lock` didn't help because it the problem arose when one thread was in the process of `await storeAsyncTask` which was already __outside__ the `lock` statement. So one task was in progress, other changed the `dataWriter` variable in the meantime."
55886036,98467322,55888964,3,0,Mon Apr 29 14:54:00 EDT 2019,732221,"Great, I am glad it helped to clarify it a bit at least :-)"
55886036,98436072,55888964,3,0,Sun Apr 28 10:50:00 EDT 2019,6146758,"Updated the question with your suggestion of using a local variable. Didn't seem to fully fix the issue, although I don't get an exception anymore."
55886036,98436308,55888964,3,0,Sun Apr 28 11:07:00 EDT 2019,6146758,"And by the way, shouldn't the `lock(WriteCancelLock)` avoid that problem altogether? (I see now that I forgot to add the member `WriteCancelLock`, so updated the code to include that)"
55886036,98463808,55888964,3,1,Mon Apr 29 13:10:00 EDT 2019,6146758,"That makes sense, I didn't really think twice about the await call being outside of the `lock`. Thanks for helping out, even though I think I'll stick with the "send data back to the Raspberry"-solution, as this seems to work perfectly.	I'll mark your answer as correct, however, as it answers the original question. Just in case someone in the future encounters this issue :)"
