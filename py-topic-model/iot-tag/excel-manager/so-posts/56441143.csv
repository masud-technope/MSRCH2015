thread_ID, Id, ParentId, PostType, Score, CreationDate, OwnerID, Body
56441143,56441143,null,1,0,Tue Jun 04 09:29:00 EDT 2019,11597976,"<p>I am working on a project in which I need to communicate with an IOT device(Raspberry Pi). This IOT device makes a hotspot and I make a connection to the Wi-Fi created by Pi. But in Android 9 request are redirecting to mobile data instead of Wifi.</p>		<p>In staring I was facing an issue that if Mobile data is also on then mobile redirect all request to Mobile Data instead of Wifi. But Mobile data is off then it was working fine also in Android 9. To make it works with Mobile data I used the forced method, to make a forced Wi-Fi connection(see forceWifiUsage method). Using this method before making the connection using(findAndConnect) Method and it starts working with mobile data also. But it is not working in Android 9 even though  Mobile data is off. What is the reason in Android 9 i can't communicate to wifi. </p>		<p>public void forceWifiUsage(boolean useWifi) {	        boolean canWriteFlag = false;</p>		<pre><code>    if (useWifi) {	        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) {		            if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.N) {	                canWriteFlag = true;	                // Only need ACTION_MANAGE_WRITE_SETTINGS on 6.0.0, regular permissions suffice on later versions	            } else if (Build.VERSION.RELEASE.toString().equals("6.0.1")) {	                canWriteFlag = true;	                // Don't need ACTION_MANAGE_WRITE_SETTINGS on 6.0.1, if we can positively identify it treat like 7+	            } else if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) {	                // On M 6.0.0 (N+ or higher and 6.0.1 hit above), we need ACTION_MANAGE_WRITE_SETTINGS to forceWifi.	                canWriteFlag = Settings.System.canWrite(reactContext);	                if (!canWriteFlag) {	                    Intent intent = new Intent(Settings.ACTION_MANAGE_WRITE_SETTINGS);	                    intent.setData(Uri.parse("package:" + reactContext.getPackageName()));	                    intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);		                    reactContext.startActivity(intent);	                }	            }		            if (((Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) &amp;&amp; canWriteFlag) || ((Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &amp;&amp; !(Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M))) {	                System.out.println("before ConnectivityManager");	                final ConnectivityManager manager = (ConnectivityManager) reactContext	                        .getSystemService(Context.CONNECTIVITY_SERVICE);	                NetworkRequest.Builder builder;	                builder = new NetworkRequest.Builder();	                //set the transport type do WIFI	                builder.addTransportType(NetworkCapabilities.TRANSPORT_WIFI);	                System.out.println("ConnectivityManager:- "+manager);		                manager.requestNetwork(builder.build(), new ConnectivityManager.NetworkCallback() {	                    @Override	                    public void onAvailable(Network network) {	                    System.out.println("onAvailable:- "+network);		                        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) {	                            manager.bindProcessToNetwork(network);	                            System.out.println("bindProcessToNetwork:- ");	                        } else {	                            //This method was deprecated in API level 23	                            ConnectivityManager.setProcessDefaultNetwork(network);	                        }		                        try {	                        } catch (Exception e) {	                            e.printStackTrace();	                        }	                        manager.unregisterNetworkCallback(this);	                    }	                });	            }	        }	    } else {	        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) {	            ConnectivityManager manager = (ConnectivityManager) reactContext	                    .getSystemService(Context.CONNECTIVITY_SERVICE);	            manager.bindProcessToNetwork(null);	        } else if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) {	            ConnectivityManager.setProcessDefaultNetwork(null);	        }	    }	}					public void findAndConnect(String ssid, String password) {	    System.out.println("bindProcessToNetwork:- ");	    List &lt; ScanResult &gt; results = wifi.getScanResults();	    boolean connected = false;	    for (ScanResult result: results) {	        String resultString = "" + result.SSID;	        System.out.println("ScanResult:- "+resultString);	        if (ssid.equals(resultString)) {	            System.out.println("if ssid equals:- "+resultString);	            connected = connectTo(result, password, ssid);	        }	    }		}	//Method to connect to WIFI Network	public Boolean connectTo(ScanResult result, String password, String ssid) {	    //Make new configuration	    WifiConfiguration conf = new WifiConfiguration();		    //clear alloweds	    conf.allowedAuthAlgorithms.clear();	    conf.allowedGroupCiphers.clear();	    conf.allowedKeyManagement.clear();	    conf.allowedPairwiseCiphers.clear();	    conf.allowedProtocols.clear();		    // Quote ssid and password	    conf.SSID = String.format("\"%s\"", ssid);		    WifiConfiguration tempConfig = this.IsExist(conf.SSID);	    if (tempConfig != null) {	        wifi.removeNetwork(tempConfig.networkId);	    }		    String capabilities = result.capabilities;		    // appropriate ciper is need to set according to security type used	    if (capabilities.contains("WPA") || capabilities.contains("WPA2") || capabilities.contains("WPA/WPA2 PSK")) {	                System.out.println("WPA:-");	        // This is needed for WPA/WPA2 	        // Reference - https://android.googlesource.com/platform/frameworks/base/+/refs/heads/master/wifi/java/android/net/wifi/WifiConfiguration.java#149	        conf.allowedAuthAlgorithms.set(WifiConfiguration.AuthAlgorithm.OPEN);		        conf.allowedGroupCiphers.set(WifiConfiguration.GroupCipher.CCMP);	        conf.allowedGroupCiphers.set(WifiConfiguration.GroupCipher.TKIP);		        conf.allowedKeyManagement.set(WifiConfiguration.KeyMgmt.WPA_PSK);		        conf.allowedPairwiseCiphers.set(WifiConfiguration.PairwiseCipher.CCMP);	        conf.allowedPairwiseCiphers.set(WifiConfiguration.PairwiseCipher.TKIP);		        conf.allowedProtocols.set(WifiConfiguration.Protocol.RSN);	        conf.allowedProtocols.set(WifiConfiguration.Protocol.WPA);	        conf.status = WifiConfiguration.Status.ENABLED;	        conf.preSharedKey = String.format("\"%s\"", password);		    } else if (capabilities.contains("WEP")) {	        System.out.println("WEP:-");	        // This is needed for WEP	        // Reference - https://android.googlesource.com/platform/frameworks/base/+/refs/heads/master/wifi/java/android/net/wifi/WifiConfiguration.java#149	        conf.wepKeys[0] = "\"" + password + "\"";	        conf.wepTxKeyIndex = 0;	        conf.allowedAuthAlgorithms.set(WifiConfiguration.AuthAlgorithm.OPEN);	        conf.allowedAuthAlgorithms.set(WifiConfiguration.AuthAlgorithm.SHARED);	        conf.allowedKeyManagement.set(WifiConfiguration.KeyMgmt.NONE);	        conf.allowedGroupCiphers.set(WifiConfiguration.GroupCipher.WEP40);	    } else {	        System.out.println("ELSE:-");	        conf.allowedKeyManagement.set(WifiConfiguration.KeyMgmt.NONE);	    }		    List&lt;WifiConfiguration&gt; mWifiConfigList = wifi.getConfiguredNetworks();	    if (mWifiConfigList == null) {	        return false;	    }		    int updateNetwork = -1;		    // Use the existing network config if exists	    for (WifiConfiguration wifiConfig : mWifiConfigList) {	        if (wifiConfig.SSID.equals(conf.SSID)) {	            conf=wifiConfig;	            updateNetwork=conf.networkId;	        }	    }		    // If network not already in configured networks add new network	    if ( updateNetwork == -1 ) {	      updateNetwork = wifi.addNetwork(conf);	      wifi.saveConfiguration();	    }		    // if network not added return false	    if ( updateNetwork == -1 ) {	        return false;	    }		    // disconnect current network	    boolean disconnect = wifi.disconnect();	    if ( !disconnect ) {	        return false;	    }		    // enable new network	    boolean enableNetwork = wifi.enableNetwork(updateNetwork, true);	    if ( !enableNetwork ) {	        return false;	    }		    return true;	}	</code></pre>	"
