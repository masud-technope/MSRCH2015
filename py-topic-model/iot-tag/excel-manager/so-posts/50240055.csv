thread_ID, Id, ParentId, PostType, Score, CreationDate, OwnerID, Body
50240055,50240055,null,1,3,Tue May 08 18:26:00 EDT 2018,9760395,"<p>I am trying to configure SQLite to run on an embedded system (ARM® Cortex®-M7). I have downloaded the amalgamation from the SQLite website, imported it into the project, and added the following symbols: SQLITE_THREADSAFE=0, SQLITE_OS_OTHER=1, SQLITE_OMIT_WAL=1 to allow it to compile.</p>		<p>I then downloaded test_onefile.c (available here: <a href="http://www.sqlite.org/vfs.html" rel="nofollow noreferrer">http://www.sqlite.org/vfs.html</a>) which is supposed to allow SQLite to operate directly on embedded media without using an intermediate filesystem and imported it into the project (I was also sure to provide an sqlite3_os_init() function to register the VFS).</p>		<pre><code>SQLITE_API int sqlite3_os_init(void)	{	    extern int fs_register(void);	    return fs_register();	}	</code></pre>		<p>In a separate file fs_register() looks like this:</p>		<pre><code>/*	** This procedure registers the fs vfs with SQLite. If the argument is	** true, the fs vfs becomes the new default vfs. It is the only publicly	** available function in this file.	*/	int fs_register(void)	{	    if (fs_vfs.pParent) return SQLITE_OK;		    fs_vfs.pParent = sqlite3_vfs_find(0);	    fs_vfs.base.mxPathname = fs_vfs.pParent-&gt;mxPathname;	    fs_vfs.base.szOsFile = MAX(sizeof(tmp_file), sizeof(fs_file));	    return sqlite3_vfs_register(&amp;fs_vfs.base, 0);	}	</code></pre>		<p>I can successfully register a filesystem, open a database, and prepare SQL statements using sqlite3_register_vfs(), sqlite3_open(), and sqlite3_prepare().	When opening a database I am sure to use the ":memory:" string to create the database in memory rather than as a file. </p>		<pre><code>static void TestSQLiteOpenDB(void)	{	    /******** setup ********************************/	    sqlite3 *db;	    int rc;		    /******** run element/component under test *****/	    rc = sqlite3_open(":memory:", &amp;db);	    sqlite3_close(db);		    /******** assertion test ***********************/	    TEST_ASSERT_EQUAL_INT(SQLITE_OK, rc);	}	</code></pre>		<p>My issue is when trying to run sqlite3_exec(). The program crashes when the following piece of code from test_onefile.c is called:</p>		<pre><code>/*	** Populate the buffer pointed to by zBufOut with nByte bytes of	** random data.	*/	static int fsRandomness(sqlite3_vfs *pVfs, int nByte, char *zBufOut)	{	   sqlite3_vfs *pParent = ((fs_vfs_t *)pVfs)-&gt;pParent;	   return pParent-&gt;xRandomness(pParent, nByte, zBufOut);	}	</code></pre>		<p>If I change this function to simply return 0, it appears to work. I can then create tables, insert data into tables etc...</p>		<p>My question is this: Is there a need in SQLite to populate this buffer with random data or is this workaround ok? I do not want to create further headaches for myself but it was a nightmare to track this down as the point of failure and I can not quite wrap my head around what is happening. </p>	"
50240055,50241371,50240055,2,3,Tue May 08 19:56:00 EDT 2018,11654,"<p>SQLite uses this randomness for temporary files, to force changes in journal/WAL files, to generate unique column names, and when autoincremented IDs overflow.</p>		<p>If the returned value is constant, some of these might go into an infinite loop, so you should attempt to get actual randomness. (It does not need to be cryptographically secure.)</p>	"
