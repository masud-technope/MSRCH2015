thread_ID, Id, ParentId, PostType, Score, CreationDate, OwnerID, Body
50125585,50125585,null,1,1,Wed May 02 00:25:00 EDT 2018,4265370,"<p>I am trying to have an IoT device (ESP32) use Wifi AP mode, so that I can connect my cellphone to it and visit a webpage hosted on the device in order to see some data.</p>		<p>By doing some DNS shenanigans, I do get the "Sign in to network" pop-up to appear.</p>		<p>When I tap on the 'sign in' popup, a page from my IoT device appears correctly.</p>		<p>If I use any regular browser to visit the devices IP, my phone refuses to connect.</p>		<p>If I disable mobile data, I can connect to my device using browsers.</p>		<p>It seems that Android refuses to route traffic to a wifi network that doesn't appear to offer internet connectivity.</p>		<p>I looked at the routing tables (ip route show table 0) and the default route does seem to be to my device, but all the browsers seem to ignore it.</p>		<p>I am assuming that this is some anti-spoofing protection against rogue wifi hotspots - but how does the webview in the 'sign in' popup circumvent this?</p>		<p>Would i have to hack together some custom webview wrapper in order to be able to connect to the IoT device (over a LAN IP over Wifi) and the internet (3G/4G) simultaneously?</p>		<p>I tried telling the IoT device to hand out 0.0.0.0 as the default gw, but this only had the effect of disabling the sign-in pop-up.</p>	"
50125585,50125659,50125585,2,1,Wed May 02 00:38:00 EDT 2018,337455,"<p>Look into using <code>ConnetivityManager.requestNetwork()</code>. This allows you to bind a process to a particular network interface. Something like,</p>		<pre><code>   NetworkRequest.Builder request = new NetworkRequest.Builder();	   request.addCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET);	   request.addTransportType(NetworkCapabilities.TRANSPORT_WIFI);		   connectivityManager.requestNetwork(request.build(), ...);	</code></pre>		<p>Look at the docs, but the second argument is a callback for when the network is available. Something like,</p>		<pre><code>        @Override	        public void onAvailable(Network network) {	            if (connectivityManager.bindProcessToNetwork(network)) {	                // success	            } else {	                // fail	            }	        }	</code></pre>		<p>Undo the binding with <code>ConnectivityManager.unregisterNetworkCallback()</code> and <code>.bindProcessToNetwork(null)</code>. E.g.,</p>		<pre><code>protected void releaseTransport() {	    if (requestTransportCallback != null) {	        connectivityManager.unregisterNetworkCallback(requestTransportCallback);	        requestTransportCallback = null;	        connectivityManager.bindProcessToNetwork(null);	    }	}	</code></pre>		<p>Good luck.</p>	"
50125585,87306719,50125659,3,0,Wed May 02 22:08:00 EDT 2018,4265370,"I will - but i'd like to wait a while to see if there is some other less complicated way, maybe. Like setting an invalid default gateway or something?	I just think it's too annoying that an Android phone can't route a subnet through wifi, while using the mobile data connection as the default gateway?"
50125585,87295738,50125659,3,0,Wed May 02 15:51:00 EDT 2018,4265370,"Thank you. I bet that's how the 'sign into network' window does it. It seems horrendously complicated for simply achieving standard IP routing behaviour (more specific routes get priority over more generic ones), though."
50125585,87295915,50125659,3,0,Wed May 02 15:56:00 EDT 2018,337455,"Feel free to accept this answer if it answered your question."
