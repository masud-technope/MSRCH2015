thread_ID, Id, ParentId, PostType, Score, CreationDate, OwnerID, Body
39795289,39795289,null,1,0,Fri Sep 30 15:43:00 EDT 2016,4586493,"<p>I am trying to read data from a Bosch BME280 on Windows IoT Core. I am able to reset the chip, read the chip ID, get the trimming values and read the temp/press/hum values (burst mode). However, the compensated values are not correct. Here are the values I am getting now. I am hoping someone can share some values that I can use for comparison. Will post code in follow on post. Thanks.</p>		<p>DT1 0x196e, DT2 0x7e66, DT3 0x3200	DP1 0xc78f, DP2 0xded5, DP3 0xd00b, DP4 0xae1b, DP5 0xf00, DP6 0xf9ff, DP7 0xac26, DP8 0xad8, DP9 0xbd10	DH1 0x4b, DH2 0x6d01, DH3 0x0, DH4 0x1308, DH5 0x800, DH6 0x1e	Raw Temp: 0x7fd10, Raw Press: 0x581bc, Raw Humid: 0x6cca</p>		<p>Compensated values here:	BME280: Temp: 187.36c Pressure: 1344.55 millibars Humidity: 100 %rH</p>		<p>I am sure I am just doing something dumb, just need a little nudge in the right direction. Thanks.</p>		<p>Definitions of commands and way I read the trimming values. (just temp in example)</p>		<pre><code>    public static class BME280Commands	{	    public static byte[] ChipID = {0xD0 };	    public static byte[] Version = { 0xD1 };	    public static byte[] SoftReset = { 0xE0, 0xB6 };	    public static byte[] ControlHumidity = { 0xF2, 0x04 };  // second parm was 0x01	    public static byte[] Status = { 0xF3 };	    public static byte[] Control = { 0xF4, 0x91 };          // second parm was 0x87	    public static byte[] Control1 = { 0xf4, 0x3f };	    public static byte[] Config = { 0xF5, 0x16 };	    public static byte[] PressureData = { 0xF7 };	    public static byte[] TemperatureData = { 0xFA };	    public static byte[] HumidityData = { 0xFD };	    public static byte[] DIG_T1 = { 0x88 };	    public static byte[] DIG_T2 = { 0x8A };	    public static byte[] DIG_T3 = { 0x8C };	    public static byte[] DIG_P1 = { 0x8E };	    public static byte[] DIG_P2 = { 0x90 };	    public static byte[] DIG_P3 = { 0x92 };	    public static byte[] DIG_P4 = { 0x94 };	    public static byte[] DIG_P5 = { 0x96 };	    public static byte[] DIG_P6 = { 0x98 };	    public static byte[] DIG_P7 = { 0x9A };	    public static byte[] DIG_P8 = { 0x9C };	    public static byte[] DIG_P9 = { 0x9E };	    public static byte[] DIG_H1 = { 0xA1 };	    public static byte[] DIG_H2 = { 0xE1 };	    public static byte[] DIG_H3 = { 0xE3 };	    public static byte[] DIG_H4 = { 0xE4 };	    public static byte[] DIG_H5 = { 0xE5 };	    public static byte[] DIG_H6 = { 0xE7 };	    public static byte ExpectedChipId = 0x60;	    public static byte SlaveAddress = 0x77;	    public static byte SoftResetCode = 0xb6;	    public Configure()	    {	        var data = new byte[1];	        bme280Sensor.WriteRead(BME280Commands.SoftReset, data);	        bme280Sensor.WriteRead(BME280Commands.ChipID, Id);	        if (Id[0] == BME280Commands.ExpectedChipId)	        {  // How I read the trimming values	            bme280Sensor.WriteRead(BME280Commands.DIG_T1, buf2);	            _digT1 = (UInt32)((buf2[0] &lt;&lt; 8) | buf2[1]);	            bme280Sensor.WriteRead(BME280Commands.DIG_T2, buf2);	            _digT2 = ((buf2[0] &lt;&lt; 8) | buf2[1]);	            bme280Sensor.WriteRead(BME280Commands.DIG_T3, buf2);	            _digT3 = ((buf2[0] &lt;&lt; 8) | buf2[1]);	        }	   }	</code></pre>		<p>How I read the actual values</p>		<pre><code>    var buf8 = new byte[8];	    bme280Sensor.Write(BME280Commands.ControlHumidity);	    bme280Sensor.Write(BME280Commands.Control);		    bme280Sensor.WriteRead(BME280Commands.PressureData, buf8);	    _rawPress = (buf8[0] &lt;&lt; 16 | buf8[1] &lt;&lt; 8 | buf8[2]) &gt;&gt; 4;	    _rawTemp = (buf8[3] &lt;&lt; 16 | buf8[4] &lt;&lt; 8 | buf8[5]) &gt;&gt; 4;	    _rawHumid = (buf8[6] &lt;&lt; 8) | buf8[7];	</code></pre>	"
39795289,39827042,39795289,2,1,Mon Oct 03 08:06:00 EDT 2016,5730046,"<p>I think you are doing everything right.</p>		<p>However, following the raw values you provide, and I use the below math to calculate compensated temperature, for example,</p>		<pre><code>        int _rawTemp = 0x7fd10;	        int _digT1 = 0x196e;	        int _digT2 = 0x7e66;	        int _digT3 = 0x3200;		        int var1 = (((_rawTemp &gt;&gt; 3 - _digT1 &lt;&lt; 1)) * _digT2) &gt;&gt; 11;	        int var2 = (((((_rawTemp &gt;&gt; 4) - (_digT1)) * ((_rawTemp &gt;&gt; 4) - (_digT1))) &gt;&gt; 12) * (_digT3)) &gt;&gt; 14;	        int t_fine = var1 + var2;	        int temperature = ((t_fine) * 5 + 128) &gt;&gt; 8;	</code></pre>		<p>And I get 2559, which reads 25.59degreeC.</p>		<p>See to 	<a href="https://github.com/BoschSensortec/BME280_driver/blob/master/bme280.c" rel="nofollow">https://github.com/BoschSensortec/BME280_driver/blob/master/bme280.c</a></p>		<p>How did you calculate compensated values?</p>	"
39795289,66961622,39827042,3,0,Mon Oct 03 16:16:00 EDT 2016,4586493,"Thank you very much, getting closed but just not getting this. Please try your same logic with a _rawTemp=0x80200. What I am seeing is that the bit shifts are wrong when the sign bit is set. I believe _rawTemp should be a uint but that messes everything up on my end. I also tried the floating point routines without success. However, I think you have me pointed the right direction. (I am getting the proper values from the chip)"
39795289,66973205,39827042,3,0,Mon Oct 03 23:03:00 EDT 2016,5730046,"@TomLindley, with 0x80200 I get -2545, I guess that reads -25.45degreeC?"
39795289,71187109,39827042,3,0,Thu Feb 02 15:04:00 EST 2017,104109,"It looks like your gathering of the calibration data is wrong. Some of the dig_xx values are signed shorts you're treating them all as unsigned shorts. Also, you should read all of the calibration registers in one shot instead of asking for a few bytes at a time."
