thread_ID, Id, ParentId, PostType, Score, CreationDate, OwnerID, Body
53323371,53323371,null,1,2,Thu Nov 15 16:02:00 EST 2018,2071323,"<p>I was trying Socket.io (server and client) for my personal project. As it is my first try with node.js even javascript and mongodb I am bit confused about performance of my server.</p>		<p>I have created a complex real time system with many events and many rooms. Server have very limited events but clients have too many events. These events are distributed under rooms. </p>		<p>For example - </p>		<ul>	<li><p>Room R1 >>	Event R1E1,	Event R1E2,	Event R1E3....	Event R1EN</p></li>	<li><p>Room R2 >>	Event R2E1,	Event R2E2,	Event R2E3....	Event R2EN</p></li>	</ul>		<p>All the data is stored in mongodb. Working awesome.</p>		<p>But issue arise when few clients (5-8) with 10-15 events registered start sending data. Server initially works fine but after couple of minutes it stops responding. Clients stay connected even server is not responding.  Requests are pile up. Sometime server receive last sessions request.</p>		<p>It all start when the ultimate device start registering events. <strong>So I want to know how many events a socket.io can handle ?</strong></p>		<p><strong>P.S.</strong> Here what I think "event" is -</p>		<pre><code>io.on('event', function(msg){	    console.log( msg);	});	</code></pre>		<p><strong>Edit 2</strong></p>		<p>As I studied about node.js, a node is basically a process which runs on a single thread, if it requires to process other things it starts another node (an async thread), leaves new thread alone doing it's process and return to main thread running. If we want to process some sequences of process we use "async/await". </p>		<p>In my case I am using async at only one place when client first connect. Here I query 3 different collections of mongodb and return the data on an event.</p>		<p>My server is currently running on a MacBook pro (16 GB RAM, i7 6th gen quad core). It should handle at least 4-6 concurrent threads.</p>		<p>I have created a load test, 100000 different events distributed under 1000 rooms with 5 request per second querying db. It was working fine. Almost 40% RAM and 250% CPU was max laod.</p>		<p>My connection to db is persistent mean I connect to db as soon as server starts and keep that connection reference alive.</p>		<p><strong>So what is the issue?</strong></p>	"
53323371,93527670,53323371,3,0,Thu Nov 15 16:13:00 EST 2018,2012017,"I don't have a definitive answer for you, but I would assume the bottleneck is probably somewhere in the handling of your events, rather than with Socket.io itself.  That being said, if you expect your application to grow, I would start looking at how to set up multiple nodes with socket.io (https://socket.io/docs/using-multiple-nodes/#Passing-events-between-nodes).  That alone may help things by putting the event handlers into separate process loops."
53323371,93527867,53323371,3,0,Thu Nov 15 16:19:00 EST 2018,2071323,"in my case then server and clients will have many "redis". I have tested performance benchmarks it was good and current scenario have small fraction of that benchmark test. so technically it should work."
53323371,53323631,53323371,2,2,Thu Nov 15 16:15:00 EST 2018,816620,"<blockquote>	  <p>So I just want to know how many events a socket.io can handle ?</p>	</blockquote>		<p>First off, it's not clear if you're talking about how many event handlers a socket.io server can have or whether you're asking about how many real-time events (as in events/sec) a socket.io server can handle.</p>		<p>On the first item, there is no coded limit to how many event handlers a socket.io server can handle.  A socket derives from an EventEmitter and it uses the EventEmitter's listener capabilities to allow someone to listen for events.  There are no coded limits for that infrastructure and there's not even really a practical limit either as it's a pretty lightweight system.</p>		<p>In general a system that requires thousands of separately coded event listeners probably could be designed more efficiently other ways, but we'd have to see more detail on what you're doing to know how to advise more specifically.</p>		<hr>		<p>As for how many messages/sec a socket.io server can handle, that totally depends upon what the server is doing to process each message, how much bandwidth your server has, how fast your server is at processing each message and so on.</p>		<hr>		<p>Unless you are flooding your server with tens of thousands of messages at once or doing heavy processing on each message, I would guess that your server difficulties probably have to do with other parts of your server code (likely in what you are doing when messages arrive and how you process them).   </p>		<p>I would also wonder if you have created some sort of circular message loop where clientA emits msgA to server.  server receives that message, does some processing on it and emits msgB to clientA.  clientA receives that message, does some processing on it and some side effect of that processing causes it to emit msgA to server again and you can end up with a never ending message loop.</p>		<p>Also, rooms in socket.io don't "have events" or "receive events" so that part of your description doesn't really make sense.  You can send an event to all sockets within a room.  But, that actually just causes the server to loop through all members of a given room and send them each a message individually.</p>		<hr>		<p>Per your edit, if an "event" is this:</p>		<pre><code>io.on('event', function(msg){	    console.log( msg);	});	</code></pre>		<p>Then, the number of events that your server can handle per second depends upon all sorts of system configuration variables (bandwidth, CPU, database performance, etc...) and how much processing you do to handle each incoming event.  Here's a list of things to do:</p>		<ol>	<li>Make absolutely sure you have no synchronous I/O anywhere in your server other than at server startup time as that will instantly ruin your ability to have lots of "in process" events going at once.  </li>	<li>Make the code that processes each event as efficient as possible.  If you're consulting the database on each event, that will likely set your database up as a bottleneck.</li>	<li>Design some tests to figure out where your first bottleneck in processing is.</li>	<li>Improve the performance characteristics of that first bottleneck.</li>	<li>Rinse, lather repeat until you've removed/improved the first N places you were running into a bottleneck.</li>	</ol>		<p>Keep in mind that a single node.js instance has only one thread that is running your Javascript.  So, if you wanted to be able to process 100 messages/sec, you can use no more than 10ms of CPU to process each message (1000ms/sec divided by 100 messages/sec = 10ms/message).  You can fan out to multiple CPUs by implementing clustering or firing up multiple processes to process a work queue if CPU is your actual bottleneck, but you'd have to first determine that with testing.</p>	"
53323371,93528147,53323631,3,0,Thu Nov 15 16:26:00 EST 2018,2071323,"I can't put all code here but I can explain how it going to work. Think about an end to end encrypted system talking on just one channel (or in room). Separately db, server, clients working fine. Server was able to handle 100000 events distributed in 1000 rooms with 5 requests per second querying db. It was taking about 40% RAM and 250% CPU."
53323371,93528369,53323631,3,0,Thu Nov 15 16:33:00 EST 2018,2071323,"Question updated."
53323371,93528899,53323631,3,0,Thu Nov 15 16:48:00 EST 2018,816620,"@HarvantS.Choudhary - I'm not sure you've seen the edits to my answer.  If you're really asking how many messages/sec your server can handle, that depends entirely upon things that are not disclosed here and could ultimately only be answered by devising an appropriate test for your server in your data center anyway since it depends upon a whole lot of environmental factors (server configuration, bandwidth, number of active clients, processing on each message, etc...).  Also, if you have ANY synchronous I/O code in  your server, that could also ruin scalability."
53323371,93541403,53323631,3,0,Fri Nov 16 02:45:00 EST 2018,2071323,"Yeah it helped. I will update my load test code will try those approaches."
53323371,93531456,53323631,3,0,Thu Nov 15 18:07:00 EST 2018,816620,"@HarvantS.Choudhary - Added some more to the end of my answer."
