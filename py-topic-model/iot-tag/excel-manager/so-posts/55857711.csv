thread_ID, Id, ParentId, PostType, Score, CreationDate, OwnerID, Body
55857711,55857711,null,1,0,Thu Apr 25 21:12:00 EDT 2019,8711769,"<p>I have a C# Windows IoT Background application I have created.  That application has multiple threads in the ThreadPool that run indefinitely.  </p>		<p>These threads need to be able to read/write to global variables in the main thread, but I am not sure how to accomplish this.  Here is an example of what I am trying to do:</p>		<pre><code>// main task	public sealed class StartupTask : IBackgroundTask	{	    private static BackgroundTaskDeferral _Deferral = null;		    private static MyThreadClass1 thread1 = null;	    private static MyThreadClass2 thread2 = null;	    private static MyThreadClass3 thread3 = null;		    List&lt;Object&gt; MyDevices = null;		    public async void Run(IBackgroundTaskInstance taskInstance)	    {	        _Deferral = taskInstance.GetDeferral();		        MyDevices = GetDeviceList();		        thread1 = new MyThreadClass1();	        await ThreadPool.RunAsync(workItem =&gt;	        {	            thread1.Start();	        });		        thread2 = new MyThreadClass2();	        await ThreadPool.RunAsync(workItem =&gt;	        {	            thread2.Start();	        });		        thread3 = new MyThreadClass3();	        await ThreadPool.RunAsync(workItem =&gt;	        {	            thread3.Start();	        });	    }	}		internal class MyThreadClass1	{	    public async void Start()	    { }	}		internal class MyThreadClass2	{	    public async void Start()	    { }	}		internal class MyThreadClass3	{	    public async void Start()	    { }	}	</code></pre>		<p>In any of the three threads that are running, I need to be able to read and write to <code>List&lt;Object&gt; MyDevices</code>.</p>		<p>The threads all have different functions, but they all interact with "MyDevices", so if one thread makes a change to that list, the other threads need to know about the change right away.</p>		<p>What is the best way to go about doing this?</p>		<p>Thanks!</p>	"
55857711,98388830,55857711,3,0,Fri Apr 26 09:10:00 EDT 2019,259769,"There are no global variables in C# - just `static` fields in classes. More or less the same, but different."
55857711,55858119,55857711,2,0,Thu Apr 25 21:51:00 EDT 2019,2962027,"<p>One thing you might want to consider using is an <a href="https://docs.microsoft.com/en-us/dotnet/api/system.collections.objectmodel.observablecollection-1?view=netframework-4.8" rel="nofollow noreferrer"><code>ObservableCollection</code></a>. This class implements the <code>INotifyPropertyChanged</code> interface, which notifies any listeners of changes to the underlying collection.</p>		<p>Next, you'll want to implement an event handler for <code>PropertyChanged</code> in your <code>Thread</code> classes like so (I recommend making either an interface or base class that handles this since you appear to be using different classes for each <code>Thread</code>):</p>		<pre><code>public sealed class MyThreadBase	{	    private ObservableCollection&lt;object&gt; MyDevices;		    public MyThreadBase(ObservableCollection&lt;object&gt; deviceList)	    {	        MyDevices = deviceList;	        MyDevices.PropertyChanged += MyDevices_PropertyChanged; // Register listener	    }		    private void MyDevices_PropertyChanged(object sender, PropertyChangedEventArgs e)	    {	        lock (MyDevices)	        {	            // Do something with the data...	        }	    }	}	</code></pre>		<p>The <code>lock</code> statement is used so that the thread is blocked when another thread is reading or writing to <code>MyDevices</code>. This is typically important in synchronization and is known as the <a href="https://en.wikipedia.org/wiki/Readers%E2%80%93writers_problem" rel="nofollow noreferrer">readers-writers problem</a>. I'd suggest reading up on that and possible solutions as well.</p>		<p>If you intend, however, for each thread to iterate over the devices and do something with each one, then you will run into issues, as iterating over a changing collection is not a good idea (and when using a <code>foreach</code> loop, will actually throw an exception), so keep that in mind too.</p>	"
55857711,98377581,55858119,3,1,Thu Apr 25 22:00:00 EDT 2019,126995,"I’m not sure what exactly OP wants but I think they want notifications on different threads. Event handlers only execute on one thread, the same one which raised the event."
55857711,55858166,55857711,2,0,Thu Apr 25 21:56:00 EDT 2019,126995,"<blockquote>	  <p>other threads need to know about the change right away</p>	</blockquote>		<p>If you want low latency notifications, threads must spend the majority of time sleeping on something. E.g. executing <code>Dispatcher.Run()</code> that will sleep waiting for messages/tasks to process.</p>		<p>If that’s your case, you can use <code>ObservableCollection</code> instead of List, and write <code>CollectionChanged</code> handler that forwards notifications for your 3 threads. Or if that’s what you want, forward notifications to 2 other threads, excluding the current one, if you won’t want the thread that initiated the change to process changed event.</p>		<p>I'm not sure if the <code>Dispatcher</code> class is available on Windows IoT platform. Definitely not the case for .NET core. Even if not, high-level building blocks to create one are available. Here’s an example implementation that also implements synchronization context, very simple because relies on high-level ConcurrentQueue and BlockingCollection generic classes.</p>		<pre><code>using kvp = KeyValuePair&lt;SendOrPostCallback, object&gt;;		enum eShutdownReason : byte	{	    Completed,	    Failed,	    Unexpected,	}		class Dispatcher : IDisposable	{	    const int maxQueueLength = 100;		    readonly ConcurrentQueue&lt;kvp&gt; m_queue;	    readonly BlockingCollection&lt;kvp&gt; m_block;		    public Dispatcher()	    {	        m_queue = new ConcurrentQueue&lt;kvp&gt;();	        m_block = new BlockingCollection&lt;kvp&gt;( m_queue, maxQueueLength );	        createdThreadId = Thread.CurrentThread.ManagedThreadId;	        prevContext = SynchronizationContext.Current;	        SynchronizationContext.SetSynchronizationContext( new SyncContext( this ) );	    }		    readonly SynchronizationContext prevContext;	    readonly int createdThreadId;		    class SyncContext : SynchronizationContext	    {	        readonly Dispatcher dispatcher;		        public SyncContext( Dispatcher dispatcher )	        {	            this.dispatcher = dispatcher;	        }		        // https://blogs.msdn.microsoft.com/pfxteam/2012/01/20/await-synchronizationcontext-and-console-apps/	        public override void Post( SendOrPostCallback cb, object state )	        {	            dispatcher.Post( cb, state );	        }	    }		    /// &lt;summary&gt;Run the dispatcher. Must be called on the same thread that constructed the object.&lt;/summary&gt;	    public eShutdownReason Run()	    {	        Debug.Assert( Thread.CurrentThread.ManagedThreadId == createdThreadId );		        while( true )	        {	            kvp h;	            try	            {	                h = m_block.Take();	            }	            catch( Exception ex )	            {	                ex.logError( "Dispatcher crashed" );	                return eShutdownReason.Unexpected;	            }	            if( null == h.Key )	                return (eShutdownReason)h.Value;		            try	            {	                h.Key( h.Value );	            }	            catch( Exception ex )	            {	                ex.logError( "Exception in Dispatcher.Run" );	            }	        }	    }		    /// &lt;summary&gt;Signal dispatcher to shut down. Can be called from any thread.&lt;/summary&gt;	    public void Stop( eShutdownReason why )	    {	        Logger.Info( "Shutting down, because {0}", why );	        Post( null, why );	    }		    /// &lt;summary&gt;Post a callback to the queue. Can be called from any thread.&lt;/summary&gt;	    public void Post( SendOrPostCallback cb, object state = null )	    {	        if( !m_block.TryAdd( new kvp( cb, state ) ) )	            throw new ApplicationException( "Unable to post a callback to the dispatcher: the dispatcher queue is full" );	    }		    void IDisposable.Dispose()	    {	        Debug.Assert( Thread.CurrentThread.ManagedThreadId == createdThreadId );	        SynchronizationContext.SetSynchronizationContext( prevContext );	    }	}	</code></pre>		<p>Regardless on whether you’ll use built-in Dispatcher or my custom one, all threads must call it’s Run method, then use asynchronous posted tasks, or async methods, to run code within the dispatcher.</p>	"
55857711,55858545,55857711,2,1,Thu Apr 25 22:44:00 EDT 2019,263693,"<blockquote>	  <p>These threads need to be able to read/write to global variables in the main thread</p>	</blockquote>		<p>The easiest way to deal with this requirement is to remove it. Is it possible to code the solution so that each thread owns a device? Or is it possible to rethink the thread's responsibilities so that they communicate by message passing instead of updating shared data? Usually these alternative approaches result in much cleaner and less buggy code. But not always.</p>		<p>You will need locks to protect shared data. The easiest way to do this is with the <code>lock</code> statement, e.g.:</p>		<pre><code>object _mutex = new object();	List&lt;Object&gt; MyDevices = null;		...		var device = ...;	lock (_mutex)	{	  MyDevices.Add(device);	}	</code></pre>		<p>Generally, you want to minimize the code in the <code>lock</code> statement. Also, you may want to have one lock for the <code>List&lt;Object&gt;</code> and a separate lock for each <em>item</em> in the list, depending on how your thread use those devices.</p>	"
