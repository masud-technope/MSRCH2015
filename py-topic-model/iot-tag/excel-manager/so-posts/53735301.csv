thread_ID, Id, ParentId, PostType, Score, CreationDate, OwnerID, Body
53735301,53735301,null,1,0,Wed Dec 12 02:39:00 EST 2018,9210596,"<p>UART data transmission Raspberry pi UART (RX TX) Arduino	I know should avoid async void. They are only used for event handling. For other methods return Task. async and await	Where can there be a mistake? Why the data does not come?</p>		<p>Who knows the link where it is shown how to receive data on the UART?</p>		<pre><code>using Windows.Storage.Streams;	using Windows.Devices.Enumeration;	using Windows.Devices.SerialCommunication;		public async void Serial()	{	string aqs = SerialDevice.GetDeviceSelector("UART0");                   /* Find the selector string for the serial device   */	var dis = await DeviceInformation.FindAllAsync(aqs);                    /* Find the serial device with our selector string  */	SerialDevice SerialPort = await SerialDevice.FromIdAsync(dis[0].Id);    /* Create an serial device with our selected device */		/* Configure serial settings */	SerialPort.WriteTimeout = TimeSpan.FromMilliseconds(1000);	SerialPort.ReadTimeout = TimeSpan.FromMilliseconds(1000);	SerialPort.BaudRate = 9600;                                             /* mini UART: only standard baudrates */	SerialPort.Parity = SerialParity.None;                                  /* mini UART: no parities */  	SerialPort.StopBits = SerialStopBitCount.One;                           /* mini UART: 1 stop bit */	SerialPort.DataBits = 8;		/* Write a string out over serial */	string txBuffer = "Hello Serial";	DataWriter dataWriter = new DataWriter();	dataWriter.WriteString(txBuffer);	uint bytesWritten = await SerialPort.OutputStream.WriteAsync(dataWriter.DetachBuffer());		/* Read data in from the serial port */	const uint maxReadLength = 1024;	DataReader dataReader = new DataReader(SerialPort.InputStream);	uint bytesToRead = await dataReader.LoadAsync(maxReadLength);	string rxBuffer = dataReader.ReadString(bytesToRead);	</code></pre>		<p>}</p>	"
53735301,94330543,53735301,3,0,Wed Dec 12 08:39:00 EST 2018,9210596,"Michael Xu - MSFT  Of course, I accept data, but only once) By this code:   https://docs.microsoft.com/en-us/windows/iot-core/learn-about-hardware/pinmappings/pinmappingsrpi"
53735301,94329268,53735301,3,0,Wed Dec 12 07:53:00 EST 2018,8546089,"@SergeyKuntsevich, did you cross over RxTx wires connected with the other serial port end?"
53735301,94323994,53735301,3,1,Wed Dec 12 02:46:00 EST 2018,9210596,"Yes, https://docs.microsoft.com/en-us/windows/iot-core/learn-about-hardware/pinmappings/pinmappingsrpi"
53735301,94324021,53735301,3,0,Wed Dec 12 02:49:00 EST 2018,9210596,"A similar answer is here http://www.iot-developer.net/windows-iot/uwp-programming-in-c/uart-serial-port/rpi-using-the-uart"
53735301,94324155,53735301,3,0,Wed Dec 12 03:02:00 EST 2018,3698648,"oh.. You using `Winodws IOT Core`.. I thought trying to develop app in windows to read data from serial port which connected to `R-PI`"
53735301,94324182,53735301,3,1,Wed Dec 12 03:04:00 EST 2018,9210596,"read carefully the headlines, then minus :)"
53735301,94387415,53735301,3,0,Thu Dec 13 18:12:00 EST 2018,9210596,"Майкл Сюй - MSFT, The code is working, I wrote it from below. When checking, I did not correctly send data from the Arduino Serial3.println ("String"); Thank you."
53735301,94331969,53735301,3,0,Wed Dec 12 09:21:00 EST 2018,8546089,"@SergeyKuntsevich, if possible  please connect the device to your computer via any terminal to verify that the serial port on that device works as expected."
53735301,53751645,53735301,2,1,Wed Dec 12 21:29:00 EST 2018,9210596,"<p>Working code for communication UART (RX TX) arduino and Raspberry pi	It works through a voltage converter 5V -> 3.3V. RX TX do not forget to swap.</p>		<pre><code>    public sealed partial class MainPage : Page	{	    private SerialDevice SerialPort;	    private DataWriter dataWriter;	    private DataReader dataReader;	    string rxBuffer;     	    CancellationTokenSource ReadCancellationTokenSource = new CancellationTokenSource();		    public MainPage()	    {	        this.InitializeComponent();	        InitSerial();   	    }		    private async void InitSerial()	    {	        string aqs = SerialDevice.GetDeviceSelector("UART0");	        var dis = await DeviceInformation.FindAllAsync(aqs);	        SerialPort = await SerialDevice.FromIdAsync(dis[0].Id);	        SerialPort.WriteTimeout = TimeSpan.FromMilliseconds(1000);	        SerialPort.ReadTimeout = TimeSpan.FromMilliseconds(1000);	        SerialPort.BaudRate = 9600;	        SerialPort.Parity = SerialParity.None;	        SerialPort.StopBits = SerialStopBitCount.One;	        SerialPort.DataBits = 8;		        dataWriter = new DataWriter();	        //dataReader = new DataReader(SerialPort.InputStream);	        Listen();	    }		    public async void SerialReceived()	    {	        /* Read data in from the serial port*/	        const uint maxReadLength = 1024;	        dataReader = new DataReader(SerialPort.InputStream);	        uint bytesToRead = await dataReader.LoadAsync(maxReadLength);	        rxBuffer = dataReader.ReadString(bytesToRead);	        receivedData.Text = rxBuffer;	    }		    public async void SerialSend(string txBuffer2)	    {	        /* Write a string out over serial */	        string txBuffer = txBuffer2;	        dataWriter.WriteString(txBuffer);	        uint bytesWritten = await SerialPort.OutputStream.WriteAsync(dataWriter.DetachBuffer());	    }		    private void Button_Click(object sender, RoutedEventArgs e)	    {	        SerialSend("Hello Serial");	    }		    private async void Listen()	    {	        try	        {	            if (SerialPort != null)	            {	                dataReader = new DataReader(SerialPort.InputStream);		                // keep reading the serial input	                while (true)	                {	                    await ReadAsync(ReadCancellationTokenSource.Token);	                }	            }	        }	        catch (Exception ex)	        {	            throw new Exception("Uart Error", ex);	        }	    }		    private async Task ReadAsync(CancellationToken cancellationToken)	    {	        Task&lt;UInt32&gt; loadAsyncTask;	        uint ReadBufferLength = 1024;	        // If task cancellation was requested, comply	        cancellationToken.ThrowIfCancellationRequested();	        // Set InputStreamOptions to complete the asynchronous read operation when one or more bytes is available	        dataReader.InputStreamOptions = InputStreamOptions.Partial;	        // Create a task object to wait for data on the serialPort.InputStream	        loadAsyncTask = dataReader.LoadAsync(ReadBufferLength).AsTask(cancellationToken);	        // Launch the task and wait	        UInt32 bytesRead = await loadAsyncTask;	        if (bytesRead &gt; 0)	        {	            receivedData.Text = dataReader.ReadString(bytesRead);	        }	    }	}	</code></pre>	"
