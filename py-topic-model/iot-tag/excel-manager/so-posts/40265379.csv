thread_ID, Id, ParentId, PostType, Score, CreationDate, OwnerID, Body
40265379,40265379,null,1,1,Wed Oct 26 14:46:00 EDT 2016,6556913,"<p>I am playing around with freeboard.io and trying to make a widget that pulls JSON data from a URL [TBD].  My original data source is from an iMX6-based Wandboard running Linux that is connected to the internet.  I want to write a C++ program on the Wandboard that opens a socket to [TBD] and sends UDP packets, for example, containing my sensor data.  My JSON data structure is like this:</p>		<pre><code>{	  "sensor_a": 1100,	  "sensor_b": 247,	  "sensor_c": 0	}	</code></pre>		<p>Can you help me put my JSON data structure into an IP packet using C++ on Ubuntu Linux?  I know how to just serialize the data structure in ascii for example and build a buffer to stuff an IP packet but I'm wondering if there is a standard way to do this for cloud services, or will it be different for Azure vs AWS?  Is some type of header info needed to "put" the data?</p>	"
40265379,67791403,40265379,3,0,Wed Oct 26 14:52:00 EDT 2016,4533695,"You might want to consider Casablanca: https://github.com/Microsoft/cpprestsdk - Yes it does support Ubuntu, iOS, OSX and Android"
40265379,67791613,40265379,3,0,Wed Oct 26 14:56:00 EDT 2016,3807729,"It sounds like this question is really how to send a string to a server. The answer is going to depend on what the server is expecting."
40265379,67792800,40265379,3,0,Wed Oct 26 15:23:00 EDT 2016,6556913,"So there's not a standard format for publishing JSON data?  I have a google cloud services account.  I'll choose to put data there for now.  Is the product or feature I'm looking for considered "Cloud storage", as offered by most cloud service companies?"
40265379,67793879,40265379,3,0,Wed Oct 26 15:50:00 EDT 2016,6556913,"Wow!  Google Cloud Platform has a lot of ways to store stuff.  https://cloud.google.com/storage-options/"
40265379,51887950,40265379,2,0,Fri Aug 17 03:20:00 EDT 2018,4739800,"<p>This is a very simple problem, like all simple problems no need for external libraries for serializing etc. Like @Galik  said above your problem is how to send a string from client to server. Additionally for your case you need a JSON parser on the server (any C or C++ parser from the JSON page will do, I use gason because it's fast and simple). </p>		<p>In TCP/IP socket programming you have to make the other part know how many bytes (characters in your case) to read.</p>		<p>I faced a similar case: send JSON over the web.	here's the example, a JSON "message"</p>		<p><a href="https://github.com/pedro-vicente/lib_netsockets/blob/master/examples/json_message.cc" rel="nofollow noreferrer">https://github.com/pedro-vicente/lib_netsockets/blob/master/examples/json_message.cc</a></p>		<p>in this case, the size of the message has this header format</p>		<pre><code>nbr_bytes#json_string	</code></pre>		<p>where "json_string" is the JSON text, "nbr_bytes" is the number of characters "json_string" has and "#" is a separator character.</p>		<p>how does the server parse this?	By reading 1 character at a time until the "#" separator is found, then converting that string into a number;	then make the socket API read "nbr_bytes" characters and exit</p>		<p>example</p>		<pre><code>100#{json_txt....}	</code></pre>		<p>in this case "json_txt" has 100 characters</p>		<p>here's the code for the parser</p>		<pre><code>std::string read_response(socket_t &amp;socket)	{	  int recv_size; // size in bytes received or -1 on error 	  size_t size_json = 0; //in bytes	  std::string str_header;	  std::string str;		  //parse header, one character at a time and look for for separator #	  //assume size header lenght less than 20 digits	  for (size_t idx = 0; idx &lt; 20; idx++)	  {	    char c;	    if ((recv_size = recv(socket.m_socket_fd, &amp;c, 1, 0)) == -1)	    {	      std::cout &lt;&lt; "recv error: " &lt;&lt; strerror(errno) &lt;&lt; std::endl;	      return str;	    }	    if (c == '#')	    {	      break;	    }	    else	    {	      str_header += c;	    }	  }		  //get size	  size_json = static_cast&lt;size_t&gt;(atoi(str_header.c_str()));		  //read from socket with known size	  char *buf = new char[size_json];	  if (socket.read_all(buf, size_json) &lt; 0)	  {	    std::cout &lt;&lt; "recv error: " &lt;&lt; strerror(errno) &lt;&lt; std::endl;	    return str;	  }	  std::string str_json(buf, size_json);	  delete[] buf;	  return str_json;	}	</code></pre>	"
