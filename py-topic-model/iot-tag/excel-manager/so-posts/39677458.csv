thread_ID, Id, ParentId, PostType, Score, CreationDate, OwnerID, Body
39677458,39677458,null,1,2,Sat Sep 24 14:29:00 EDT 2016,4089404,"<p>I have the following code running on a raspberry pi 3 running windows 10 using C#</p>		<p>GPIO init ....</p>		<pre><code>_gpioController = GpioController.GetDefault();	                _motorPin = _gpioController.OpenPin(Convert.ToInt32(RaspberryGPIOpin);	                _motorPin.SetDriveMode(GpioPinDriveMode.Output);   	</code></pre>		<p>GPIO pin on off    </p>		<pre><code>_motorPin.Write(GpioPinValue.High);	_motorPin.Write(GpioPinValue.Low);	</code></pre>		<p>The problem is that in my application to turn on and off the GPI pin takes 100 milliseconds, but I need this it happen in less that 25 milliseconds to change the direction of a servo. </p>		<p>Is there a way to speed up the on off of the GPIO pins?</p>		<p>or should I be looking at a hardware controller of some sort to control the servo. I would prefer to do this. My code is also running in a thread as well. should I remove the threading???</p>		<p>I have a much simpler application where the code does work...	<a href="https://github.com/StuartSmith/RaspberryPi-Control-Sg90-Example" rel="nofollow">https://github.com/StuartSmith/RaspberryPi-Control-Sg90-Example</a> </p>	"
39677458,66682936,39677458,3,0,Sun Sep 25 21:06:00 EDT 2016,4089404,"Thank you, your response led me to the lightning provider for GPIO pins. I will check this out to see if I can get the performance I need."
39677458,66673699,39677458,3,2,Sun Sep 25 13:07:00 EDT 2016,5730046,"I'm afraid this can not be easily done with UWP, especially when windows iot core is not an read-time operating system. However, if you want to have precise control over the gpio toggling, you might want to use the build-in DMA controller."
39677458,66689032,39677458,3,0,Mon Sep 26 05:19:00 EDT 2016,5730046,"Yes, the lighting provider claims to have better performance over the default inbox driver, msdn provides a detailed tests result on toggling GPIO bit, https://developer.microsoft.com/en-us/windows/iot/docs/lightningperformance."
39677458,39695312,39677458,2,3,Mon Sep 26 05:33:00 EDT 2016,5730046,"<p>Microsoft provides a complete test result on toggling GPIO bit using raspberry pi 2, find it in <a href="https://developer.microsoft.com/en-us/windows/iot/docs/lightningperformance" rel="nofollow">https://developer.microsoft.com/en-us/windows/iot/docs/lightningperformance</a>.</p>		<p>So you can see the result varies with IoT version,  driver model, .NET native toolchain, and even programming languages. But in the worst case, approximately 10kHz can be achieved.</p>		<p>I haven't tested on the latest IoT Redstone 1 release, but I'm guessing it should have similar performance with TH2.</p>		<p>So, in general, <strong>choose the lightning driver over the default inbox driver</strong>, it's supposed to have better performance on GPIO ports.</p>		<p>Also <strong>disabling the .NET native toolchain</strong> will have noticeably better performance as well.</p>		<p>I'm seeing you're using the GPIO pin to drive the servo, the software timing should be good enough in this case. However if you want to use it for clock source that needs high precision, don't trust on the software timing(lighting provider), <strong>the software jitter is always unpredictable</strong>. One good alternative is to use the build-in <strong>DMA controller</strong>, which uses hardware timing and should have precision within 1 micro-second.</p>	"
39677458,39801636,39677458,2,-2,Sat Oct 01 00:01:00 EDT 2016,6353376,"<p>How did you measure 100ms? Is 100ms how long it took to run the two Write() calls, or was there other code in there? </p>		<p>We measured each Write() call at 3.6 microseconds (from a C++ app).</p>		<p>The first Write() call after you open a pin and set drive mode may take longer than subsequent calls due to the way the underlying stack works. Did your measurement include the first Write() call?</p>	"
39677458,66915962,39801636,3,0,Sat Oct 01 23:17:00 EDT 2016,4089404,"The measurement was from the visual studio IDE. The measurements were in a for loop and the timing was about the same in all cases."
39677458,66895622,39801636,3,0,Sat Oct 01 00:11:00 EDT 2016,4585476,"This is not an answer to the Question. If you have a question, I would recommend you to post a new one with your case and Scenario."
