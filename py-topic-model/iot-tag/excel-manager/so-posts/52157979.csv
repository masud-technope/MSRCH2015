thread_ID, Id, ParentId, PostType, Score, CreationDate, OwnerID, Body
52157979,52157979,null,1,1,Tue Sep 04 02:22:00 EDT 2018,741099,"<p>My goal is to create a system on AWS using the <a href="http://serverless.com/" rel="nofollow noreferrer">serverless framework</a> for multiple IoT devices to send JSON payloads to AWS IoT, which in turn will be saved to DynamoDB.</p>		<p>I am very new to using AWS outside of creating EC2 servers and this is my first project using the <a href="http://serverless.com/" rel="nofollow noreferrer">serverless framework</a>. </p>		<p>After referring to <a href="https://serverless.zone/iot-with-the-serverless-framework-e228fae87be" rel="nofollow noreferrer">an example</a>, the modified version that I came up with is posted below.</p>		<p><strong>Problem:</strong> It appears that the example is for just 1 device to connect to AWS IoT, which I concluded from the hardcoded IoT Thing certificate being used, such as</p>		<pre><code>SensorPolicyPrincipalAttachmentCert:	  Type: AWS::IoT::PolicyPrincipalAttachment	  Properties:	    PolicyName: { Ref: SensorThingPolicy }	    Principal: ${{custom.iotCertificateArn}}		SensorThingPrincipalAttachmentCert:	  Type: "AWS::IoT::ThingPrincipalAttachment"	  Properties:	    ThingName: { Ref: SensorThing }	    Principal: ${self:custom.iotCertificateArn}	</code></pre>		<p>If this conclusion is correct that <code>serverless.yml</code> is configured for only 1 Thing, then what modifications can we make such that more than 1 Thing can be used?</p>		<p>Maybe setup all the Things outside of <code>serverless.yaml</code>? Which means removing just <code>SensorPolicyPrincipalAttachmentCert</code> and <code>SensorThingPrincipalAttachmentCert</code>?</p>		<p>Also, how should we set the <code>Resource</code> property to in <code>SensorThingPolicy</code>? They are currently set to <code>"*"</code>, is this too broard? Or is there a way to limit to just Things.</p>		<p><strong>serverless.yml</strong></p>		<pre><code>service: garden-iot		provider:	name: aws	runtime: nodejs6.10	region: us-east-1		# load custom variables from a file	custom: ${file(./vars-dev.yml)}		resources:	Resources:	    LocationData:	    Type: AWS::DynamoDB::Table	    Properties:	        TableName: location-data-${opt:stage}	        AttributeDefinitions:	        - 	            AttributeName: ClientId	            AttributeType: S	        - 	            AttributeName: Timestamp	            AttributeType: S	        KeySchema:	        - 	            AttributeName: ClientId	            KeyType: HASH	        - 	            AttributeName: Timestamp	            KeyType: RANGE	        ProvisionedThroughput:	        ReadCapacityUnits: 1	        WriteCapacityUnits: 1		    SensorThing:	    Type: AWS::IoT::Thing	    Properties:	        AttributePayload:	        Attributes:	            SensorType: soil		    SensorThingPolicy:	    Type: AWS::IoT::Policy	    Properties:	        PolicyDocument:	        Version: "2012-10-17"	        Statement:	            - Effect: Allow	            Action: ["iot:Connect"]	            Resource: ["${self:custom.sensorThingClientResource}"]	            - Effect: "Allow"	            Action: ["iot:Publish"]	            Resource: ["${self:custom.sensorThingSoilTopicResource}"]		    SensorPolicyPrincipalAttachmentCert:	    Type: AWS::IoT::PolicyPrincipalAttachment	    Properties:	        PolicyName: { Ref: SensorThingPolicy }	        Principal: ${{custom.iotCertificateArn}}		    SensorThingPrincipalAttachmentCert:	    Type: "AWS::IoT::ThingPrincipalAttachment"	    Properties:	        ThingName: { Ref: SensorThing }	        Principal: ${self:custom.iotCertificateArn}		IoTRole:	Type: AWS::IAM::Role	Properties:	    AssumeRolePolicyDocument:	    Version: "2012-10-17"	    Statement:	        -	        Effect: Allow	        Principal:	            Service:	            - iot.amazonaws.com	        Action:	            - sts:AssumeRole		IoTRolePolicies:	Type: AWS::IAM::Policy	Properties:	    PolicyName: IoTRole_Policy	    PolicyDocument:	    Version: "2012-10-17"	    Statement:	        -	        Effect: Allow	        Action:	            - dynamodb:PutItem	        Resource: "*"	        -	        Effect: Allow	        Action:	            - lambda:InvokeFunction	        Resource: "*"	    Roles: [{ Ref: IoTRole }]	</code></pre>	"
52157979,52167210,52157979,2,1,Tue Sep 04 13:14:00 EDT 2018,799155,"<p><strong>EDIT 05/09/2018:</strong> I've found this blog post, which describes my approach pretty well: <a href="https://aws.amazon.com/de/blogs/iot/ensure-secure-communication-with-aws-iot-core-using-the-certificate-vending-machine-reference-application/" rel="nofollow noreferrer">Ensure Secure Communication with AWS IoT Core Using the Certificate Vending Machine Reference Application</a></p>		<p><strong>--</strong></p>		<p>You could take a look at <a href="https://docs.aws.amazon.com/iot/latest/developerguide/jit-provisioning.html" rel="nofollow noreferrer">Just-in-Time Provisioning</a> or build your own solution based on <a href="https://docs.aws.amazon.com/iot/latest/developerguide/programmatic-provisioning.html" rel="nofollow noreferrer">Programmatic Provisioning</a>.</p>		<p>I have dealt with this topic many times and had to realize that it depends a lot on the use case, which makes more sense. Also security is an aspect to keep an eye on. You don't want to have a public API responsible for JIT device registration accessible by the whole Internet. </p>		<p>A simple Programmatic Provisioning-based scenario could look like this: You build a thing (maybe a sensor), which should be abled to connect to AWS IoT and have an in-house provisioning process.</p>		<p>Simple provisioning process:</p>		<ol>	<li>Thing built</li>	<li>Thing has a serial number</li>	<li>Thing registers itself via an internal server</li>	</ol>		<p>The registration code running on the server could look something like this (JS + AWS JS SDK):</p>		<pre><code>// Modules	const AWS = require('aws-sdk')		// AWS	const iot = new AWS.Iot({ region: process.env.region })		// Config	const templateBodyJson = require('./register-thing-template-body.json')		// registerThing	const registerThing = async ({ serialNumber = null } = {}) =&gt; {	  if (!serialNumber) throw new Error('`serialNumber` required!')		  const {	    certificateArn = null,	    certificateId = null,	    certificatePem = null,	    keyPair: {	      PrivateKey: privateKey = null,	      PublicKey: publicKey = null	    } = {}	  } = await iot.createKeysAndCertificate({ setAsActive: true }).promise()	  const registerThingParams = {	    templateBody: JSON.stringify(templateBodyJson),	    parameters: {	      ThingName: serialNumber,	      SerialNumber: serialNumber,	      CertificateId: certificateId	    }	  }	  const { resourceArns = null } = await iot.registerThing(registerThingParams).promise()		  return {	    certificateArn,	    certificateId,	    certificatePem,	    privateKey,	    publicKey,	    resourceArns	  }	}		const unregisterThing = async ({ serialNumber = null } = {}) =&gt; {	  if (!serialNumber) throw new Error('`serialNumber` required!')		  try {	    const thingName = serialNumber	    const { principals: thingPrincipals } = await iot.listThingPrincipals({ thingName }).promise()	    const certificates = thingPrincipals.map((tp) =&gt; ({ certificateId: tp.split('/').pop(), certificateArn: tp }))		    for (const { certificateId, certificateArn } of certificates) {	      await iot.detachThingPrincipal({ thingName, principal: certificateArn }).promise()	      await iot.updateCertificate({ certificateId, newStatus: 'INACTIVE' }).promise()	      await iot.deleteCertificate({ certificateId, forceDelete: true }).promise()	    }		    await iot.deleteThing({ thingName }).promise()		    return {	      deleted: true,	      thingPrincipals	    }	  } catch (err) {	    // Already deleted!	    if (err.code &amp;&amp; err.code === 'ResourceNotFoundException') {	      return {	        deleted: true,	        thingPrincipals: []	      }	    }		    throw err	  }	}	</code></pre>		<p><strong>register-thing-template-body.json:</strong></p>		<pre><code>{	  "Parameters": {	     "ThingName": {	       "Type": "String"	     },	     "SerialNumber": {	       "Type": "String"	     },	     "CertificateId": {	       "Type": "String"	     }	  },	  "Resources": {	    "thing": {	      "Type": "AWS::IoT::Thing",	      "Properties": {	        "ThingName": {	          "Ref": "ThingName"	        },	        "AttributePayload": {	          "serialNumber": {	            "Ref": "SerialNumber"	          }	        },	        "ThingTypeName": "NewDevice",	        "ThingGroups": ["NewDevices"]	      }	    },	    "certificate": {	      "Type": "AWS::IoT::Certificate",	      "Properties": {	        "CertificateId": {	          "Ref": "CertificateId"	        }	      }	    },	    "policy": {	      "Type": "AWS::IoT::Policy",	      "Properties": {	        "PolicyName": "DefaultNewDevicePolicy"	      }	    }	  }	}	</code></pre>		<p>Make sure you got all the "NewDevice" Thing types, groups and policies in place. Also keep in mind ThingName = SerialNumber (important for unregisterThing).</p>	"
