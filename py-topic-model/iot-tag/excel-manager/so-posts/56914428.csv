thread_ID, Id, ParentId, PostType, Score, CreationDate, OwnerID, Body
56914428,56914428,null,1,0,Sat Jul 06 13:14:00 EDT 2019,11747663,"<p>I am having problem in receiving string from HC05 to ATmega16. I am able receive characters but not able to receive strings.  </p>		<p>I want to control DC motor wirelessly using ATmega16 and Bluetooth module (HC05). I am sending the timer OCR1A values from serial monitor app to ATmega16 by HC05 but not succeeded.  </p>		<pre><code>#define F_CPU 16000000UL 	#include&lt;string.h&gt;	#include &lt;avr/io.h&gt;	#include &lt;util/delay.h&gt;	#include &lt;stdlib.h&gt;	#include &lt;stdio.h&gt;		void UART_init()	{	    UCSRB |= (1 &lt;&lt; RXEN) | (1 &lt;&lt; TXEN);	    UCSRC |= (1 &lt;&lt; URSEL) | (1 &lt;&lt; UCSZ0) | (1 &lt;&lt; UCS Z1);	    UBRRL = 0x67;	}		unsigned char UART_RxChar()	{	    while( (UCSRA &amp; (1 &lt;&lt; RXC)) == 0 );	    return(UDR);	}		void UART_TxChar( char ch )	{	    while( !(UCSRA &amp; (1 &lt;&lt; UDRE)) );  /* Wait for empty transmit buffer*/	    UDR = ch ;	}		void UART_SendString( char* str )	{	    unsigned char j = 0;		    while( j &lt;= 2 )	    {	        UART_TxChar( str[j] );	        j++;	    }	}		int main( void )	{	    char buff[3];	    char j;	    int i = 0, k = 0;	    DDRD = (1 &lt;&lt; PD5);		    UART_init();		    while( 1 )	    {	        buff[0] = UART_RxChar();	        buff[1] = UART_RxChar();	        buff[2] = UART_RxChar();		        j = UART_RxChar();		        if( j == '!' )	        {	            UART_SendString( buff );   // this is to check whether the atmega16 received correct values for timer or not.	            UART_SendString( "\n" );	        }	    }	}	</code></pre>		<p>The expected result is when I enter the number in serial monitor app, I should get back the same number on serial monitor app.</p>		<p>In the actual result I am getting different characters sometimes and empty some times.</p>	"
56914428,100377966,56914428,3,0,Sat Jul 06 21:04:00 EDT 2019,5329483,"At which frequency your Atmega16 is running? What is the fuses setting?"
56914428,100382229,56914428,3,0,Sun Jul 07 06:28:00 EDT 2019,5329483,"Still think there is something wrong with the baud rate."
56914428,100383423,56914428,3,0,Sun Jul 07 08:18:00 EDT 2019,168986,"@user5329483 :  What makes you think that?  It appears to be set for _nominally_ 9600 baud -  BAUD = Fosc /  16(UBRR+1), which for 0x67 (103) results in 9524, which is well withing the 5% tolerance required for robust UART frame synchronisation."
56914428,100384001,56914428,3,0,Sun Jul 07 09:06:00 EDT 2019,11747663,"baud rate is 9600 and i have substituted it in formula and found out its equivalent hex value as 0x67."
56914428,100384075,56914428,3,0,Sun Jul 07 09:11:00 EDT 2019,168986,"Apart from the lack of nul termination, you code requires input of the form `nnn!nnn!nnn!...`.  If the other end is in fact sending _lines_ with CR or CR+LF terminators, `nnn!<newline>nnn!<newline>nnn!<newline>...your receive loop will get out of sync."
56914428,100381254,56914428,3,0,Sun Jul 07 04:15:00 EDT 2019,11747663,"Frequency is 16mhz fuses are 99FF."
56914428,100971271,56914428,3,0,Sat Jul 27 17:20:00 EDT 2019,11747663,"what if i want to store 100 char size string without using ring buffer. can it be done by pointers?"
56914428,56920358,56914428,2,0,Sun Jul 07 08:04:00 EDT 2019,168986,"<p>The string <code>buff</code> is unterminated, so <code>UART_SendString( buff );</code> will send whatever junk follows the received three characters until a NUL (0) byte is found.</p>		<pre><code>char buff[4] = {0};	</code></pre>		<p>Will have room for the NUL and the initialisation will ensure that <code>buff[3]</code> is a NUL terminator.</p>		<p>Alternatively, send the three characters individually since without the terminator they do not constitute a valid C (ASCIIZ) string.</p>		<p>Apart from the lack of nul termination, you code requires input of <em>exactly</em>  the form <code>nnn!nnn!nnn!...</code>.  If the other end is in fact sending <em>lines</em> with CR or CR+LF terminators -  <code>nnn!&lt;newline&gt;nnn!&lt;newline&gt;nnn!&lt;newline&gt;...</code> your receive loop will get out of sync.</p>		<p>A safer solution is to use the previously received <em>three</em> characters whenever a <code>'!'</code> character is received.  This can be done in a number of ways - for long buffers a ring-buffer would be advised, but for just three characters it is probably efficient enough to simply shift characters left when inserting a new character - for example:</p>		<pre><code>char buff[4] ;	for(;;)	{	    memset( buff, '0', sizeof(buff) - 1 ) ;		    char ch = 0 ;	    while( (ch != '!' )	    {   	        ch = UART_RxChar() ;	        if( isdigit(ch) )	        {	            // Shift left one digit	            memmove( buff, &amp;buff[1], sizeof(buff) - 2 ) ; 		            // Insert new digit at the right	            buff[sizeof(buff) - 2] = ch ;	        }	        else if( ch != '!' )	        {	            // Unexpected character, reset buffer	            memset( buff, '0', sizeof(buff) - 1 ) ;	        }	    }		    UART_SendString( buff ) ;	    UART_SendString( "\n" ) ;	}	</code></pre>		<p>This also has the advantage that it will work when the number entered is less than three digits, and will discard any sequence containing non-digit characters.</p>	"
56914428,100384795,56920358,3,0,Sun Jul 07 10:08:00 EDT 2019,168986,"@NallurisasiKiran : Which part 'is true'? I have included some guessing. The code I posted is intended to be illustrative: I have no means if running or testing it, so I am not gauranteeing that it is correct. You are using a debugger right? If not, you really should."
56914428,100384831,56920358,3,0,Sun Jul 07 10:11:00 EDT 2019,168986,"@NallurisasiKiran I have the arguments to memmove reversed. Will fix."
56914428,100384833,56920358,3,0,Sun Jul 07 10:11:00 EDT 2019,11747663,"this is true but the output what i got when i entered 457! is 007, 567! is 007, 333! is 003! and so on. i think there must be a decrement counter till 0 in memmove and buff[sizeof(buff)-2] = ch instead of '2'."
56914428,100384912,56920358,3,0,Sun Jul 07 10:16:00 EDT 2019,168986,"... also I apparently don't know my left from my right! :-)"
56914428,100384918,56920358,3,0,Sun Jul 07 10:16:00 EDT 2019,11747663,"i am talking about the part of code which you had answered is true."
56914428,100971226,56920358,3,0,Sat Jul 27 17:17:00 EDT 2019,11747663,"what if i want to store 100 char size string without using ring buffer. can it be done by pointers?"
56914428,100971574,56920358,3,0,Sat Jul 27 17:40:00 EDT 2019,168986,"@NallurisasiKiran "pointers" are not the magic here, pointers are a fundamental concept, not a solution.  A ring buffer is as likely to use pointers as any other solution.  This method is distinct from a ring buffer as it moves the data in memory rather than moving references to the data.  It is the use of memmove() that is peculiar to this solution.  It is functionally scalable to any size buffer, but decreases performance linearly.  By the time it takes longer to move the data than it takes to receive a character, it will fail. For large buffers it is a poor solution."
56914428,100972120,56920358,3,0,Sat Jul 27 18:17:00 EDT 2019,11747663,"how to increase the size of the buffer in the above code and i didnt clearly understand left shift and right shift part in the code. can you explain it with some illustrations."
56914428,100972311,56920358,3,0,Sat Jul 27 18:29:00 EDT 2019,168986,"@NallurisasiKiran : All the data in the buffer is moved "left", loosing the oldest character, and adding the new character to the end.  Because I have used `sizeof(buff)` throughout, the solution can be extended simply by changing the size of `buff`.  But be aware, this solution is specifically tailored to receiving a fixed number of characters before the `!`, it is not a general purpose serial buffering solution and not suited to variable length commands.  If that is required you need a redesign and probably to post a new question."
56914428,100972338,56920358,3,0,Sat Jul 27 18:31:00 EDT 2019,168986,"@NallurisasiKiran : SO is not a discussion forum, it is a Q&A, we are deviating from the original question.  If you have new or different requirements from the original question, post a new question."
56914428,100384975,56920358,3,0,Sun Jul 07 10:20:00 EDT 2019,168986,"@NallurisasiKiran I meant was it the nul termination, the synchronisation, or both that are "true". I was trying to see where the error in the answer lies, that's all. Never mind though - the memmove was shifting the wrong way I think. Try the correction."
56914428,100385015,56920358,3,0,Sun Jul 07 10:22:00 EDT 2019,11747663,"thank you for showing a new approach by the way  code  worked :-)"
