thread_ID, Id, ParentId, PostType, Score, CreationDate, OwnerID, Body
35986549,35986549,null,1,7,Mon Mar 14 11:40:00 EDT 2016,804440,"<p>I connect to a BLE device with the <code>connectGatt()</code> method in Android. This works great.</p>		<p>When I disconnect I use the following:</p>		<pre><code>private void disconnectDevice() {	    gatt.disconnect();	}	</code></pre>		<p>When I receive the callback I do a close.</p>		<pre><code>private BluetoothGattCallback gattCallback = new BluetoothGattCallback() {	    @Override	    public void onConnectionStateChange(BluetoothGatt gatt, int status, int newState) {	        switch (newState) {	            case BluetoothProfile.STATE_CONNECTED:	                Log.d("BLED-GATT", "STATE_CONNECTED");	                setUIConnectionStatus("Discover services on device...", Color.YELLOW);	                checkEnableAddButton(simpleTrackEditText.getText().toString());	                gatt.discoverServices();	                break;	            case BluetoothProfile.STATE_DISCONNECTED:	                Log.d("BLED-GATT", "STATE_DISCONNECTED");	                setUIConnectionStatus("Not Connected!", Color.RED);	                gatt.close();	                break;	            default:	                Log.d("BLED-GATT", "STATE_OTHER");	        }	    }	}	</code></pre>		<p>This is executed and I can no longer control the device after calling <code>disconnectDevice()</code>. The device itself seems to think that it is still connected since I cant put it in broadcasting visibility mode (which happens if it already has a connection). However, if I kill the application and open it again then I can set the device in broadcasting mode. This tells me the app was not properly disconnected.</p>		<p>Any idea what I missed here? </p>	"
35986549,59640973,35986549,3,1,Mon Mar 14 17:32:00 EDT 2016,5935255,"do you stop scanning for devices after you connect to the ble device? I had a similar issue which the phone stayed connected to the ble chip even after calling disconnect. The issue was that I never called mScanner.stopScan(mScanCallback) after successful connection."
35986549,59655640,35986549,3,0,Tue Mar 15 02:21:00 EDT 2016,804440,"Thank you but yes I call stopScan upon successful connection."
35986549,35986684,35986549,2,2,Mon Mar 14 11:46:00 EDT 2016,3343174,"<p>That's totally logic because you are not disconnecting before closing Gatt.</p>		<pre><code>public void disconnect() {	        if (mBluetoothAdapter == null || mBluetoothGatt == null) {	            Log.w(TAG, "BluetoothAdapter not initialized");	            return;	        }	        mBluetoothGatt.disconnect();	    }	</code></pre>		<p>try to call this method before closing your <code>GATT</code></p>	"
35986549,59635622,35986684,3,6,Mon Mar 14 15:27:00 EDT 2016,804440,"I am disconnecting before closing, the callback gets called on disconnect. Which means I already disconnected it when calling `close()`? Your answer is only adding a null check to my code?"
35986549,59636539,35986684,3,0,Mon Mar 14 15:46:00 EDT 2016,3343174,"no no in fact you must call the disconnect method otherwise it just close the Gatt without disconnecting !! just try it"
35986549,36005877,35986549,2,9,Tue Mar 15 08:24:00 EDT 2016,804440,"<p>The problem was that I during scanning was connecting to the same device multiple times causing my application to have many connections open at the same time. Adding <code>!isConnected()</code> solved the problem:</p>		<pre><code>/**	 * Connects to the device. Does nothing if already connected.	 * @param macAddress the address of the device.	 */	private void connectDevice(String macAddress) {	    if (!isConnected()) {	        device = bluetoothAdapter.getRemoteDevice(macAddress);		        if (device == null) {	            this.sendToast("Device Not Available");	        } else {	            Log.d("BLED", "Connecting...");	            gatt = device.connectGatt(this, true, gattCallback);	        }	    }	}	</code></pre>	"
35986549,97510292,36005877,3,0,Thu Mar 28 10:12:00 EDT 2019,1099820,"That is not proper behavior by the peer according to the spec. When a peer receives a connection event, it shall stop advertising. Since many BTLE devices behave badly (as does the Android API) as a work-a-round I ignore any received advertisement from an already connected device. I do turn of scanning during connection but once connected I turn it back on. Otherwise you cannot support multiple simultaneous connections."
35986549,63496919,36005877,3,0,Sat Jun 25 12:14:00 EDT 2016,2506817,"Does `isConnected()` return some kind of a private variable that you track? Can you elaborate more...? Thx!"
35986549,63510747,36005877,3,0,Sun Jun 26 05:05:00 EDT 2016,804440,"Don't remember but I think that was just a utility method I made. Checking if `gatt` was null, if so then I was sure there was no connection already. I should also have set `gatt` to null in `onConnectionStateChange` I think"
35986549,54778020,35986549,2,1,Wed Feb 20 02:37:00 EST 2019,3725501,"<p>I experienced same problem and I found two possible root cause as follows:	1. Was same as @nilsi answer, connect to the same device more than once in one scanning. 	→ solved by lock &amp; List	2. connect to the device in one scanning and didn't get onConnectionStateChange, than I scanned again, it resulted in second connection to the same device.	→ solved by keeping BluetoothGatt object when I call device.connectGatt(), and call object.disconnect(), object.close() before scanning.</p>		<p>My test phone is 4 years old so sometimes it needs more than 20 seconds to return onConnectionStateChange....</p>	"
