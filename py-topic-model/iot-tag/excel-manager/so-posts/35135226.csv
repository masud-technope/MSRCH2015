thread_ID, Id, ParentId, PostType, Score, CreationDate, OwnerID, Body
35135226,35135226,null,1,2,Mon Feb 01 16:17:00 EST 2016,4361588,"<p>I did the following tutorial to connect my Raspberry Pi with an application on Bluemix using the IoT Foundation:</p>		<p><a href="https://developer.ibm.com/bluemix/2015/04/02/tutorial-using-a-raspberry-pi-python-iot-twilio-bluemix/" rel="nofollow">https://developer.ibm.com/bluemix/2015/04/02/tutorial-using-a-raspberry-pi-python-iot-twilio-bluemix/</a></p>		<p>I have the following problem:</p>		<p>If I press the button on my Pi it only prints out "Button pushed" in the Pi terminal.</p>		<p>I don't get any SMS send on my phone and there is now entry in the Log from Twilio.</p>	"
35135226,35135354,35135226,2,3,Mon Feb 01 16:23:00 EST 2016,3817025,"<p>Turns out the IBM IoT Foundation library changed in the way it parses JSON...  Also, I had the code hardcoded to expect USA phone numbers.  I added a check for USA phone numbers as well.</p>		<p>Change <a href="https://github.com/IBM-Bluemix/python-iot-raspberry-pi/blob/master/server.py#L25" rel="nofollow">line 25</a></p>		<pre><code>buttonPushed = cmd.payload["d"]["buttonPushed"]	</code></pre>		<p>to </p>		<pre><code>payload = json.loads(cmd.payload)	buttonPushed = payload["buttonPushed"]	</code></pre>	"
35135226,35201126,35135226,2,1,Thu Feb 04 12:32:00 EST 2016,3818286,"<p>Don't use cmd.payload ... use cmd.data</p>		<p>This example is old, was built using an older version of the library and it unfortunately doesn't reference which release of the python library it was using, as the easy "fix" is to install the version of the library that the application was developed for.</p>		<p>The python library is still in pre-release state, I would recommend when building applications you set your requirements to a specific version of the library as backwards compatibility is not guaranteed at this stage and any new release may break your application due to changes in behaviour, although I try to avoid these whenever possible.</p>		<p>The command and event objects the library passes to callbacks have the following properties:</p>		<ul>	<li><strong>cmd/evt.deviceType</strong>		<ul>	<li>the typeId of the device</li>	</ul></li>	<li><strong>cmd/evt.deviceId</strong>		<ul>	<li>the deviceId of the device</li>	</ul></li>	<li><strong>cmd/evt.device</strong>		<ul>	<li>the typeId:deviceId unique identifier for the device within your organization</li>	</ul></li>	<li><strong>cmd.command/evt.event</strong>		<ul>	<li>the ID/name of the command/event</li>	</ul></li>	<li><strong>cmd/evt.format</strong>		<ul>	<li>the format of the command/event message</li>	</ul></li>	<li><strong>cmd/evt.payload</strong>		<ul>	<li>the raw payload of the command (this seems to only be available for events at the moment .. oops, will correct in 0.1.8)</li>	</ul></li>	<li><strong>cmd/evt.data</strong>		<ul>	<li>the parsed data from the command payload (as a python dictionary), library supports parsing of any message format as long as an appropriate codec has been registered for the format</li>	</ul></li>	</ul>		<p>If you send a command with format "json" with the following content: {"d": {"buttonPushed": true}} then cmd.data will look like this:</p>		<p>cmd.data == {	  "d": {	    "buttonPushed": true	  }	}</p>		<p>The plain <a href="https://github.com/ibm-messaging/iot-python/blob/master/src/ibmiotf/codecs/jsonCodec.py" rel="nofollow">json parser</a> makes no assumptions about the shape of your json and works as long as your payload is valid json.</p>		<p>If you sent the same content with format "json-iotf" then the <a href="https://github.com/ibm-messaging/iot-python/blob/master/src/ibmiotf/codecs/jsonIotfCodec.py" rel="nofollow">json-iotf</a> parser would kick in, which only works if you use the json shape required for the built-in historian service.  In this case it will take the data directly from the d element and pick up the timestamp from the ts element, so you would have:</p>		<p>cmd.data == {	  "buttonPushed": true	}</p>		<p>In both cases, in the latest version of the library cmd.payload will be the raw byte array form the underlying MQTT message</p>		<p>If you need your application/device to understand payloads that aren't json it's a simple case of <a href="https://github.com/ibm-messaging/iot-python/tree/master/samples/customMessageFormat" rel="nofollow">writing a custom codec and registering it with the clients</a>.</p>		<p>A good example of how both data and payload can be used can be found in the <a href="https://github.com/ibm-watson-iot/connector-cloudant/blob/master/connector-cloudant.py#L66" rel="nofollow">connector-cloudant application</a>:</p>		<pre><code>def myEventCallback(self, evt):	    #self.logger.info("%-33s%-30s%s" % (evt.timestamp.isoformat(), evt.device, evt.event + ": " + json.dumps(evt.data)))	    #self.logger.info(evt.data)		    # Create with a generated ID	    future = self._cloudantDb.post(params={	        'typeId': evt.deviceType,	        'deviceId': evt.deviceId,	        'eventId': evt.event,	        'timestamp': evt.timestamp.isoformat(),	        'data': evt.data,	        'format': evt.format,	        'payload': base64.encodestring(evt.payload).decode('ascii')	    })	    future.add_done_callback(self._eventRecordedCallback)	</code></pre>		<p><em>All of this holds true for the current release (0.1.7)</em></p>		<p>Edit: <a href="https://github.com/ibm-messaging/iot-python/releases/tag/0.1.8" rel="nofollow">0.1.8</a> released which fixes a couple of bugs mentioned here affecting application command support.</p>	"
