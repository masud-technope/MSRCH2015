thread_ID, Id, ParentId, PostType, Score, CreationDate, OwnerID, Body
48368262,48368262,null,1,1,Sun Jan 21 15:12:00 EST 2018,1947098,"<p>This is my i2c sensor: <a href="http://www.mindsensors.com/rpi/76-smartdrive-high-current-motor-controller" rel="nofollow noreferrer">http://www.mindsensors.com/rpi/76-smartdrive-high-current-motor-controller</a> look in pdf in Documents sessions please </p>		<p>Based on this google guide <a href="https://developer.android.com/things/sdk/pio/pio-cli.html" rel="nofollow noreferrer">https://developer.android.com/things/sdk/pio/pio-cli.html</a> What I need to put in XX ZZ YY UU to run motors in determined speed, direction, duration, etc...</p>		<p>e.g.: pio i2c I2C1 0x1B write-reg-buffer 0xXX 0xYY 0xUU 0xZZ</p>		<p>As (in this case) I will use writeRegBuffer() on my android things app to run one, two or both motors in determined spped, direction, duration, etc?</p>		<p>e.g.: I used (via jcenter) this driver in intel edison/android things DP2, but now I want to create an AT driver to use smartdrive in nx pico and rpi 3, because there would be no more mraa:</p>		<p><a href="https://github.com/androidthings/contrib-drivers/issues/70" rel="nofollow noreferrer">https://github.com/androidthings/contrib-drivers/issues/70</a></p>		<p><strong><em>My questions is</em></strong>: If you see here: <a href="https://github.com/intel-iot-devkit/upm/blob/master/src/smartdrive/smartdrive.hpp" rel="nofollow noreferrer">https://github.com/intel-iot-devkit/upm/blob/master/src/smartdrive/smartdrive.hpp</a>	and especially in this: <a href="https://github.com/intel-iot-devkit/upm/blob/master/src/smartdrive/smartdrive.cxx" rel="nofollow noreferrer">https://github.com/intel-iot-devkit/upm/blob/master/src/smartdrive/smartdrive.cxx</a>	in function  </p>		<pre><code>SmartDrive::Run_Seconds(int motor_id, int direction, uint8_t speed, uint8_t duration, bool wait_for_completion, int next_action )	</code></pre>		<p>you will see  <code>writeArray(array, sizeof(array));</code></p>		<p>ok. I need help to use this in android things using <code>writeRegBuffer(int reg, byte[] buffer, int length)</code> and <code>write(byte[] buffer, int length)</code></p>	"
48368262,83723285,48368262,3,1,Sun Jan 21 15:23:00 EST 2018,1491707,"What is your question specifically? How to read the datasheet and obtain useful information from it?"
48368262,48375090,48368262,2,1,Mon Jan 22 05:20:00 EST 2018,246461,"<p>Per the <a href="https://developer.android.com/things/sdk/pio/pio-cli.html" rel="nofollow noreferrer">PIO CLI tool</a> doc you linked, the format of the <code>i2c</code> command is:</p>		<pre><code>$ pio i2c &lt;bus_name&gt; &lt;slave_address&gt; &lt;command&gt; &lt;reg&gt; &lt;val&gt;	</code></pre>		<p>Your motor controller has a default slave address of 0x36 and uses registers. As an example you could write to the "Motor 1 Speed" register (address 0x46) using this tool like so:</p>		<pre><code>$ pio i2c I2C1 0x36 write-reg-byte 0x46 &lt;speed_value&gt;	</code></pre>		<p>The same operation from code would look like the following:</p>		<pre><code>PeripheralManagerService manager = new PeripheralManagerService();		I2cDevice device = manager.openI2cDevice("I2C1", 0x36);	device.writeRegByte(0x46, speed);	</code></pre>	"
48368262,83770659,48375090,3,0,Mon Jan 22 22:34:00 EST 2018,1947098,"OpenElectrons_i2c.py  https://pastebin.com/TFbtSiWA   SmartDrive.py 	 https://pastebin.com/6dUYjGY6"
48368262,83759986,48375090,3,0,Mon Jan 22 16:37:00 EST 2018,1947098,"Hi Devunwired, 	Thanks for answer. When I run i2c-address-scanner (app for AT)  I get 0x1B (8 bits address)  and not 0x36 (7 bits smartdrive address)		In python original driver (https://pastebin.com/6dUYjGY6) it is used 0x36 but in C++ driver it is used 0x1b		How to I specify <speed_value> to write-reg-byte if spped value igual 90 (int)?                                                                                                                 	How to I will use writeRegBuffer(int reg, byte[] buffer, int length) and write(byte[] buffer, int length) to pass all parameters at once ????"
48368262,83832024,48375090,3,0,Wed Jan 24 11:23:00 EST 2018,1947098,"Thanks @Devunwired,	Based on this: http://nilhcem.com/android-things/arduino-as-an-i2c-slave,Ido this:https://github.com/neuberfran/SmartDrive5  passing as parameters 0x4E and 90 (to speed default of the motor 02) But motor not run.	you can see in the log below that the build is ok	https://drive.google.com/file/d/1SKZm6OJmS5m8gtr3XsUrv19HYsWjGvNE/view?usp=sharing	I still do not know the real need of the ByteExt.KT and why 0XFF. I understood about write() 're 16 bits. On this I will need work with writer(0x02, 0x46, 90.toByte(), durat, C_Wait,,Action_Brake) 0x02 in original drivers= motor 2"
48368262,83832966,48375090,3,0,Wed Jan 24 11:49:00 EST 2018,1947098,"I said this because this code in c++  used  in Android things/jcenter/intel Edison:	https://drive.google.com/file/d/1mR5uhAp7_NAj8bwRxScg6WB0yNLvD2IM/view?usp=sharing	Pls, Look to:	uint8_t ctrl = 0;	ctrl |= SmartDrive_CONTROL_SPEED;	ctrl |= SmartDrive_CONTROL_TIME;		and		uint8_t array[5] = {SmartDrive_SPEED_M1, speed, duration, 0, ctrl};	writeArray(array, sizeof(array));"
48368262,83807738,48375090,3,0,Tue Jan 23 19:15:00 EST 2018,246461,"I pulled the default slave address from the datasheet. If you device has a different address then use that one. You can enter values on the CLI in either hex or decimal."
48368262,83807766,48375090,3,0,Tue Jan 23 19:16:00 EST 2018,246461,"writeRegBuffer() accepts the register address of the first byte, subsequent values in the array are written into subsequent registers.		You're device uses I2C registers, so I can't see why you would want to use raw write() at all."
48368262,48651428,48368262,2,0,Tue Feb 06 20:28:00 EST 2018,1947098,"<p>run motor 1 in direction A	pio i2c I2C1 0x1B write-raw  0x46 128  0x05 0x00 0xD1</p>		<p>run motor 1 in direction B	pio i2c I2C1 0x1B write-raw  0x46 127  0x05 0x00 0xD1</p>		<p>run motor 2 in direction A	pio i2c I2C1 0x1B write-raw  0x4E 128  0x05 0x00 0xD1</p>		<p>run motor 2 in direction B	pio i2c I2C1 0x1B write-raw  0x4E 127  0x05 0x00 0xD1</p>	"
