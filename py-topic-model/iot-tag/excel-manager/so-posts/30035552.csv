thread_ID, Id, ParentId, PostType, Score, CreationDate, OwnerID, Body
30035552,30035552,null,1,3,Mon May 04 16:53:00 EDT 2015,540776,"<p>we setup a MQTT client powered by <a href="https://github.com/mqttjs/MQTT.js" rel="nofollow">MQTT.js</a> (either on a desktop PC or on the actual board, is the same) and a MQTT broker powered by <a href="https://github.com/mcollina/mosca" rel="nofollow">mosca</a>, this one running on the desktop PC.</p>		<p>We are able to successfully send a message with a specific topic <em>from client to broker</em>, but now we're stuck on the opposite: send a message <strong>from broker to client</strong>.</p>		<p>We're following the code samples provided on both project docs, but with no luck. Client is able to correctly register to topic, but does not react in any way when message is sent. Broker is able to correctly send the message and also to listen to its own message, as it's listening for all messages anyway.</p>		<p>Excerpt from MQTT broker:</p>				<pre><code>broker.on('published', function(packet, client) {	  console.log('MQTT broker received message');  // it passes by here	  console.log(' - packet:', packet);	  console.log(' - packet payload:', packet.payload.toString());	});		// ...		var packet = {	  topic: 'our_custom_topic',	  payload: ourCustomPayload,	  qos: 1,	  retain: false,  	};		console.log('MQTT broker sending message to client ...');		broker.publish(packet, function() {	  console.log('Message sent');  // it passes by here	});	</code></pre>		<p>Excerpt from MQTT client:</p>				<pre><code>client.on('connect', function () {	  console.log('MQTT client connected');		  client.subscribe('our_custom_topic', { qos: 1 }, function onSubscribe(err, granted) {	    if (err) {	      console.log('subscribe errors:', err);  // no error shown	    }		    if (granted) {	      console.log('subscribe granted:', granted);  // it passes by here	    }	  });	});		// ...		client.on('message', function (topic, message, packet) {	  console.log('MQTT client received message');  // it DOESN'T pass by here	  console.log(' - topic', topic);	  console.log(' - message', JSON.stringify(message));	  console.log(' - packet', JSON.stringify(packet));	});	</code></pre>		<h3>Update</h3>		<p>The problem seems to show up when persistence is based on mongoDb. Instead messages are correctly sent to subscribers when persistence is memory-based. Here are our pub-sub settings when relying persistence on mongoDb. Actually, it's a development instance running on mongolab.com:</p>				<pre><code>var mongoDbSettings = {	  // remote MongoLab mongodb instance	  url: 'mongodb://mqtt-db-user:&lt;OUR-USER-CODE&gt;@&lt;THEIR-INSTANCE-SUBDOMAIN&gt;.mongolab.com:39291/sample-mqtt-datastore',	  pubsubCollection: 'myCollections',	};		var mongoDbBrokerSettings = {	  port: 1883,  // mosca (mqtt) port		  // using ascoltatore over MongoDB	  backend: {	    type: 'mongo',	    url: mongoDbSettings.url,	    pubsubCollection: mongoDbSettings.pubsubCollection,	    mongo: {},	  },	  persistence: {	    factory: mosca.persistence.Mongo,	    url: mongoDbSettings.url,	  }	};		var broker = new mosca.Server(mongoDbBrokerSettings, function onCreated(err, broker) {	  // assume no errors		  console.log('MQTT broker is up and running');	});	</code></pre>		<p>does anyone spot anything wrong with that?</p>	"
30035552,48187897,30035552,3,0,Mon May 04 17:19:00 EDT 2015,540776,"We patched [MQTT.js\client.js](https://github.com/mqttjs/MQTT.js/blob/master/lib/client.js#L694) with some debug logs, and apparently its `_handlePublish` method is not even invoked, so no `'message'` event could actually be fired. Still investigating..."
30035552,48232823,30035552,3,0,Tue May 05 17:01:00 EDT 2015,540776,"We put up a sample test [on github](https://github.com/BrainCrumbz/mosca-publish-demo) with a server publishing on a topic and a client subscribed to that: this works, apart from a *server created* callback invoked twice.  	In the actual project, the MQTT broker is also an express + socket.io web server, of course on a different port. Don't know if this could be a root cause of the problem"
30035552,48188176,30035552,3,0,Mon May 04 17:26:00 EDT 2015,540776,"Going up the client.js chain, not even `_handlePacket` method within `process` is invoked when broker sends the message."
30035552,48192040,30035552,3,0,Mon May 04 19:09:00 EDT 2015,540776,"Looking at mosca side, we added some debug logs to [mosca\server.js](https://github.com/mcollina/mosca/blob/master/lib/server.js#L326) and one can see that `publish` method is invoked, as well as inner `that.published` callback."
30035552,48192116,30035552,3,0,Mon May 04 19:12:00 EDT 2015,540776,"While [publishing on ascoltatore](https://github.com/mcollina/mosca/blob/master/lib/server.js#L321), at some point we saw some kind of exception or error message, that caused the client to disconnect and reconnect on its own but reported **no issue** on server side. Error was *Argument must be a string* in `publish` at `....\mqtt-connection\node_modules\mqtt-packet\generate.js:227:22`"
30035552,31042709,30035552,2,1,Thu Jun 25 06:23:00 EDT 2015,2213375,"<p>An MQTT Broker handles messages between clients, does not sent them (except for Last Will Testament special messages).</p>		<p>You have to implement the following:</p>		<ul>	<li>Client A subscribes to a topic: test/one</li>	<li>Client B publishes a message to the same topic: test/one</li>	<li>Automatically all subscribed clients to this topic (like Client A) will get the message.</li>	</ul>		<p>But yes in Mosca you can instantiate a client object that acts as an MQTT Client and can publish. </p>		<p>You should debug that this messages are effectively published with an external client like mosquitto_sub or MQTT.fx subscribed to the <code>our_custom_topic</code>. </p>		<p>The persistence should not affect the publishing of messages, but you can install mosquitto and test if using it as backend works <a href="https://github.com/mcollina/mosca/wiki/Mosca-advanced-usage" rel="nofollow">https://github.com/mcollina/mosca/wiki/Mosca-advanced-usage</a></p>	"
30035552,50129664,31042709,3,0,Thu Jun 25 15:11:00 EDT 2015,540776,"? I think that is actually the scenario I described at the beginning: an MQTT client powered by MQTT.js, with a MQTT broker powered by mosca, each running on node.js"
30035552,50130240,31042709,3,0,Thu Jun 25 15:23:00 EDT 2015,2213375,"Brokers handle messages. Clients gets messages via connecting to the Broker and subscribing to a topic or sends messages via connecting to the Broker and publishing to a topic. Brokers cannot sent messages, a client connected to a broker, yes."
30035552,50130885,31042709,3,0,Thu Jun 25 15:38:00 EDT 2015,540776,""Brokers cannot sent messages, a client connected to a broker, yes." Where in mosca API or docs is this prevented? I know the regular behaviour, but as I said there seems to be nothing against that in broker implementation, i.e. broker *can* send messages."
30035552,50129006,31042709,3,0,Thu Jun 25 14:58:00 EDT 2015,2213375,"MQTT.js is just a MQTT Client implementation for node.js			You will need to run a Broker like mosca for node.js			http://mcollina.github.io/mosca/"
30035552,50112921,31042709,3,0,Thu Jun 25 08:38:00 EDT 2015,540776,"thanks for your feedback. Yes that is the "classic" - so to say - way it works, but the API seems to support also server sending messages, and we did not find any mention that this should not be done. In our context, that scenario was useful."
30035552,32029810,30035552,2,0,Sat Aug 15 22:01:00 EDT 2015,1546710,"<p>You can publish directly from the broker, as it's a part of the Mosca public API:</p>		<pre><code>/**	 * Publishes a packet on the MQTT broker.	 *	 * @api public	 * @param {Object} packet The MQTT packet, it should include the	 *                        topic, payload, qos, and retain keys.	 * @param {Object} client The client object (internal)	 * @param {Function} callback The callback	 */	Server.prototype.publish = function publish(packet, client, callback)...	</code></pre>		<p>As long as your client is subscribed, you can send via <code>broker.publish({topic:"/foo/bar", payload:'foo'}, client)</code> on the client (i.e. from callback) of the model instance you want to send.</p>	"
30035552,51980967,32029810,3,0,Sun Aug 16 21:41:00 EDT 2015,1546710,"do you mean to store and access the client object? the solution above does and should not use backend of mqtt configs. the value should be stored relative to the user or device or whatever your model is named."
30035552,52017243,32029810,3,0,Mon Aug 17 20:33:00 EDT 2015,540776,"sorry, my bad, I don't get it. Our client is subscribed to `our_custom_topic`. Broker prepares a packet with that topic and publish that. Client should receive and react to that, but instead it behaves as nothing happened. That same bit of code (server and client), left untouched, works if server is configured with in-memory persistence, and stops working if server is configured with mongodb persistence. Persistence configuration is needed for other reasons (e.g. the guaranteed QoS level of communication), and should not affect this use case."
30035552,51973051,32029810,3,0,Sun Aug 16 14:21:00 EDT 2015,540776,"if you look at the question & code samples, that's actually what we tried to do. It worked with memory-based persistence, while it did not work with mongodb-based persistence (with mongodb running on mongolab.com)"
