thread_ID, Id, ParentId, PostType, Score, CreationDate, OwnerID, Body
32102888,32102888,null,1,3,Wed Aug 19 18:22:00 EDT 2015,1073912,"<p>I need to write a method in my Windows Universal App to write to the SD card.  How can I ensure two threads do not try to write to the same file at the same time in my method below ?</p>		<pre><code>public async void WriteToCard(string strFileName, IEnumerable&lt;string&gt; listLinesToWrite)	{	    IStorageItem item = await folder.GetItemAsync(strFileName);	    StorageFile file = (StorageFile)item;		    await Windows.Storage.FileIO.WriteLinesAsync(file, listLinesToWrite);	}	</code></pre>	"
32102888,52100219,32102888,3,0,Wed Aug 19 18:26:00 EDT 2015,76051,"easiest way: write one after the other (most likely you will not get much quicker if you try to write in parallel anyways) - if not you have to take care of it yourself (no way to give good advicel from this snippet)"
32102888,52100434,32102888,3,0,Wed Aug 19 18:32:00 EDT 2015,1073912,"Carsten - I'm not looking for a performance boost.  My concern is this method being called twice on the same file.  I will edit my question with the code I used in my old app where I used a lock.  It's my understanding you should not use a lock in an async method."
32102888,52100503,32102888,3,1,Wed Aug 19 18:34:00 EDT 2015,76051,"yes they are tricky to use (as dcastr said there are some) - I would just queue all writes up and write them one after the other (there are prebuild things in TPL-dataflow and you will surely find something if you look for *agents* - but of course you can just use `Queue`, `ConcurrentQueue`, ...)"
32102888,52100858,32102888,3,0,Wed Aug 19 18:42:00 EDT 2015,857807,"@Carsten is probably referring to the `ActionBlock<T>` when he mentioned the TPL Dataflow lib."
32102888,52100977,32102888,3,0,Wed Aug 19 18:45:00 EDT 2015,76051,"yes that's it (I never remember as you have better options in F# ;) )"
32102888,32102979,32102888,2,4,Wed Aug 19 18:27:00 EDT 2015,857807,"<p>You can use the <a href="https://www.nuget.org/packages/Nito.AsyncEx" rel="nofollow">AsyncEx</a> library, which contains an <a href="https://github.com/StephenCleary/AsyncEx/wiki/AsyncLock" rel="nofollow"><code>AsyncLock</code></a></p>		<p>Assuming there won't be a huge number of filenames, you can use a <code>ConcurrentDictionary</code> to associate a filename to a lock - otherwise, the dictionary size might grow unbound.</p>		<pre><code>private readonly locks = new ConcurrentDictionary&lt;string, AsyncLock&gt;();		public async void WriteToCard(string strFileName, IEnumerable&lt;string&gt; listLinesToWrite)	{	    var lock = locks.GetOrAdd(strFileName, () =&gt; new AsyncLock());		    using (await lock.LockAsync())	    {	        IStorageItem item = await folder.GetItemAsync(strFileName);	        StorageFile file = (StorageFile)item;		        await Windows.Storage.FileIO.WriteLinesAsync(file, listLinesToWrite);	    }	}	</code></pre>	"
32102888,52118061,32102979,3,2,Thu Aug 20 07:49:00 EDT 2015,144746,"There's no need to be worried about millions of files as long as you just use weak references for the keys. ConditionalWeakTable is a standard option, but has list performance which might become a bottleneck (there might be standard solutions by now that don't have this downside), but at least you don't have a memory leak."
32102888,52100294,32102979,3,2,Wed Aug 19 18:28:00 EDT 2015,76051,"this will only allow to write one *thread* to write to one file at any time ... so just the same as just doing them in an old fashioned for loop ..."
32102888,52100356,32102979,3,0,Wed Aug 19 18:30:00 EDT 2015,857807,"@Carsten That assumes the writes are being done in a deterministic order, by the same thread. In which case, no synchronization is needed whatsoever, and the question has no meaning. If the writes are being done in a non-deterministic fashion by multiple threads, then this is needed."
32102888,52100427,32102979,3,0,Wed Aug 19 18:31:00 EDT 2015,76051,"I can only guess because it's not 100% clear - but I think he wants to write to multiple different files (maybe to the same more than once) - so you only have to watch out that you don't write to the same file at the same time - the rest could possible be worked from a few parallel threads"
32102888,52100521,32102979,3,0,Wed Aug 19 18:34:00 EDT 2015,76051,"@Brandon that is exactly what I was trying to say"
32102888,52100775,32102979,3,0,Wed Aug 19 18:40:00 EDT 2015,857807,"@Brandon updated"
32102888,52100893,32102979,3,0,Wed Aug 19 18:43:00 EDT 2015,1073912,"I will not be writing to a bunch of files at the same time.  I just want to make sure my method does not try to write to the same file from two different calls / threads.  I think dcastro's code snippet solves my problem."
32102888,32103274,32102888,2,3,Wed Aug 19 18:43:00 EDT 2015,1870803,"<p>You could keep a map with a <code>ConcurrentDictionary</code> which maps each file to a <code>SemaphoreSlim</code>. Then, fetch each semaphore based on the file location you'll be writing to:</p>		<pre><code>private ConcurrentDictionary&lt;string, SemaphoreSlim&gt; fileLocks = new ConcurrentDictionary&lt;string, SemaphoreSlim&gt;();		public async Task WriteToCardAsync(string strFileName, IEnumerable&lt;string&gt; listLinesToWrite)	{	   var semaphoreSlim = fileLocks.GetOrAdd(strFileName, new SemaphoreSlim(1, 1));		   await semaphoreSlim.WaitAsync();	   try	   {	       IStorageItem item = await folder.GetItemAsync(strFileName);	      StorageFile file = (StorageFile)item;		        await Windows.Storage.FileIO.WriteLinesAsync(file, listLinesToWrite);	   }	   finally	   {	       semaphoreSlim.Release();	   }	}	</code></pre>		<p>Side note - Use <code>async Task</code> instead of <code>async void</code>. I also added the <code>Async</code> postfix to the methods.</p>	"
32102888,52103979,32103274,3,0,Wed Aug 19 20:09:00 EDT 2015,1870803,"@Bill The objects in the dictionary will only be created once you start initializing them when running the method. The minor advantage here is that `SemaphoreSlim` comes OOTB for WP8.1, instead of getting a NuGet package. That's the only difference. `Lazy` wasn't needed here."
32102888,52101701,32103274,3,0,Wed Aug 19 19:05:00 EDT 2015,1159478,"You don't actually need the `Lazy` here.  Having the dictionary map directly to the semaphores would be fine.  If you're worried about creating additional semaphores (which shouldn't be a large concern, but still) simply use the overload of `GetOrAdd` that takes a factory delegate, rather than an object itself."
32102888,52101743,32103274,3,0,Wed Aug 19 19:06:00 EDT 2015,1073912,"@Yuval Itzchakov  Thanks for the nice answer.  Is the purpose of Lazy<SemaphoreSlim> to prevent the creation of the ConcurrentDictionary until needed to save on resources ?"
32102888,52101760,32103274,3,0,Wed Aug 19 19:07:00 EDT 2015,1159478,"@BillGreer The dictionary is created as soon as this class is used for the first time, so that has no bearing on it."
32102888,52101798,32103274,3,0,Wed Aug 19 19:08:00 EDT 2015,1073912,"Just trying to get my head wrapped around Lazy.  I looked at the MSDN documentation but I'm still confused :)"
32102888,52102046,32103274,3,0,Wed Aug 19 19:16:00 EDT 2015,1159478,"@BillGreer Like I said in my first comment; it's superfluous in this case.  It's not harmful, it's just not accomplishing anything important."
32102888,52103063,32103274,3,0,Wed Aug 19 19:43:00 EDT 2015,1870803,"@Servy I remembered `valueFactory` (in `ConcurrentDictionary` methods) had the side-effect of running the delegate multiple times. Wasn't sure of that was the case here."
32102888,52103148,32103274,3,0,Wed Aug 19 19:45:00 EDT 2015,1159478,"@YuvalItzchakov It's not guaranteed to not run it multiple times, although it doesn't *always* run multiple times for each key, but as the object in question here doesn't cause side effects on construction, nor is it particularly expensive to construct, that's not a problem at all.  Like I said in my first comment, if you create a few extra semaphores that you throw away it's just not a big deal."
32102888,52103181,32103274,3,0,Wed Aug 19 19:46:00 EDT 2015,1870803,"@Servy I guess it's probably not that meaningful here then."
