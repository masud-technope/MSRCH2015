thread_ID, Id, ParentId, PostType, Score, CreationDate, OwnerID, Body
47865874,47865874,null,1,15,Mon Dec 18 09:57:00 EST 2017,4817630,"<p>I have an IoT application that uses <a href="https://developer.apple.com/library/content/documentation/NetworkingInternet/Conceptual/NetworkingTopics/Articles/UsingSocketsandSocketStreams.html" rel="noreferrer">Socket Programming</a> to communicate with the device. All good up until iOS 11 released. It doesn't communicate in iOS 11 and above but it works in earlier versions ( Up to 10). Here is the code.</p>		<p><strong>Establishing Socket Connection</strong>         </p>		<pre><code>(void)setUpSocketConnection {	    @try {	        CFStreamCreatePairWithSocketToHost(kCFAllocatorDefault, (__bridge CFStringRef) VeranoHost,VeranoPort , &amp;readStream, &amp;writeStream);	        [self open];	    }	    @catch (NSException *exception) {	        NSLog(@"Open Exception:%@", exception.reason);	    }   	}	</code></pre>		<p><strong>Opening Streams</strong></p>		<pre><code>(void)open {	    //NSLog(@"Opening streams.");	    _outputStream = (__bridge  NSOutputStream *)writeStream;	    _inputStream = (__bridge  NSInputStream *)readStream;	    [_outputStream setDelegate:self];	    [_inputStream setDelegate:self];		    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH,0);	    dispatch_async(queue, ^ {	            [_outputStream scheduleInRunLoop:[NSRunLoop currentRunLoop] forMode:NSDefaultRunLoopMode];	            [_inputStream scheduleInRunLoop:[NSRunLoop currentRunLoop] forMode:NSDefaultRunLoopMode];	            [[NSRunLoop currentRunLoop] run];	    });		    [_outputStream open];	    [_inputStream open];		    //[self disableNaglesAlgorithmForStream:_inputStream];	   // NSLog(@"Connected");	//    self.timeOutTimer = [NSTimer scheduledTimerWithTimeInterval:10.0	//                                                         target:self	//                                                       selector:@selector(timerTimeOutAction:)	//                                                       userInfo:nil	//                                                        repeats:NO];	}	</code></pre>		<p><strong>Writing to Output Stream</strong></p>		<pre><code>(void)writeData:(NSString *)message forSocketType:(SOCKETTTYPE)socketType {	    self.socketType = socketType;	    NSData *data = [[NSData alloc] initWithData:[message dataUsingEncoding:NSASCIIStringEncoding]];	    [_outputStream write:[data bytes] maxLength:[data length]];	    [_outputStream close];		}	</code></pre>		<p><strong>Event Handler</strong></p>		<pre><code>(void)stream:(NSStream *)theStream handleEvent:(NSStreamEvent)streamEvent {	   // NSLog(@"stream event %lu", (unsigned long)streamEvent);	    switch (streamEvent) {	        case NSStreamEventOpenCompleted:{		           // NSLog(@"NSStreamEventOpenCompleted :::: Stream opened and connected");	        }	            break;	        case NSStreamEventHasBytesAvailable:	            // NSLog(@"NSStreamEventHasBytesAvailable :::: Stream opened and connected");	            if (theStream == _inputStream) {	                uint8_t buffer[1024];	                NSInteger len;		                while ([_inputStream hasBytesAvailable])	                {	                    len = [_inputStream read:buffer maxLength:sizeof(buffer)];	                    if (len &gt; 0)	                    {	                        NSString *output = [[NSString alloc] initWithBytes:buffer length:len encoding:NSASCIIStringEncoding];		                        if (nil != output)	                        {	                            NSLog(@"server said: %@", output);	                            [self messageReceived:output];	                        }	                    }	                }	            }	            break;	        case NSStreamEventHasSpaceAvailable:	           // NSLog(@"NSStreamEventHasSpaceAvailable :::: Stream has space available now");	            break;		        case NSStreamEventErrorOccurred:{	           NSError *theError = [theStream streamError];	            NSLog(@"Error Description:%@",theError.localizedDescription);	            [self close];	            if(self.delegate &amp;&amp;[self.delegate respondsToSelector:@selector(socketHandlerItem:failureWithError:forSocketType:)]){	                [self.delegate socketHandlerItem:self failureWithError:[theStream streamError] forSocketType:self.socketType];	            }	             //NSLog(@"NSStreamEventErrorOccurred :::: %@",[theStream streamError].localizedDescription);	        }	            break;		        case NSStreamEventEndEncountered:	            [theStream close];	            [theStream removeFromRunLoop:[NSRunLoop currentRunLoop] forMode:NSDefaultRunLoopMode];	            if(self.delegate &amp;&amp;[self.delegate respondsToSelector:@selector(socketHandlerItem:eventStopedWithstatus:forSocketType:)]){	                [self.delegate socketHandlerItem:self eventStopedWithstatus:YES forSocketType:self.socketType];	            }	           // NSLog(@"NSStreamEventEndEncountered :::: close stream Disconnected");	            break;	        default:	           // NSLog(@"Unknown event");	            break;	    }	}	</code></pre>		<blockquote>	  <p>So, when connecting to the socket it enters to the	  <code>NSStreamEventErrorOccurred</code> in the event handler and logs - <code>The operation couldn’t be completed. No route to host</code></p>	</blockquote>		<p>Any help would be greatly appreciated.</p>		<p><strong>Update Dec 19, 2017</strong></p>		<ul>	<li>Got a <a href="http://apple.co/2By9Lhl" rel="noreferrer">Reachability</a> wrapper that allows to discover host address and I can confirm that it returns the NetworkStatus <code>ReachableViaWiFi</code></li>	<li>Socket communication works fine, I tried by creating a sample server socket, able to send and receive data.</li>	</ul>		<p><strong>Update Dec 20, 2017 (1)</strong></p>		<blockquote>	  <p>IoT device Details - <code>USR-WIFI232-S</code> Low Power WiFi Module</p>	  	  <p>User Manual <a href="https://www.elecrow.com/download/USR-WIFI232%20Low%20Power%20WiFi%20Module%20User%20Manual%20V2.2.pdf" rel="noreferrer">Here</a></p>	</blockquote>		<p><strong>Update Dec 20, 2017 (2)</strong></p>		<p>Eurekaa, but the solution can't be applied in real time. While setting a nearest range of static IP address in iOS 11 corresponding to IoT module's host address the communication works fine. but it doesn't work with the dynamically allocated IP address.</p>	"
47865874,82696733,47865874,3,0,Mon Dec 18 09:59:00 EST 2017,3418066,"What is the error message/code?"
47865874,82696854,47865874,3,0,Mon Dec 18 10:02:00 EST 2017,4817630,"@Paulw11 -  `NSError *theError = [theStream streamError];` I've casted to `NSError` then logged `localizedDescription` and it shows `The operation couldn’t be completed. No route to host`"
47865874,82696924,47865874,3,1,Mon Dec 18 10:04:00 EST 2017,3418066,"So, it can't reach the host since it received an ICMP response stating that there was no way of routing to it. Is the host on the local network?  Have you tried a network capture to seed ios is event attempting a connection?"
47865874,82697095,47865874,3,0,Mon Dec 18 10:09:00 EST 2017,4817630,"@Paulw11,  basically its an IoT device and I'm connecting iPhone to the WiFi provided by the device. WiFi communication works in older versions of iOS. So, we can assume this is not the issue with device right?"
47865874,82697175,47865874,3,0,Mon Dec 18 10:11:00 EST 2017,4817630,"Yes, the host is on the local network as I'm connecting to device WiFi."
47865874,82726364,47865874,3,0,Tue Dec 19 04:57:00 EST 2017,4817630,"@GeneCode `SocketRocket` wrapper is used for communicating with web socket right? Well, that's fine, but why this code doesn't work in iOS 11 and above, any idea?"
47865874,82727461,47865874,3,1,Tue Dec 19 05:59:00 EST 2017,501439,"Yup. As for why it fail in iOS11, I am guessing it's a bug. Have u tried asking in Apple Developer forum? iOS11 is so buggy i tell u that"
47865874,82780010,47865874,3,1,Wed Dec 20 12:56:00 EST 2017,2854159,"@Stella. Can you try this https://www.raywenderlich.com/157128/real-time-communication-streams-tutorial-ios"
47865874,82782337,47865874,3,0,Wed Dec 20 13:54:00 EST 2017,4817630,"@Vaisakh Thanks, Let me try this out."
47865874,82732601,47865874,3,0,Tue Dec 19 09:14:00 EST 2017,4817630,"@GeneCode Yes, It has been reported [thread](https://forums.developer.apple.com/thread/94002)"
47865874,82942521,47865874,3,0,Wed Dec 27 05:38:00 EST 2017,7007326,"Are you using pods for sockets?"
47865874,82724258,47865874,3,0,Tue Dec 19 02:16:00 EST 2017,501439,"Better change ur code to SocketRocket then it will be ok."
47865874,48364092,47865874,2,1,Sun Jan 21 05:53:00 EST 2018,2705182,"<p>I Wonder if it App Transport Security (ATS), See: <a href="https://www.nowsecure.com/blog/2017/08/31/security-analysts-guide-nsapptransportsecurity-nsallowsarbitraryloads-app-transport-security-ats-exceptions/" rel="nofollow noreferrer">https://www.nowsecure.com/blog/2017/08/31/security-analysts-guide-nsapptransportsecurity-nsallowsarbitraryloads-app-transport-security-ats-exceptions/</a></p>		<p>For iOS 11 ATS updates some ATS updates are expected as a part of that:</p>		<ul>	<li>TLSv1.3 will receive preliminary support</li>	<li>3DES will be removed from the approved list of ciphers</li>	<li>Certificates signed with SHA1 will no longer be accepted</li>	<li>Certificates signed with RSA keys must have 2048-bit key lengths or larger</li>	</ul>		<p>PLIST and Entitlements are you using in your app?</p>		<pre><code>&lt;key&gt;NSAppTransportSecurity&lt;/key&gt;	&lt;dict&gt;	    &lt;key&gt;NSAllowsArbitraryLoads&lt;/key&gt;	    &lt;true/&gt;	    &lt;key&gt;NSExceptionDomains&lt;/key&gt;	    &lt;dict&gt;		        &lt;key&gt;creativecommons.org&lt;/key&gt;	        &lt;dict&gt;	            &lt;key&gt;NSIncludesSubdomains&lt;/key&gt;	            &lt;true/&gt;	            &lt;key&gt;NSTemporaryExceptionAllowsInsecureHTTPLoads&lt;/key&gt;	            &lt;true/&gt;	            &lt;key&gt;NSThirdPartyExceptionRequiresForwardSecrecy&lt;/key&gt;	            &lt;false/&gt;	        &lt;/dict&gt;		        &lt;key&gt;localhost&lt;/key&gt;	        &lt;dict&gt;	            &lt;key&gt;NSIncludesSubdomains&lt;/key&gt;	            &lt;true/&gt;	            &lt;key&gt;NSTemporaryExceptionAllowsInsecureHTTPLoads&lt;/key&gt;	            &lt;true/&gt;	        &lt;/dict&gt;		    &lt;/dict&gt;	&lt;/dict&gt;	</code></pre>		<p>Also one more option, if you want to disable ATS you can use this :</p>		<pre><code>&lt;key&gt;NSAppTransportSecurity&lt;/key&gt;  	 &lt;dict&gt;  	      &lt;key&gt;NSAllowsArbitraryLoads&lt;/key&gt;&lt;true/&gt;  	 &lt;/dict&gt;	</code></pre>		<p>But this is not recommended ! </p>	"
