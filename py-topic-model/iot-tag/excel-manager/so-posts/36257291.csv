thread_ID, Id, ParentId, PostType, Score, CreationDate, OwnerID, Body
36257291,36257291,null,1,1,Mon Mar 28 06:41:00 EDT 2016,5554585,"<p>I am using a RFID reader to receive messages. I'm trying to avoid duplicated message by appending them to <code>emptylist = []</code> and don't further append them if they exist in the list. Below are my code:</p>		<pre><code>import paho.mqtt.client as mqtt		def on_connect(client, userdata, flags, rc):	    print("Connected with result code " + str(rc))	    client.subscribe("/whatver/#")		def on_message(client, userdata, msg): # when PUBLISH msg is rcvd frm the server	    payloadjson = json.loads(msg.payload.decode('utf-8'))	    line = payloadjson["value"].split(',')	    epc =  line[1]			    payload = {'a': epc[11:35], 'b':payloadjson["devicename"], 'c':payloadjson["sensorname"]}		    emptylist = []	    emptylist.append(payload)		    if payload not in emptylist:	        emptylist.append(payload)		    print (emptylist)		test = mqtt.Client(protocol = mqtt.MQTTv31)	test.connect(host=_host, port=1883, keepalive=60, bind_address="")	test.on_connect = on_connect	test.on_message = on_message	test.loop_forever() 	</code></pre>		<p>However I am getting output as below, which shows that <code>payload</code> is appended to the <code>emptylist</code>, but is stored into multiple separated lists.  And it keeps printing the same output if the RFID reader is still reading the same tag. I would like to remove the duplicated messages and retain only one even if the RFID reader reads the same tag.</p>		<pre><code>[{'b': 'READERBASIN.3', 'c': 'ANTENNA.2', 'a': '000000000000130000624462'}] # from Tag A	[{'b': 'READERBASIN.3', 'c': 'ANTENNA.2', 'a': 'abcxxx000000130000627000'}] # from Tag B	[{'b': 'READERBASIN.3', 'c': 'ANTENNA.2', 'a': '000000000000130000624462'}] # from Tag A	[{'b': 'READERBASIN.3', 'c': 'ANTENNA.2', 'a': '000000000000130000624462'}] # from Tag A	.	.	.	</code></pre>		<p>How can I fix this?</p>	"
36257291,36257343,36257291,2,0,Mon Mar 28 06:45:00 EDT 2016,5896781,"<p>Either you can check for existence while appending as below:</p>		<pre><code>if payload not in emptylist:	   emptylist.append(payload)	</code></pre>		<p>or </p>		<p>You can choose <code>set(emptylist)</code> on your final output.</p>	"
36257291,36257892,36257291,2,2,Mon Mar 28 07:27:00 EDT 2016,4014959,"<p>As the other answers mention, a set is a great way to avoid storing or printing duplicates. You <em>can</em> do this (less efficiently) using lists, however, the logic in your current code is incorrect. It creates a fresh empty <code>emptylist</code> every time that <code>on_message</code> is called, and then appends the new <code>payload</code> to it, so the following <code>if payload not in emptylist:</code> doesn't make much sense.</p>		<p>You need to initialize <code>emptylist</code> outside of the <code>on_message</code> callback. Eg,</p>		<pre><code>emptylist = []		def on_message(client, userdata, msg): # when PUBLISH msg is rcvd frm the server	    payloadjson = json.loads(msg.payload.decode('utf-8'))	    line = payloadjson["value"].split(',')	    epc =  line[1]		    payload = {	        'a': epc[11:35], 	        'b':payloadjson["devicename"], 	        'c':payloadjson["sensorname"],	    }		    if payload not in emptylist:	        emptylist.append(payload)	        print (emptylist)	</code></pre>		<p>That will only append &amp; print the new payload if it's not already in <code>emptylist</code>.</p>		<p>To do the same thing using a set:</p>		<pre><code>emptylist = set()		def on_message(client, userdata, msg): # when PUBLISH msg is rcvd frm the server	    payloadjson = json.loads(msg.payload.decode('utf-8'))	    line = payloadjson["value"].split(',')	    epc =  line[1]		    payload = {	        'a': epc[11:35], 	        'b':payloadjson["devicename"], 	        'c':payloadjson["sensorname"],	    }		    if payload not in emptylist:	        emptylist.add(payload)	        print (emptylist)	</code></pre>		<p>FWIW, <code>emptylist</code> is a slightly confusing variable name. :)</p>	"
36257291,60144777,36257892,3,0,Mon Mar 28 07:38:00 EDT 2016,5554585,"Thanks for this great tip!"
