thread_ID, Id, ParentId, PostType, Score, CreationDate, OwnerID, Body
54681477,54681477,null,1,0,Thu Feb 14 00:23:00 EST 2019,11059316,"<p>I'm writing a script for a Raspberry Pi in Python whose purpose is to listen to a server/message broker for commands and execute said commands with certain hardware.  Sometimes, those commands must last for a specified duration (i.e. I need something to turn on, stay on for t seconds, then turn off) and this is accomplished by having the code sleep for said duration between on and off commands (this happens inside a function call -- hardware1.on(dur = t)).  I would like to be able to interrupt that sequence with another command (such as turning the hardware off before t seconds is up).  I've tried to accomplish this via multiprocessing,  but cannot get the behavior I'm looking for.</p>		<p>This hardware (a stalk of differently colored lights) is controlled via a class, LiteStalk.  This class is made up of Lite objects (each light in the stalk), which have their own class too.  Both classes inherit multiprocessing.process.  In my main code that creates a specific LiteStalk and then listens to a message broker (MQTT-based) for commands, I evaluate the commands published to the broker (this is in the on_message callback which runs when a message is published to the broker).</p>		<pre><code>import time	import LiteCntrlModule as LiteStalkMod	import multiprocessing	import paho.mqtt.client as mqtt		print('Starting...\n')		# Set gpio designatin mode to BCM	gpio.setmode(gpio.BCM)		# Initialize light stalk	stalkdict = {'red':1, 'yel':2, 'grn':3, 'bzr':4}	stalk = LiteStalkMod.LiteStalk(stalkdict)	msgRec = ""		def on_connect(client, userdata, flags, rc):	    print("Connected with result code "+str(rc))	    if(rc == 0):	        print('Code "0" indicates successful connection.  Waiting for messages...')	    # Subscribing in on_connect() means that if we lose the connection and	    # reconnect then subscriptions will be renewed.	    client.subscribe("asset/andon1/state")		# The callback for when a PUBLISH message is received from the server.	def on_message(client, userdata, msg):	    print(msg.topic+" "+str(msg.payload))	    msgRec = msg.payload	    eval(msg.payload)	    if msg.payload == "stalk.off()":	        print("If this executes while another command is running, it works!")		client = mqtt.Client(client_id="")	client.username_pw_set("mytopic", password="mypassword")	client.on_connect = on_connect	client.on_message = on_message		client.connect("mymessagebrokeraddress", 1883, 60)	client.subscribe("mytopic")		# Blocking call that processes network traffic, dispatches callbacks and	# handles reconnecting.	# Other loop*() functions are available that give a threaded interface and a	# manual interface.		try:	    client.loop_start() # start listening in a thread and proceed		except KeyboardInterrupt: # so that aborting with Ctrl+C works cleanly	stalk.off()		finally:	stalk.shutDown()	</code></pre>		<h3>LiteCtnrlModule (Lite and LiteStalk classes) follows:</h3>		<pre><code>import time	import multiprocessing	from relay_lib_seeed import *	</code></pre>		<p>class Lite(multiprocessing.Process):</p>		<pre><code># A Lite object has an associated relay and functions	# Ex: red	    # A lite can be controlled	    # Ex: red.blink()       		def __init__(self, relayIn):	    # Ex: red = Lite.Lite(1)	    multiprocessing.Process.__init__(self) # allows you to create multiple objects that can be run as threads	    self.daemon = True # creates a daemon thread that will exit when the main code terminates	    self.start() # allows multiproc. to begin	    self.relay = relayIn		def shutDown(self):	    # terminates the threaded object	    relay_off(self.relay)	    self.join()		def off(self, dur = 0):	            # turns light off		def on(self, dur = 0):	            # turns light on, optional duration to stay on for		# blink	def blink(self, dur = 0, timeOn = .5, timeOff = .5):	            # blinks light	</code></pre>		<p>class LiteStalk(multiprocessing.Process):</p>		<pre><code># A LiteStalk object can have any number of "lite" onjects in it. Ex:	    # Object: stalk1	        # A lite object in stalk1 respresents one segment/color of the light stalk	        # stalk1.red	            # Any lite can be turned on/off in various patterns for amounts of time, etc.	            # stalk1.red.blink()	        # An entire stalk can be controlled all at once	        # stalk1.cycle()		liteList = {}		def __init__(self, liteListIn):		    # liteListIn = {'clr1':relay1, 'clr2":relay2, 'clr3':relay3]...}	    self.liteList = liteListIn;	    multiprocessing.Process.__init__(self) # allows you to create multiple objects that can be run as threads	    self.daemon = True # creates a daemon thread that will exit when the main code terminates	    self.start() # allows multiproc. to begin	    for lite in self.liteList: # for each lite color string in the lites dict	        setattr(self, lite, Lite(self.liteList[lite])) # creates a lite obj attr in the LiteStalk obj	    print(self.liteList)		def shutDown(self):		    # each light is turned off and that gpio pin is cleaned-up	    relay_all_off()	    self.join() # joins thread		def off(self, dur = 0):	            # turns all hardware off		def on(self): 	            # turns all hardware on, optional duration to stay on for	def blink(self, timeOn, timeOff):	            # blinks all hardware		def cntDn(self, dur = 20, yelDur = 2, redDur = 10): #in min	    # enters a count down sequence	</code></pre>		<p>The command always runs to its completion before being executing whatever other commands were published to the server, i.e. the stalk stays on for the commanded duration, and cannot be commanded to turn off (or anything else) before the duration is up.  I think this may be becuase I am not including all the functionality of my multiprocessing-able objects in a run() function, but I've messed around with that with no luck.</p>	"
54681477,54684665,54681477,2,0,Thu Feb 14 06:51:00 EST 2019,504554,"<p>The Paho MQTT client is single threaded (the thread you start with the <code>client.loop_start()</code> function) it can only call <code>on_message()</code> for one message at a time.</p>		<p>This means it will block in the call to <code>eval()</code> until whatever was passed to it has finished, even if that is code is creating new threads to do things.</p>	"
54681477,96167444,54684665,3,0,Thu Feb 14 12:02:00 EST 2019,11059316,"Hm, so you're saying that even if the function called in eval() goes and runs in an independent thread, it must return before the on_message() can run again?	I might try testing that with a function that I know runs correctly in a threaded manner to confirm.  Thanks for the feedback!"
54681477,96178917,54684665,3,0,Thu Feb 14 17:10:00 EST 2019,504554,"Also using eval like this seems like a great way for an attacker to run arbitrary code..."
54681477,54686111,54681477,2,0,Thu Feb 14 08:34:00 EST 2019,388787,"<p>I was going to suggest replacing sleep with waiting with a timeout on a threading.Event or the equivalent and then checking when the sleep ends if it was due to the event being set or the timeout. If the event was set, stop.</p>		<p>But it seems there are other issues than just an interrupt-able sleep.</p>	"
54681477,96167520,54686111,3,0,Thu Feb 14 12:04:00 EST 2019,11059316,"It might be that the way around this is with an event scheduler like that, I might have to rework my class design to try that.  Thanks."
