thread_ID, Id, ParentId, PostType, Score, CreationDate, OwnerID, Body
31548067,31548067,null,1,3,Tue Jul 21 19:35:00 EDT 2015,2831106,"<p>While reading about various IoT messaging protocols I came across a structure defined as below:</p>		<pre><code>enum TempScale {	   CELSIUM,	   KELVIN,	   FARENHEIT	};		struct TempSensorType {	   short id;	   float temp;	   float hum;	   TempScale scale;	};	#pragma keylist TempSensorType id	</code></pre>		<p>My question is: What does this <em>#pragma keylist</em> keyword do and where can I find some documentation about using <em>#pragma</em> preprocessor directives (I believe it is such directive..).</p>		<p>Thanks.</p>	"
31548067,51054877,31548067,3,0,Tue Jul 21 19:40:00 EDT 2015,1413395,"Which particular compiler (version)?"
31548067,51078857,31548067,3,0,Wed Jul 22 11:16:00 EDT 2015,60281,"Any use of `#pragma` is **strictly implementation defined**. Indeed that is the *purpose* of `#pragma`. So the **only** place any `#pragma` *could* be documented is the compiler manual. (That `#pragma` is strictly non-portable should be obvious.)"
31548067,51103588,31548067,3,0,Wed Jul 22 21:30:00 EDT 2015,2831106,"Thanks DevSolar. This made me look into clang and gcc documentation and search there for pragmas."
31548067,31549654,31548067,2,4,Tue Jul 21 21:09:00 EDT 2015,352920,"<p>The #pragma you are looking at is the PrismTech method for defining a key value within an OMG-DDS (Data Distribution Service for Real-Time Systems) Type structure.  In this case, it is defining the short 'id' as a key value.  The comparable RTI definition would be</p>		<pre><code>struct TempSensorType {	    short id; //@key	    float temp;	    float hum;	    TempScale scale;	}	</code></pre>		<p>For interoperability between vendors' implementations, you can safely do</p>		<pre><code>struct TempSensorType {	    short id; //@key	    float temp;	    float hum;	    TempScale scale;	}	#pragma keylist TempSensorType id	</code></pre>		<p>because the RTI compiler ignores the pragmas, and the PT compiler ignores the //@key.</p>		<p>This will change with future versions of the specification for Extensible Types, which will define a standard method for all vendors to support.</p>		<p>Note that if you were looking at a generic list of IoT messaging protocols, the concept of a "key" value may not exist in the other messaging protocols you were looking at.</p>	"
31548067,31560795,31548067,2,0,Wed Jul 22 10:41:00 EDT 2015,2583463,"<p>Note that the explicit key-list specification via the pragma allows to define a ordering in the keys which - depending on the use-case - could have noticable performance impact on maintaining (filling/reading/querying/filtering) the 'multi-dimensional-storage' for a dataReader (and/or durability-service)</p>	"
31548067,31577517,31548067,2,0,Thu Jul 23 03:07:00 EDT 2015,2989341,"<p>Note that for DDS implementations that comply with the recently-adopted OMG DDS-XTYPES specification (<a href="http://www.omg.org/spec/DDS-XTypes/" rel="nofollow">http://www.omg.org/spec/DDS-XTypes/</a>) the standard portable way to specify keys is either:</p>		<pre><code>struct SensorType {	    @key short id;	    float temp;	    float hum;	    TempScale scale;	}	</code></pre>		<p>Or alternatively (to avoid breaking IDL compilers that do not understand the IDL annotations):</p>		<pre><code>struct SensorType {	    short id; //@key	    float temp;	    float hum;	    TempScale scale;	}	</code></pre>	"
